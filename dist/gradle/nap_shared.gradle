// TODO Later, devise a more Gradle-y way to do this logic sharing

// Recursively find dependencies for all specified NAP modules
ext.buildModuleDependencies = { foundModulesList, searchModulesList, projectName ->
    // Track new dependencies found in this iteration
    def newlyFoundModules = []

    // Iterate over our module we want to process for their dependencies
    for (String moduleName : searchModulesList) {
        def moduleJsonFile

        // Build the module.json path, based on whether it's a project module or NAP module
        if (moduleName == ('mod_' + projectName)) {
            moduleJsonFile = file('src/main/cpp/module/module.json')
        } else {
            moduleJsonFile = file(project.ext.get('NAP_ROOT') + '/modules/' + moduleName + '/module.json')
        }

        // Parse the module.json file
        def moduleParsedJson = new groovy.json.JsonSlurper().parseText(moduleJsonFile.text)

        // Iterate dependencies for the module, adding any new dependencies to our found modules list
        for (String dependentModuleName : moduleParsedJson.dependencies) {
            if (!foundModulesList.contains(dependentModuleName) && !newlyFoundModules.contains(dependentModuleName)) {
                newlyFoundModules.add(dependentModuleName)
            }
        }
    }

    if (newlyFoundModules.size() > 0) {
        // Extend our total dependent modules list with any new dependencies
        foundModulesList.addAll(newlyFoundModules)

        // Process the dependencies of the newly found dependencies
        buildModuleDependencies(foundModulesList, newlyFoundModules, projectName)
    }
}

// Copy module.json files into assets directory so they can be processed during initialisation 
// on device
ext.copyModuleJsonFilesIntoAssets = {napModules, napProjectName ->
    // Remove any existing directory
    def folder = new File('app/src/main/assets/nap_modules')
    if (folder.exists())
        folder.deleteDir()

    // Iterate and copy for each module
    def outputFolderPath
    def sourceModulePath
    for (String moduleName : napModules) {
        outputFolderPath = 'src/main/assets/nap_modules/' + moduleName

        // Build the module.json path, based on whether it's a project module or NAP module
        if (moduleName == ('mod_' + napProjectName)) {
            sourceModulePath = 'src/main/cpp/module/module.json'
        } else {
            sourceModulePath = project.ext.get('NAP_ROOT') + '/modules/' + moduleName + '/module.json'
        }
        copy {
            from sourceModulePath
            into outputFolderPath
        }
    }
}

// Process project module dependencies. If a project module exists its dependencies will also be generated
// separately for population through to CMake. module.json files are also copied into the asset folder.
ext.processNapDependencies = { napProjectName ->
    // Read main project.json
    def jsonFile = file('src/main/assets/project.json')
    def parsedJson = new groovy.json.JsonSlurper().parseText(jsonFile.text)
    def napModules = parsedJson.modules
    def searchModules = parsedJson.modules

    // Build entire NAP module dependencies for project
    buildModuleDependencies(napModules, searchModules, napProjectName)
    project.ext.set('NAP_MODULES', napModules)

    // If a project module exists, build the NAP module dependencies for the project module, for population
    // through to CMake
    def modulePath = new File(project.projectDir, '/src/main/cpp/module')
    if (modulePath.exists()) {
        def projectModuleFoundDependencies = []
        def projectModuleSearchModules = ['mod_' + napProjectName]
        buildModuleDependencies(projectModuleFoundDependencies, projectModuleSearchModules, napProjectName)
        project.ext.set('NAP_PROJECTMODULE_MODULES', projectModuleFoundDependencies)
    } else {
        project.ext.set('NAP_PROJECTMODULE_MODULES', [])        
    }

    // Copy module.json files into assets for reading on device
    copyModuleJsonFilesIntoAssets(napModules, napProjectName)
}

// Build shared library paths for including into APK
ext.getSharedLibSourceDirs = { napProjectName, buildType ->
    // Add RTTR and NAP core libraries
    def srcDirs = [project.NAP_ROOT + '/thirdparty/rttr/bin/' + buildType,
                   project.NAP_ROOT + '/lib/' + buildType
                   ]

    // If Python is in the framework release include the path
    def pythonPath = new File(project.NAP_ROOT + '/thirdparty/python')
    if (pythonPath.exists()) {
        srcDirs.add(project.NAP_ROOT + '/thirdparty/python' + '/lib/')
    }

    // Iterate all NAP modules for project
    for (String napModule : project.ext.get('NAP_MODULES')) {
        // If we're looking at a project module ignore it as this will already be included
        if (napModule == ("mod_" + napProjectName))
            continue

        srcDirs.add(project.NAP_ROOT + '/modules/' + napModule + '/lib/' + buildType)
    }
    
    return srcDirs    
}