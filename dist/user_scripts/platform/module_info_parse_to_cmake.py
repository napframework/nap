#!/usr/bin/env python3

import argparse
import json
import os
import sys

MODULE_INFO_FILENAME = 'module.json'
MODULE_INFO_CMAKE_CACHE_FILENAME = 'cached_module_json.cmake'

def find_module_json_by_module_name(module_name, nap_root):
    module_path = None
    # Check for NAP module in framework release
    if os.path.exists(os.path.join(nap_root, 'modules', module_name)):
        module_path = os.path.join(nap_root, 'modules', module_name)
    # Check for user module in framework release
    elif os.path.exists(os.path.join(nap_root, 'user_modules', module_name)):
        module_path = os.path.join(nap_root, 'user_modules', module_name)
    # Check for NAP module in NAP source
    elif module_name.startswith('mod_nap') and os.path.exists(os.path.join(nap_root, 'modules', module_name[4:])):
        module_path = os.path.join(nap_root, 'modules', module_name[4:])
    elif module_name.startswith('mod_') and os.path.exists(os.path.join(nap_root, '4dsound_modules', module_name[4:])):
        module_path = os.path.join(nap_root, '4dsound_modules', module_name[4:])

    if module_path is None:
        print("Couldn't find module %s" % module_name)
        return None
    else:
        return os.path.join(module_path, MODULE_INFO_FILENAME)

def find_new_dependencies_for_modules(new_dependencies, full_nap_modules, nap_root):
    output_dependencies = []
    for module_name in new_dependencies:
        module_json_path = find_module_json_by_module_name(module_name, nap_root)
        if module_json_path is None:
            return (False, None)
        else:
            dependencies_for_module = read_single_module_dependencies(module_json_path)
            for found_module_name in dependencies_for_module:
                if not found_module_name in full_nap_modules and not found_module_name in output_dependencies:
                    output_dependencies.append(found_module_name)

    return (True, output_dependencies)

def read_single_module_dependencies(module_json_path):
    # Read in the JSON
    with open(module_json_path) as json_file:
        json_dict = json.load(json_file)
        if not 'RequiredModules' in json_dict:
            print("Missing element 'RequiredModules' in %s" % module_json_path)
            return False

        if not type(json_dict['RequiredModules']) is list:
            print("Element 'RequiredModules' in %s is not an array" % MODULE_INFO_FILENAME)
            return False

        return json_dict['RequiredModules']

def update_module_info_to_cmake(module_path, nap_root):
    # Check our module exists
    if not os.path.exists(module_path):
        return False

    output_filename = os.path.join(module_path, MODULE_INFO_CMAKE_CACHE_FILENAME)

    # If any existing output file exists remove it.  This ensure that CMake will fail if our JSON parsing etc fails.
    if os.path.exists(output_filename):
        os.remove(output_filename)

    # Read in the JSON
    nap_modules = read_single_module_dependencies(os.path.join(module_path, MODULE_INFO_FILENAME))

    # Read full, deep, module dependencies
    full_nap_modules = []
    new_dependencies = nap_modules
    while len(new_dependencies) > 0:
        full_nap_modules.extend(new_dependencies)
        (success, new_dependencies) = find_new_dependencies_for_modules(new_dependencies, full_nap_modules, nap_root)
        if not success:
            return False

    # Write out
    with open(output_filename, 'w') as out_file:
        out_file.write("# Don't edit this file\n")
        out_file.write("#\n# It was auto generated by cmake from module.json which should be edited instead\n\n")
        out_file.write("set(DEPENDENT_NAP_MODULES %s)\n" % ' '.join(nap_modules))
        out_file.write("set(DEEP_DEPENDENT_NAP_MODULES %s)\n" % ' '.join(full_nap_modules))

    return True

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('MODULE_PATH')
    parser.add_argument('NAP_ROOT')
    args = parser.parse_args()

    if not update_module_info_to_cmake(args.MODULE_PATH, args.NAP_ROOT):
        sys.exit(1)
