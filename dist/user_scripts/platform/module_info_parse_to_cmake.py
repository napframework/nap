#!/usr/bin/python

import argparse
import json
import os
import sys

MODULE_INFO_FILENAME = 'module.json'
MODULE_INFO_CMAKE_CACHE_FILENAME = 'cached_module_json.cmake'

def update_module_info_to_cmake(module_path):
    # Check our module exists
    if not os.path.exists(module_path):
        return False

    output_filename = os.path.join(module_path, MODULE_INFO_CMAKE_CACHE_FILENAME)

    # If any existing output file exists remove it.  This ensure that CMake will fail if our JSON parsing etc fails.
    if os.path.exists(output_filename):
        os.remove(output_filename)

    # Read in the JSON
    with open(os.path.join(module_path, MODULE_INFO_FILENAME)) as json_file:
        json_dict = json.load(json_file)
        if not 'dependencies' in json_dict:
            print("Missing element 'dependencies' in %s" % MODULE_INFO_FILENAME)
            return False

        if not type(json_dict['dependencies']) is list:
            print("Element 'dependencies' in %s is not an array" % MODULE_INFO_FILENAME)
            return False

        nap_modules = ' '.join(json_dict['dependencies'])

    # Write out
    with open(output_filename, 'w') as out_file:
        out_file.write("# Don't edit this file\n")
        out_file.write("#\n# It was auto generated by cmake from module.json which should be edited instead\n\n")
        out_file.write("set(DEPENDENT_NAP_MODULES %s)\n" % nap_modules)

    return True

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('MODULE_PATH')
    args = parser.parse_args()

    if not update_module_info_to_cmake(args.MODULE_PATH):
        sys.exit(1)