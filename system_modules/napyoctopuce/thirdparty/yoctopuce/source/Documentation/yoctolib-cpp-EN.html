<HTML>
<HEAD>
<title>C++ API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cpp-EN.html 29804 2018-01-30 18:05:21Z mvuilleu $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - -
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce
 *    and Licensee are governed by Yoctopuce General Terms and
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute;
  left:0px;
  top:0px;
  width:800px;
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute;
  left:0px;
  top:80px;
  width:250px;
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;

}

div#FunctionsLayer
{ position:absolute;
  left:250px;
  top:80px;
  width:600px;
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute;
  left:0px;
  top:570px;
  width: 800px;
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute;
  width:10px;
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize;
}

div.container
{ width:100%;
  height:100%;
}

span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
}

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }

span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }

div.methodsList
 { margin-top:0px;
   padding-top:0px;
   padding-left:10px;
   margin-bottom:10px;
 }

div.methodsList A
 { color: navy;
   text-decoration:none;
 }

div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }

span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }

span#pn , td.pn
 { font-weight:bold;
   color:#004000;

 }

td.pn
 {vertical-align:top}

span.paramAndRet
 {font-weight:bold;

 }

table
 {font-size:14px;}

span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;
   background-color: #f8f8f8;
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }

p.protolabel
 { border-top:1px  solid #f0f0f0;
 }

P.protoretval
 { margin-left:20px;}

.paramtable
 { margin-left:20px; margin-top:0px;}

P.protoretval
 { margin-left:20px;}

input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }

td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040;
 }

td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }

p.methodlist
 { border-top:1px solid #e0e0e0;
 }

a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 }

span.synlist
 { margin-left:10px;
 }

p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }
</style>

<SCRIPT type="text/JavaScript">
<!--
var WinW;
var WinH;

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array();
var SVN_Id = '$Id: yoctolib-cpp-EN.html 29804 2018-01-30 18:05:21Z mvuilleu $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'General functions',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>These general functions should be used to initialize and configure the Yoctopuce library. In most cases, a simple call to function <tt>yRegisterHub()</tt> should be enough. The module-specific functions <tt>yFind...()</tt> or <tt>yFirst...()</tt> should then be used to retrieve an object that provides interaction with the module.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'Checks if a given string is valid as logical name for a module or a function.',lib:'YAPI::CheckLogicalName()',pro:'bool CheckLogicalName(const string&amp; <span id=pn>name</span>)',cmt:'<p>Checks if a given string is valid as logical name for a module or a function. A valid logical name has a maximum of 19 characters, all among <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt>, and <tt>-</tt>. If you try to configure a logical name with an incorrect string, the invalid characters are ignored.</p>',par:{name:'a string containing the name to check.'},ret:'<tt>true</tt> if the name is valid, <tt>false</tt> otherwise.'};
doc['YAPI']['DisableExceptions']={syn:'Disables the use of exceptions to report runtime errors.',lib:'YAPI::DisableExceptions()',pro:'void DisableExceptions()',cmt:'<p>Disables the use of exceptions to report runtime errors. When exceptions are disabled, every function returns a specific error value which depends on its type and which is documented in this reference manual.</p>'};
doc['YAPI']['EnableExceptions']={syn:'Re-enables the use of exceptions for runtime error handling.',lib:'YAPI::EnableExceptions()',pro:'void EnableExceptions()',cmt:'<p>Re-enables the use of exceptions for runtime error handling. Be aware than when exceptions are enabled, every function that fails triggers an exception. If the exception is not caught by the user code, it either fires the debugger or aborts (i.e. crash) the program. On failure, throws an exception or returns a negative error code.</p>'};
doc['YAPI']['FreeAPI']={syn:'Frees dynamically allocated memory blocks used by the Yoctopuce library.',lib:'YAPI::FreeAPI()',pro:'void FreeAPI()',cmt:'<p>Frees dynamically allocated memory blocks used by the Yoctopuce library. It is generally not required to call this function, unless you want to free all dynamically allocated memory blocks in order to track a memory leak for instance. You should not call any other library function after calling <tt>yFreeAPI()</tt>, or your program will crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Returns the version identifier for the Yoctopuce library in use.',lib:'YAPI::GetAPIVersion()',pro:'string GetAPIVersion()',cmt:'<p>Returns the version identifier for the Yoctopuce library in use. The version is a string in the form <tt>\x22Major.Minor.Build\x22</tt>, for instance <tt>\x221.01.5535\x22</tt>. For languages using an external DLL (for instance C#, VisualBasic or Delphi), the character string includes as well the DLL version, for instance <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> If you want to verify in your code that the library version is compatible with the version that you have used during development, verify that the major number is strictly equal and that the minor number is greater or equal. The build number is not relevant with respect to the library compatibility.</p>',ret:'a character string describing the library version.'};
doc['YAPI']['GetTickCount']={syn:'Returns the current value of a monotone millisecond-based time counter.',lib:'YAPI::GetTickCount()',pro:'u64 GetTickCount()',cmt:'<p>Returns the current value of a monotone millisecond-based time counter. This counter can be used to compute delays in relation with Yoctopuce devices, which also uses the millisecond as timebase.</p>',ret:'a long integer corresponding to the millisecond counter.'};
doc['YAPI']['HandleEvents']={syn:'Maintains the device-to-library communication channel.',lib:'YAPI::HandleEvents()',pro:'YRETCODE HandleEvents(string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Maintains the device-to-library communication channel. If your program includes significant loops, you may want to include a call to this function to make sure that the library takes care of the information pushed by the modules on the communication channels. This is not strictly necessary, but it may improve the reactivity of the library for the following commands.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['InitAPI']={syn:'Initializes the Yoctopuce programming library explicitly.',lib:'YAPI::InitAPI()',pro:'YRETCODE InitAPI(int <span id=pn>mode</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Initializes the Yoctopuce programming library explicitly. It is not strictly needed to call <tt>yInitAPI()</tt>, as the library is automatically initialized when calling <tt>yRegisterHub()</tt> for the first time.</p><p> When <tt>Y_DETECT_NONE</tt> is used as detection <tt>mode</tt>, you must explicitly use <tt>yRegisterHub()</tt> to point the API to the VirtualHub on which your devices are connected before trying to access them.</p>',par:{mode:'an integer corresponding to the type of automatic device detection to use. Possible values are <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt>, and <tt>Y_DETECT_ALL</tt>.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['PreregisterHub']={syn:'Fault-tolerant alternative to <tt>RegisterHub()</tt>.',lib:'YAPI::PreregisterHub()',pro:'YRETCODE PreregisterHub(const string&amp; <span id=pn>url</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Fault-tolerant alternative to <tt>RegisterHub()</tt>. This function has the same purpose and same arguments as <tt>RegisterHub()</tt>, but does not trigger an error when the selected hub is not available at the time of the function call. This makes it possible to register a network hub independently of the current connectivity, and to try to contact it only when a device is actively needed.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Register a callback function, to be called each time a device is plugged.',lib:'YAPI::RegisterDeviceArrivalCallback()',pro:'void RegisterDeviceArrivalCallback(yDeviceUpdateCallback <span id=pn>arrivalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is plugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{arrivalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Register a callback function, to be called each time a device is unplugged.',lib:'YAPI::RegisterDeviceRemovalCallback()',pro:'void RegisterDeviceRemovalCallback(yDeviceUpdateCallback <span id=pn>removalCallback</span>)',cmt:'<p>Register a callback function, to be called each time a device is unplugged. This callback will be invoked while <tt>yUpdateDeviceList</tt> is running. You will have to call this function on a regular basis.</p>',par:{removalCallback:'a procedure taking a <tt>YModule</tt> parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterHub']={syn:'Setup the Yoctopuce library to use modules connected on a given machine.',lib:'YAPI::RegisterHub()',pro:'YRETCODE RegisterHub(const string&amp; <span id=pn>url</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Setup the Yoctopuce library to use modules connected on a given machine. The parameter will determine how the API will work. Use the following values:</p><p> <b>usb</b>: When the <ui>usb</ui> keyword is used, the API will work with devices connected directly to the USB bus. Some programming languages such a Javascript, PHP, and Java don\x27t provide direct access to USB hardware, so <ui>usb</ui> will not work with these. In this case, use a VirtualHub or a networked YoctoHub (see below).</p><p> <b><i>x.x.x.x</i></b> or <b><i>hostname</i></b>: The API will use the devices connected to the host with the given IP address or hostname. That host can be a regular computer running a VirtualHub, or a networked YoctoHub such as YoctoHub-Ethernet or YoctoHub-Wireless. If you want to use the VirtualHub running on you local computer, use the IP address 127.0.0.1.</p><p> <b>callback</b>: that keyword make the API run in \x22<i>HTTP Callback</i>\x22 mode. This a special mode allowing to take control of Yoctopuce devices through a NAT filter when using a VirtualHub or a networked YoctoHub. You only need to configure your hub to call your server script on a regular basis. This mode is currently available for PHP and Node.JS only.</p><p> Be aware that only one application can use direct USB access at a given time on a machine. Multiple access would cause conflicts while trying to access the USB modules. In particular, this means that you must stop the VirtualHub software before starting an application that uses direct USB access. The workaround for this limitation is to setup the library to use the VirtualHub rather than direct USB access.</p><p> If access control has been activated on the hub, virtual or not, you want to reach, the URL parameter should look like:</p><p> <tt>http://username:password@address:port</tt></p><p> You can call <i>RegisterHub</i> several times to connect to several machines.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['RegisterHubDiscoveryCallback']={syn:'Register a callback function, to be called each time an Network Hub send an SSDP message.',lib:'YAPI::RegisterHubDiscoveryCallback()',pro:'void RegisterHubDiscoveryCallback(YHubDiscoveryCallback <span id=pn>hubDiscoveryCallback</span>)',cmt:'<p>Register a callback function, to be called each time an Network Hub send an SSDP message. The callback has two string parameter, the first one contain the serial number of the hub and the second contain the URL of the network hub (this URL can be passed to RegisterHub). This callback will be invoked while yUpdateDeviceList is running. You will have to call this function on a regular basis.</p>',par:{hubDiscoveryCallback:'a procedure taking two string parameter, the serial number and the hub URL. Use <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['RegisterLogFunction']={syn:'Registers a log callback function.',lib:'YAPI::RegisterLogFunction()',pro:'void RegisterLogFunction(yLogFunction <span id=pn>logfun</span>)',cmt:'<p>Registers a log callback function. This callback will be called each time the API have something to say. Quite useful to debug the API.</p>',par:{logfun:'a procedure taking a string parameter, or <tt>null</tt> to unregister a previously registered callback.'}};
doc['YAPI']['Sleep']={syn:'Pauses the execution flow for a specified duration.',lib:'YAPI::Sleep()',pro:'YRETCODE Sleep(unsigned <span id=pn>ms_duration</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Pauses the execution flow for a specified duration. This function implements a passive waiting loop, meaning that it does not consume CPU cycles significantly. The processor is left available for other threads and processes. During the pause, the library nevertheless reads from time to time information from the Yoctopuce modules by calling <tt>yHandleEvents()</tt>, in order to stay up-to-date.</p><p> This function may signal an error in case there is a communication problem while contacting a module.</p>',par:{ms_duration:'an integer corresponding to the duration of the pause, in milliseconds.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['TestHub']={syn:'Test if the hub is reachable.',lib:'YAPI::TestHub()',pro:'YRETCODE TestHub(const string&amp; <span id=pn>url</span>, int <span id=pn>mstimeout</span>, string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Test if the hub is reachable. This method do not register the hub, it only test if the hub is usable. The url parameter follow the same convention as the <tt>RegisterHub</tt> method. This method is useful to verify the authentication parameters for a hub. It is possible to force this method to return after mstimeout milliseconds.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui>,<ui>\x22callback\x22</ui> or the root URL of the hub to monitor',mstimeout:'the number of millisecond available to test the connection.',errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure returns a negative error code.'};
doc['YAPI']['TriggerHubDiscovery']={syn:'Force a hub discovery, if a callback as been registered with <tt>yRegisterHubDiscoveryCallback</tt> it will be called for each net work hub that will respond to the discovery.',lib:'YAPI::TriggerHubDiscovery()',pro:'YRETCODE TriggerHubDiscovery(string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Force a hub discovery, if a callback as been registered with <tt>yRegisterHubDiscoveryCallback</tt> it will be called for each net work hub that will respond to the discovery.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['YAPI']['UnregisterHub']={syn:'Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.',lib:'YAPI::UnregisterHub()',pro:'void UnregisterHub(const string&amp; <span id=pn>url</span>)',cmt:'<p>Setup the Yoctopuce library to no more use modules connected on a previously registered machine with RegisterHub.</p>',par:{url:'a string containing either <ui>\x22usb\x22</ui> or the root URL of the hub to monitor'}};
doc['YAPI']['UpdateDeviceList']={syn:'Triggers a (re)detection of connected Yoctopuce modules.',lib:'YAPI::UpdateDeviceList()',pro:'YRETCODE UpdateDeviceList(string&amp; <span id=pn>errmsg</span>)',cmt:'<p>Triggers a (re)detection of connected Yoctopuce modules. The library searches the machines or USB ports previously registered using <tt>yRegisterHub()</tt>, and invokes any user-defined callback function in case a change in the list of connected devices is detected.</p><p> This function can be called as frequently as desired to refresh the device list and to make the application aware of hot-plug events.</p>',par:{errmsg:'a string passed by reference to receive any error message.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: YAPI)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'Unformatted data sequence',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>YDataStream objects represent bare recorded measure sequences, exactly as found within the data logger present on Yoctopuce sensors.</p><p> In most cases, it is not necessary to use YDataStream objects directly, as the YDataSet objects (returned by the <tt>get_recordedData()</tt> method from sensors and the <tt>get_dataSets()</tt> method from the data logger) provide a more convenient interface.</p>'}};
doc['DataStream']['get_averageValue']={syn:'Returns the average of all measures observed within this stream.',lib:'datastream&rarr;get_averageValue()',pro:'double get_averageValue()',cmt:'<p>Returns the average of all measures observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the average value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_columnCount']={syn:'Returns the number of data columns present in this stream.',lib:'datastream&rarr;get_columnCount()',pro:'int get_columnCount()',cmt:'<p>Returns the number of data columns present in this stream. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'an unsigned number corresponding to the number of columns.',ext:'On failure, throws an exception or returns zero.'};
doc['DataStream']['get_columnNames']={syn:'Returns the title (or meaning) of each data column present in this stream.',lib:'datastream&rarr;get_columnNames()',pro:'vector&lt;string&gt; get_columnNames()',cmt:'<p>Returns the title (or meaning) of each data column present in this stream. In most case, the title of the data column is the hardware identifier of the sensor that produced the data. For streams recorded at a lower recording rate, the dataLogger stores the min, average and max value during each measure interval into three columns with suffixes _min, _avg and _max respectively.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'a list containing as many strings as there are columns in the data stream.',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_data']={syn:'Returns a single measure from the data stream, specified by its row and column index.',lib:'datastream&rarr;get_data()',pro:'double get_data(int <span id=pn>row</span>, int <span id=pn>col</span>)',cmt:'<p>Returns a single measure from the data stream, specified by its row and column index. The meaning of the values present in each column can be obtained using the method get_columnNames().</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',par:{row:'row index',col:'column index'},ret:'a floating-point number',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Returns the whole data set contained in the stream, as a bidimensional table of numbers.',lib:'datastream&rarr;get_dataRows()',pro:'vector&lt; vector&lt;double&gt; &gt; get_dataRows()',cmt:'<p>Returns the whole data set contained in the stream, as a bidimensional table of numbers. The meaning of the values present in each column can be obtained using the method <tt>get_columnNames()</tt>.</p><p> This method fetches the whole data stream from the device, if not yet done.</p>',ret:'a list containing as many elements as there are rows in the data stream. Each row itself is a list of floating-point numbers.',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataStream']['get_dataSamplesIntervalMs']={syn:'Returns the number of milliseconds between two consecutive rows of this data stream.',lib:'datastream&rarr;get_dataSamplesIntervalMs()',pro:'int get_dataSamplesIntervalMs()',cmt:'<p>Returns the number of milliseconds between two consecutive rows of this data stream. By default, the data logger records one row per second, but the recording frequency can be changed for each device function</p>',ret:'an unsigned number corresponding to a number of milliseconds.'};
doc['DataStream']['get_duration']={syn:'Returns the approximate duration of this stream, in seconds.',lib:'datastream&rarr;get_duration()',pro:'int get_duration()',cmt:'<p>Returns the approximate duration of this stream, in seconds.</p>',ret:'the number of seconds covered by this stream.',ext:'On failure, throws an exception or returns Y_DURATION_INVALID.'};
doc['DataStream']['get_maxValue']={syn:'Returns the largest measure observed within this stream.',lib:'datastream&rarr;get_maxValue()',pro:'double get_maxValue()',cmt:'<p>Returns the largest measure observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the largest value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_minValue']={syn:'Returns the smallest measure observed within this stream.',lib:'datastream&rarr;get_minValue()',pro:'double get_minValue()',cmt:'<p>Returns the smallest measure observed within this stream. If the device uses a firmware older than version 13000, this method will always return Y_DATA_INVALID.</p>',ret:'a floating-point number corresponding to the smallest value, or Y_DATA_INVALID if the stream is not yet complete (still recording).',ext:'On failure, throws an exception or returns Y_DATA_INVALID.'};
doc['DataStream']['get_rowCount']={syn:'Returns the number of data rows present in this stream.',lib:'datastream&rarr;get_rowCount()',pro:'int get_rowCount()',cmt:'<p>Returns the number of data rows present in this stream.</p><p> If the device uses a firmware older than version 13000, this method fetches the whole data stream from the device if not yet done, which can cause a little delay.</p>',ret:'an unsigned number corresponding to the number of rows.',ext:'On failure, throws an exception or returns zero.'};
doc['DataStream']['get_runIndex']={syn:'Returns the run index of the data stream.',lib:'datastream&rarr;get_runIndex()',pro:'int get_runIndex()',cmt:'<p>Returns the run index of the data stream. A run can be made of multiple datastreams, for different time intervals.</p>',ret:'an unsigned number corresponding to the run index.'};
doc['DataStream']['get_startTime']={syn:'Returns the relative start time of the data stream, measured in seconds.',lib:'datastream&rarr;get_startTime()',pro:'int get_startTime()',cmt:'<p>Returns the relative start time of the data stream, measured in seconds. For recent firmwares, the value is relative to the present time, which means the value is always negative. If the device uses a firmware older than version 13000, value is relative to the start of the time the device was powered on, and is always positive. If you need an absolute UTC timestamp, use <tt>get_startTimeUTC()</tt>.</p>',ret:'an unsigned number corresponding to the number of seconds between the start of the run and the beginning of this data stream.'};
doc['DataStream']['get_startTimeUTC']={syn:'Returns the start time of the data stream, relative to the Jan 1, 1970.',lib:'datastream&rarr;get_startTimeUTC()',pro:'s64 get_startTimeUTC()',cmt:'<p>Returns the start time of the data stream, relative to the Jan 1, 1970. If the UTC time was not set in the datalogger at the time of the recording of this data stream, this method returns 0.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data stream (i.e. Unix time representation of the absolute time).'};
//--- (end of generated code: DataStream)
//--- (generated code: Module)
var Language='C++';
var IncludeLabel='In order to use the functions described here, you should include:';
var ParamLabel='Parameters :';
var ReturnLabel='Returns :';
var AbbrevHint='The API features two syntaxes : one is purely object oriented, the other is more compact.';
var NotFound='No match found';
var AbbrevLabel='Use abbreviated names';
var UseShortcuts=true;
var sub={YAPI_SUCCESS:'YAPI::SUCCESS',YAPI_NOT_INITIALIZED:'YAPI::NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI::INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI::NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI::DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI::VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI::DEVICE_BUSY',YAPI_TIMEOUT:'YAPI::TIMEOUT',YAPI_IO_ERROR:'YAPI::IO_ERROR',YAPI_NO_MORE_DATA:'YAPI::NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI::EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI::DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI::UNAUTHORIZED',YAPI_RTC_NOT_READY:'YAPI::RTC_NOT_READY',YAPI_FILE_NOT_FOUND:'YAPI::FILE_NOT_FOUND',null:'NULL'};
doc['Module']={'':{syn:'Module control interface',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>This interface is identical for all Yoctopuce USB modules. It can be used to control the module global parameters, and to enumerate the functions provided by each module.</p>'}};
doc['Module']['FindModule']={syn:'Allows you to find a module from its serial number or from its logical name.',lib:'YModule::FindModule()',pro:'YModule* FindModule(string <span id=pn>func</span>)',cmt:'<p>Allows you to find a module from its serial number or from its logical name.</p><p> This function does not require that the module is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YModule.isOnline()</tt> to test if the module is indeed online at a given time. In case of ambiguity when looking for a module by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string containing either the serial number or the logical name of the desired module'},ret:'a <tt>YModule</tt> object allowing you to drive the module or get additional information on the module.'};
doc['Module']['FirstModule']={syn:'Starts the enumeration of modules currently accessible.',lib:'YModule::FirstModule()',pro:'YModule* FirstModule()',cmt:'<p>Starts the enumeration of modules currently accessible. Use the method <tt>YModule.nextModule()</tt> to iterate on the next modules.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the first module currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Module']['checkFirmware']={syn:'Tests whether the byn file is valid for this module.',lib:'module&rarr;checkFirmware()',pro:'string checkFirmware(string <span id=pn>path</span>, bool <span id=pn>onlynew</span>)',cmt:'<p>Tests whether the byn file is valid for this module. This method is useful to test if the module needs to be updated. It is possible to pass a directory as argument instead of a file. In this case, this method returns the path of the most recent appropriate <tt>.byn</tt> file. If the parameter <tt>onlynew</tt> is true, the function discards firmwares that are older or equal to the installed firmware.</p>',par:{path:'the path of a byn file or a directory that contains byn files',onlynew:'returns only files that are strictly newer'},ret:'the path of the byn file to use or a empty string if no byn files matches the requirement',ext:'On failure, throws an exception or returns a string that start with \x22error:\x22.'};
doc['Module']['clearCache']={syn:'Invalidates the cache.',lib:'module&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Module']['describe']={syn:'Returns a descriptive text that identifies the module.',lib:'module&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a descriptive text that identifies the module. The text may include either the logical name or the serial number of the module.</p>',ret:'a string that describes the module'};
doc['Module']['download']={syn:'Downloads the specified built-in file and returns a binary buffer with its content.',lib:'module&rarr;download()',pro:'string download(string <span id=pn>pathname</span>)',cmt:'<p>Downloads the specified built-in file and returns a binary buffer with its content.</p>',par:{pathname:'name of the new file to load'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['functionBaseType']={syn:'Retrieves the base type of the <i>n</i>th function on the module.',lib:'module&rarr;functionBaseType()',pro:'string functionBaseType(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the base type of the <i>n</i>th function on the module. For instance, the base type of all measuring functions is \x22Sensor\x22.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the base type of the function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionCount']={syn:'Returns the number of functions (beside the \x22module\x22 interface) available on the module.',lib:'module&rarr;functionCount()',pro:'int functionCount()',cmt:'<p>Returns the number of functions (beside the \x22module\x22 interface) available on the module.</p>',ret:'the number of functions on the module',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['functionId']={syn:'Retrieves the hardware identifier of the <i>n</i>th function on the module.',lib:'module&rarr;functionId()',pro:'string functionId(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the hardware identifier of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the unambiguous hardware identifier of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionName']={syn:'Retrieves the logical name of the <i>n</i>th function on the module.',lib:'module&rarr;functionName()',pro:'string functionName(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the logical name of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the logical name of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionType']={syn:'Retrieves the type of the <i>n</i>th function on the module.',lib:'module&rarr;functionType()',pro:'string functionType(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the type of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a string corresponding to the type of the function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['functionValue']={syn:'Retrieves the advertised value of the <i>n</i>th function on the module.',lib:'module&rarr;functionValue()',pro:'string functionValue(int <span id=pn>functionIndex</span>)',cmt:'<p>Retrieves the advertised value of the <i>n</i>th function on the module.</p>',par:{functionIndex:'the index of the function for which the information is desired, starting at 0 for the first function.'},ret:'a short string (up to 6 characters) corresponding to the advertised value of the requested module function',ext:'On failure, throws an exception or returns an empty string.'};
doc['Module']['get_allSettings']={syn:'Returns all the settings and uploaded files of the module.',lib:'module&rarr;get_allSettings()',pro:'string get_allSettings()',cmt:'<p>Returns all the settings and uploaded files of the module. Useful to backup all the logical names, calibrations parameters, and uploaded files of a device.</p>',ret:'a binary buffer with all the settings.',ext:'On failure, throws an exception or returns an binary object of size 0.'};
doc['Module']['get_beacon']={syn:'Returns the state of the localization beacon.',lib:'module&rarr;get_beacon()',pro:'Y_BEACON_enum get_beacon()',cmt:'<p>Returns the state of the localization beacon.</p>',ret:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>, according to the state of the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Returns the error message of the latest error with this module object.',lib:'module&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this module object'};
doc['Module']['get_errorType']={syn:'Returns the numerical error code of the latest error with this module object.',lib:'module&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this module object. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using this module object'};
doc['Module']['get_firmwareRelease']={syn:'Returns the version of the firmware embedded in the module.',lib:'module&rarr;get_firmwareRelease()',pro:'string get_firmwareRelease()',cmt:'<p>Returns the version of the firmware embedded in the module.</p>',ret:'a string corresponding to the version of the firmware embedded in the module',ext:'On failure, throws an exception or returns <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_functionIds']={syn:'Retrieve all hardware identifier that match the type passed in argument.',lib:'module&rarr;get_functionIds()',pro:'vector&lt;string&gt; get_functionIds(string <span id=pn>funType</span>)',cmt:'<p>Retrieve all hardware identifier that match the type passed in argument.</p>',par:{funType:'The type of function (Relay, LightSensor, Voltage,...)'},ret:'an array of strings.'};
doc['Module']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module.',lib:'module&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module. The unique hardware identifier is made of the device serial number followed by string \x22.module\x22.</p>',ret:'a string that uniquely identifies the module'};
doc['Module']['get_icon2d']={syn:'Returns the icon of the module.',lib:'module&rarr;get_icon2d()',pro:'string get_icon2d()',cmt:'<p>Returns the icon of the module. The icon is a PNG image and does not exceeds 1536 bytes.</p>',ret:'a binary buffer with module icon, in png format. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_lastLogs']={syn:'Returns a string with last logs of the module.',lib:'module&rarr;get_lastLogs()',pro:'string get_lastLogs()',cmt:'<p>Returns a string with last logs of the module. This method return only logs that are still in the module.</p>',ret:'a string with last logs of the module. On failure, throws an exception or returns <tt>YAPI_INVALID_STRING</tt>.'};
doc['Module']['get_logicalName']={syn:'Returns the logical name of the module.',lib:'module&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the module.</p>',ret:'a string corresponding to the logical name of the module',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'module&rarr;get_luminosity()',pro:'int get_luminosity()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_parentHub']={syn:'Returns the serial number of the YoctoHub on which this module is connected.',lib:'module&rarr;get_parentHub()',pro:'string get_parentHub()',cmt:'<p>Returns the serial number of the YoctoHub on which this module is connected. If the module is connected by USB, or if the module is the root YoctoHub, an empty string is returned.</p>',ret:'a string with the serial number of the YoctoHub or an empty string'};
doc['Module']['get_persistentSettings']={syn:'Returns the current state of persistent module settings.',lib:'module&rarr;get_persistentSettings()',pro:'Y_PERSISTENTSETTINGS_enum get_persistentSettings()',cmt:'<p>Returns the current state of persistent module settings.</p>',ret:'a value among <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> and <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> corresponding to the current state of persistent module settings',ext:'On failure, throws an exception or returns <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Returns the USB device identifier of the module.',lib:'module&rarr;get_productId()',pro:'int get_productId()',cmt:'<p>Returns the USB device identifier of the module.</p>',ret:'an integer corresponding to the USB device identifier of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Returns the commercial name of the module, as set by the factory.',lib:'module&rarr;get_productName()',pro:'string get_productName()',cmt:'<p>Returns the commercial name of the module, as set by the factory.</p>',ret:'a string corresponding to the commercial name of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Returns the hardware release version of the module.',lib:'module&rarr;get_productRelease()',pro:'int get_productRelease()',cmt:'<p>Returns the hardware release version of the module.</p>',ret:'an integer corresponding to the hardware release version of the module',ext:'On failure, throws an exception or returns <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.',lib:'module&rarr;get_rebootCountdown()',pro:'int get_rebootCountdown()',cmt:'<p>Returns the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the module restarts, or zero when no reboot has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Returns the serial number of the module, as set by the factory.',lib:'module&rarr;get_serialNumber()',pro:'string get_serialNumber()',cmt:'<p>Returns the serial number of the module, as set by the factory.</p>',ret:'a string corresponding to the serial number of the module, as set by the factory',ext:'On failure, throws an exception or returns <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_subDevices']={syn:'Returns a list of all the modules that are plugged into the current module.',lib:'module&rarr;get_subDevices()',pro:'vector&lt;string&gt; get_subDevices()',cmt:'<p>Returns a list of all the modules that are plugged into the current module. This method only makes sense when called for a YoctoHub/VirtualHub. Otherwise, an empty array will be returned.</p>',ret:'an array of strings containing the sub modules.'};
doc['Module']['get_upTime']={syn:'Returns the number of milliseconds spent since the module was powered on.',lib:'module&rarr;get_upTime()',pro:'s64 get_upTime()',cmt:'<p>Returns the number of milliseconds spent since the module was powered on.</p>',ret:'an integer corresponding to the number of milliseconds spent since the module was powered on',ext:'On failure, throws an exception or returns <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_url']={syn:'Returns the URL used to access the module.',lib:'module&rarr;get_url()',pro:'string get_url()',cmt:'<p>Returns the URL used to access the module. If the module is connected by USB, the string \x27usb\x27 is returned.</p>',ret:'a string with the URL of the module.'};
doc['Module']['get_usbCurrent']={syn:'Returns the current consumed by the module on the USB bus, in milli-amps.',lib:'module&rarr;get_usbCurrent()',pro:'int get_usbCurrent()',cmt:'<p>Returns the current consumed by the module on the USB bus, in milli-amps.</p>',ret:'an integer corresponding to the current consumed by the module on the USB bus, in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'module&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Module']['get_userVar']={syn:'Returns the value previously stored in this attribute.',lib:'module&rarr;get_userVar()',pro:'int get_userVar()',cmt:'<p>Returns the value previously stored in this attribute. On startup and after a device reboot, the value is always reset to zero.</p>',ret:'an integer corresponding to the value previously stored in this attribute',ext:'On failure, throws an exception or returns <tt>Y_USERVAR_INVALID</tt>.'};
doc['Module']['hasFunction']={syn:'Tests if the device includes a specific function.',lib:'module&rarr;hasFunction()',pro:'bool hasFunction(string <span id=pn>funcId</span>)',cmt:'<p>Tests if the device includes a specific function. This method takes a function identifier and returns a boolean.</p>',par:{funcId:'the requested function identifier'},ret:'true if the device has the function identifier'};
doc['Module']['isOnline']={syn:'Checks if the module is currently reachable, without raising any error.',lib:'module&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the module is currently reachable, without raising any error. If there are valid cached values for the module, that have not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the requested module.</p>',ret:'<tt>true</tt> if the module can be reached, and <tt>false</tt> otherwise'};
doc['Module']['load']={syn:'Preloads the module cache with a specified validity duration.',lib:'module&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the module cache with a specified validity duration. By default, whenever accessing a device, all module attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded module parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['log']={syn:'Adds a text message to the device logs.',lib:'module&rarr;log()',pro:'int log(string <span id=pn>text</span>)',cmt:'<p>Adds a text message to the device logs. This function is useful in particular to trace the execution of HTTP callbacks. If a newline is desired after the message, it must be included in the string.</p>',par:{text:'the string to append to the logs.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['nextModule']={syn:'Continues the module enumeration started using <tt>yFirstModule()</tt>.',lib:'module&rarr;nextModule()',pro:'YModule * nextModule()',cmt:'<p>Continues the module enumeration started using <tt>yFirstModule()</tt>.</p>',ret:'a pointer to a <tt>YModule</tt> object, corresponding to the next module found, or a <tt>null</tt> pointer if there are no more modules to enumerate.'};
doc['Module']['reboot']={syn:'Schedules a simple module reboot after the given number of seconds.',lib:'module&rarr;reboot()',pro:'int reboot(int <span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a simple module reboot after the given number of seconds.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['registerLogCallback']={syn:'Registers a device log callback function.',lib:'module&rarr;registerLogCallback()',pro:'void registerLogCallback(YModuleLogCallback <span id=pn>callback</span>)',cmt:'<p>Registers a device log callback function. This callback will be called each time that a module sends a new log message. Mostly useful to debug a Yoctopuce module.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the module object that emitted the log message, and the character string containing the log.'}};
doc['Module']['revertFromFlash']={syn:'Reloads the settings stored in the nonvolatile memory, as when the module is powered on.',lib:'module&rarr;revertFromFlash()',pro:'int revertFromFlash()',cmt:'<p>Reloads the settings stored in the nonvolatile memory, as when the module is powered on.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['saveToFlash']={syn:'Saves current settings in the nonvolatile memory of the module.',lib:'module&rarr;saveToFlash()',pro:'int saveToFlash()',cmt:'<p>Saves current settings in the nonvolatile memory of the module. Warning: the number of allowed save operations during a module life is limited (about 100000 cycles). Do not call this function within a loop.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettings']={syn:'Restores all the settings of the device.',lib:'module&rarr;set_allSettings()',pro:'int set_allSettings(string <span id=pn>settings</span>)',cmt:'<p>Restores all the settings of the device. Useful to restore all the logical names and calibrations parameters of a module from a backup.Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_allSettingsAndFiles']={syn:'Restores all the settings and uploaded files to the module.',lib:'module&rarr;set_allSettingsAndFiles()',pro:'int set_allSettingsAndFiles(string <span id=pn>settings</span>)',cmt:'<p>Restores all the settings and uploaded files to the module. This method is useful to restore all the logical names and calibrations parameters, uploaded files etc. of a device from a backup. Remember to call the <tt>saveToFlash()</tt> method of the module if the modifications must be kept.</p>',par:{settings:'a binary buffer with all the settings.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_beacon']={syn:'Turns on or off the module localization beacon.',lib:'module&rarr;set_beacon()',pro:'int set_beacon(Y_BEACON_enum <span id=pn>newval</span>)',cmt:'<p>Turns on or off the module localization beacon.</p>',par:{newval:'either <tt>Y_BEACON_OFF</tt> or <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_logicalName']={syn:'Changes the logical name of the module.',lib:'module&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_luminosity']={syn:'Changes the luminosity of the module informative leds.',lib:'module&rarr;set_luminosity()',pro:'int set_luminosity(int <span id=pn>newval</span>)',cmt:'<p>Changes the luminosity of the module informative leds. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the luminosity of the module informative leds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'module&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Module']['set_userVar']={syn:'Stores a 32 bit value in the device RAM.',lib:'module&rarr;set_userVar()',pro:'int set_userVar(int <span id=pn>newval</span>)',cmt:'<p>Stores a 32 bit value in the device RAM. This attribute is at programmer disposal, should he need to store a state variable. On startup and after a device reboot, the value is always reset to zero.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['triggerFirmwareUpdate']={syn:'Schedules a module reboot into special firmware update mode.',lib:'module&rarr;triggerFirmwareUpdate()',pro:'int triggerFirmwareUpdate(int <span id=pn>secBeforeReboot</span>)',cmt:'<p>Schedules a module reboot into special firmware update mode.</p>',par:{secBeforeReboot:'number of seconds before rebooting'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Module']['updateFirmware']={syn:'Prepares a firmware update of the module.',lib:'module&rarr;updateFirmware()',pro:'YFirmwareUpdate updateFirmware(string <span id=pn>path</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'};
doc['Module']['updateFirmwareEx']={syn:'Prepares a firmware update of the module.',lib:'module&rarr;updateFirmwareEx()',pro:'YFirmwareUpdate updateFirmwareEx(string <span id=pn>path</span>, bool <span id=pn>force</span>)',cmt:'<p>Prepares a firmware update of the module. This method returns a <tt>YFirmwareUpdate</tt> object which handles the firmware update process.</p>',par:{path:'the path of the <tt>.byn</tt> file to use.',force:'true to force the firmware update even if some prerequisites appear not to be met'},ret:'a <tt>YFirmwareUpdate</tt> object or NULL on error.'};
//--- (end of generated code: Module)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Temperature function interface',inc:'#include &quot;yocto_temperature.h&quot;',cmt:'<p>The Yoctopuce class YTemperature allows you to read and configure Yoctopuce temperature sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure some specific parameters for some sensors (connection type, temperature mapping table).</p>'}};
doc['Temperature']['FindTemperature']={syn:'Retrieves a temperature sensor for a given identifier.',lib:'YTemperature::FindTemperature()',pro:'YTemperature* FindTemperature(string <span id=pn>func</span>)',cmt:'<p>Retrieves a temperature sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the temperature sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTemperature.isOnline()</tt> to test if the temperature sensor is indeed online at a given time. In case of ambiguity when looking for a temperature sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the temperature sensor'},ret:'a <tt>YTemperature</tt> object allowing you to drive the temperature sensor.'};
doc['Temperature']['FirstTemperature']={syn:'Starts the enumeration of temperature sensors currently accessible.',lib:'YTemperature::FirstTemperature()',pro:'YTemperature* FirstTemperature()',cmt:'<p>Starts the enumeration of temperature sensors currently accessible. Use the method <tt>YTemperature.nextTemperature()</tt> to iterate on next temperature sensors.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to the first temperature sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Temperature']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'temperature&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['clearCache']={syn:'Invalidates the cache.',lib:'temperature&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the temperature sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Temperature']['describe']={syn:'Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the temperature sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the temperature sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Temperature']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'temperature&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Temperature']['get_advertisedValue']={syn:'Returns the current value of the temperature sensor (no more than 6 characters).',lib:'temperature&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the temperature sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the temperature sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.',lib:'temperature&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Returns the current value of the temperature, in Celsius, as a floating point number.',lib:'temperature&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the temperature, in Celsius, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the temperature, in Celsius, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'temperature&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Temperature']['get_errorMessage']={syn:'Returns the error message of the latest error with the temperature sensor.',lib:'temperature&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the temperature sensor object'};
doc['Temperature']['get_errorType']={syn:'Returns the numerical error code of the latest error with the temperature sensor.',lib:'temperature&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the temperature sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the temperature sensor object'};
doc['Temperature']['get_friendlyName']={syn:'Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'temperature&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the temperature sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the temperature sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the temperature sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the temperature sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Temperature']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'temperature&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Temperature']['get_functionId']={syn:'Returns the hardware identifier of the temperature sensor, without reference to the module.',lib:'temperature&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the temperature sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the temperature sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Temperature']['get_hardwareId']={syn:'Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'temperature&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the temperature sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the temperature sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the temperature sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Returns the maximal value observed for the temperature since the device was started.',lib:'temperature&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'temperature&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Returns the logical name of the temperature sensor.',lib:'temperature&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the temperature sensor.</p>',ret:'a string corresponding to the logical name of the temperature sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Returns the minimal value observed for the temperature since the device was started.',lib:'temperature&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the temperature since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the temperature since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'temperature&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Temperature']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'temperature&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Temperature']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'temperature&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Temperature']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'temperature&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'temperature&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Returns the temperature sensor type.',lib:'temperature&rarr;get_sensorType()',pro:'Y_SENSORTYPE_enum get_sensorType()',cmt:'<p>Returns the temperature sensor type.</p>',ret:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt>, <tt>Y_SENSORTYPE_RES_LINEAR</tt> and <tt>Y_SENSORTYPE_RES_INTERNAL</tt> corresponding to the temperature sensor type',ext:'On failure, throws an exception or returns <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'temperature&rarr;get_signalUnit()',pro:'string get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['Temperature']['get_signalValue']={syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'temperature&rarr;get_signalValue()',pro:'double get_signalValue()',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Returns the measuring unit for the temperature.',lib:'temperature&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the temperature.</p>',ret:'a string corresponding to the measuring unit for the temperature',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'temperature&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Temperature']['isOnline']={syn:'Checks if the temperature sensor is currently reachable, without raising any error.',lib:'temperature&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the temperature sensor is currently reachable, without raising any error. If there is a cached value for the temperature sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the temperature sensor.</p>',ret:'<tt>true</tt> if the temperature sensor can be reached, and <tt>false</tt> otherwise'};
doc['Temperature']['load']={syn:'Preloads the temperature sensor cache with a specified validity duration.',lib:'temperature&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the temperature sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'temperature&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Temperature']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'temperature&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['loadThermistorResponseTable']={syn:'Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function.',lib:'temperature&rarr;loadThermistorResponseTable()',pro:'int loadThermistorResponseTable(vector&lt;double&gt;&amp; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>resValues</span>)',cmt:'<p>Retrieves the thermistor response table previously configured using the <tt>set_thermistorResponseTable</tt> function. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperatures (in degrees Celcius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, that is filled by the function with the value (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'temperature&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['nextTemperature']={syn:'Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.',lib:'temperature&rarr;nextTemperature()',pro:'YTemperature * nextTemperature()',cmt:'<p>Continues the enumeration of temperature sensors started using <tt>yFirstTemperature()</tt>.</p>',ret:'a pointer to a <tt>YTemperature</tt> object, corresponding to a temperature sensor currently online, or a <tt>null</tt> pointer if there are no more temperature sensors to enumerate.'};
doc['Temperature']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'temperature&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YTemperatureTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Temperature']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'temperature&rarr;registerValueCallback()',pro:'int registerValueCallback(YTemperatureValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Temperature']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'temperature&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'temperature&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'temperature&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_logicalName']={syn:'Changes the logical name of the temperature sensor.',lib:'temperature&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the temperature sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the temperature sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'temperature&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_ntcParameters']={syn:'Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance.',lib:'temperature&rarr;set_ntcParameters()',pro:'int set_ntcParameters(double <span id=pn>res25</span>, double <span id=pn>beta</span>)',cmt:'<p>Configures NTC thermistor parameters in order to properly compute the temperature from the measured resistance. For increased precision, you can enter a complete mapping table using set_thermistorResponseTable. This function can only be used with a temperature sensor based on thermistors.</p>',par:{res25:'thermistor resistance at 25 degrees Celsius',beta:'Beta value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'temperature&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'temperature&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_sensorType']={syn:'Changes the temperature sensor type.',lib:'temperature&rarr;set_sensorType()',pro:'int set_sensorType(Y_SENSORTYPE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the temperature sensor type. This function is used to define the type of thermocouple (K,E...) used with the device. It has no effect if module is using a digital sensor or a thermistor. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt>, <tt>Y_SENSORTYPE_TYPE_T</tt>, <tt>Y_SENSORTYPE_PT100_4WIRES</tt>, <tt>Y_SENSORTYPE_PT100_3WIRES</tt>, <tt>Y_SENSORTYPE_PT100_2WIRES</tt>, <tt>Y_SENSORTYPE_RES_OHM</tt>, <tt>Y_SENSORTYPE_RES_NTC</tt>, <tt>Y_SENSORTYPE_RES_LINEAR</tt> and <tt>Y_SENSORTYPE_RES_INTERNAL</tt> corresponding to the temperature sensor type'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_thermistorResponseTable']={syn:'Records a thermistor response table, in order to interpolate the temperature from the measured resistance.',lib:'temperature&rarr;set_thermistorResponseTable()',pro:'int set_thermistorResponseTable(vector&lt;double&gt; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>resValues</span>)',cmt:'<p>Records a thermistor response table, in order to interpolate the temperature from the measured resistance. This function can only be used with a temperature sensor based on thermistors.</p>',par:{tempValues:'array of floating point numbers, corresponding to all temperatures (in degrees Celcius) for which the resistance of the thermistor is specified.',resValues:'array of floating point numbers, corresponding to the resistance values (in Ohms) for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_unit']={syn:'Changes the measuring unit for the measured temperature.',lib:'temperature&rarr;set_unit()',pro:'int set_unit(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured temperature. That unit is a string. If that strings end with the letter F all temperatures values will returned in Fahrenheit degrees. If that String ends with the letter K all values will be returned in Kelvin degrees. If that string ends with the letter C all values will be returned in Celsius degrees. If the string ends with any other character the change will be ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the temperature function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured temperature'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Temperature']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'temperature&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Temperature']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'temperature&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Temperature']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'temperature&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Temperature']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'temperature&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'DataLogger function interface',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>Yoctopuce sensors include a non-volatile memory capable of storing ongoing measured data automatically, without requiring a permanent connection to a computer. The DataLogger function controls the global parameters of the internal data logger.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Retrieves a data logger for a given identifier.',lib:'YDataLogger::FindDataLogger()',pro:'YDataLogger* FindDataLogger(string <span id=pn>func</span>)',cmt:'<p>Retrieves a data logger for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the data logger is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDataLogger.isOnline()</tt> to test if the data logger is indeed online at a given time. In case of ambiguity when looking for a data logger by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the data logger'},ret:'a <tt>YDataLogger</tt> object allowing you to drive the data logger.'};
doc['DataLogger']['FirstDataLogger']={syn:'Starts the enumeration of data loggers currently accessible.',lib:'YDataLogger::FirstDataLogger()',pro:'YDataLogger* FirstDataLogger()',cmt:'<p>Starts the enumeration of data loggers currently accessible. Use the method <tt>YDataLogger.nextDataLogger()</tt> to iterate on next data loggers.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to the first data logger currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DataLogger']['clearCache']={syn:'Invalidates the cache.',lib:'datalogger&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the data logger attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DataLogger']['describe']={syn:'Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the data logger in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the data logger (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Clears the data logger memory and discards all recorded data streams.',lib:'datalogger&rarr;forgetAllDataStreams()',pro:'int forgetAllDataStreams()',cmt:'<p>Clears the data logger memory and discards all recorded data streams. This method also resets the current run index to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_advertisedValue']={syn:'Returns the current value of the data logger (no more than 6 characters).',lib:'datalogger&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the data logger (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the data logger (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Returns the default activation state of the data logger on power up.',lib:'datalogger&rarr;get_autoStart()',pro:'Y_AUTOSTART_enum get_autoStart()',cmt:'<p>Returns the default activation state of the data logger on power up.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_beaconDriven']={syn:'Returns true if the data logger is synchronised with the localization beacon.',lib:'datalogger&rarr;get_beaconDriven()',pro:'Y_BEACONDRIVEN_enum get_beaconDriven()',cmt:'<p>Returns true if the data logger is synchronised with the localization beacon.</p>',ret:'either <tt>Y_BEACONDRIVEN_OFF</tt> or <tt>Y_BEACONDRIVEN_ON</tt>, according to true if the data logger is synchronised with the localization beacon',ext:'On failure, throws an exception or returns <tt>Y_BEACONDRIVEN_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.',lib:'datalogger&rarr;get_currentRunIndex()',pro:'int get_currentRunIndex()',cmt:'<p>Returns the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point.</p>',ret:'an integer corresponding to the current run number, corresponding to the number of times the module was powered on with the dataLogger enabled at some point',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataSets']={syn:'Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.',lib:'datalogger&rarr;get_dataSets()',pro:'vector&lt;YDataSet&gt; get_dataSets()',cmt:'<p>Returns a list of YDataSet objects that can be used to retrieve all measures stored by the data logger.</p><p> This function only works if the device uses a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>',ret:'a list of YDataSet object.',ext:'On failure, throws an exception or returns an empty list.'};
doc['DataLogger']['get_dataStreams']={syn:'Builds a list of all data streams hold by the data logger (legacy method).',lib:'datalogger&rarr;get_dataStreams()',pro:'int get_dataStreams()',cmt:'<p>Builds a list of all data streams hold by the data logger (legacy method). The caller must pass by reference an empty array to hold YDataStream objects, and the function fills it with objects describing available data sequences.</p><p> This is the old way to retrieve data from the DataLogger. For new applications, you should rather use <tt>get_dataSets()</tt> method, or call directly <tt>get_recordedData()</tt> on the sensor object.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['get_errorMessage']={syn:'Returns the error message of the latest error with the data logger.',lib:'datalogger&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the data logger object'};
doc['DataLogger']['get_errorType']={syn:'Returns the numerical error code of the latest error with the data logger.',lib:'datalogger&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the data logger. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the data logger object'};
doc['DataLogger']['get_friendlyName']={syn:'Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'datalogger&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the data logger in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the data logger if they are defined, otherwise the serial number of the module and the hardware identifier of the data logger (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the data logger using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DataLogger']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'datalogger&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DataLogger']['get_functionId']={syn:'Returns the hardware identifier of the data logger, without reference to the module.',lib:'datalogger&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the data logger, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the data logger (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DataLogger']['get_hardwareId']={syn:'Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'datalogger&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the data logger in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the data logger (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the data logger (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Returns the logical name of the data logger.',lib:'datalogger&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the data logger.</p>',ret:'a string corresponding to the logical name of the data logger.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'datalogger&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DataLogger']['get_recording']={syn:'Returns the current activation state of the data logger.',lib:'datalogger&rarr;get_recording()',pro:'Y_RECORDING_enum get_recording()',cmt:'<p>Returns the current activation state of the data logger.</p>',ret:'a value among <tt>Y_RECORDING_OFF</tt>, <tt>Y_RECORDING_ON</tt> and <tt>Y_RECORDING_PENDING</tt> corresponding to the current activation state of the data logger',ext:'On failure, throws an exception or returns <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Returns the Unix timestamp for current UTC time, if known.',lib:'datalogger&rarr;get_timeUTC()',pro:'s64 get_timeUTC()',cmt:'<p>Returns the Unix timestamp for current UTC time, if known.</p>',ret:'an integer corresponding to the Unix timestamp for current UTC time, if known',ext:'On failure, throws an exception or returns <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'datalogger&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DataLogger']['isOnline']={syn:'Checks if the data logger is currently reachable, without raising any error.',lib:'datalogger&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the data logger is currently reachable, without raising any error. If there is a cached value for the data logger in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the data logger.</p>',ret:'<tt>true</tt> if the data logger can be reached, and <tt>false</tt> otherwise'};
doc['DataLogger']['load']={syn:'Preloads the data logger cache with a specified validity duration.',lib:'datalogger&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the data logger cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'datalogger&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DataLogger']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'datalogger&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['nextDataLogger']={syn:'Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.',lib:'datalogger&rarr;nextDataLogger()',pro:'YDataLogger * nextDataLogger()',cmt:'<p>Continues the enumeration of data loggers started using <tt>yFirstDataLogger()</tt>.</p>',ret:'a pointer to a <tt>YDataLogger</tt> object, corresponding to a data logger currently online, or a <tt>null</tt> pointer if there are no more data loggers to enumerate.'};
doc['DataLogger']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'datalogger&rarr;registerValueCallback()',pro:'int registerValueCallback(YDataLoggerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DataLogger']['set_autoStart']={syn:'Changes the default activation state of the data logger on power up.',lib:'datalogger&rarr;set_autoStart()',pro:'int set_autoStart(Y_AUTOSTART_enum <span id=pn>newval</span>)',cmt:'<p>Changes the default activation state of the data logger on power up. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the default activation state of the data logger on power up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_beaconDriven']={syn:'Changes the type of synchronisation of the data logger.',lib:'datalogger&rarr;set_beaconDriven()',pro:'int set_beaconDriven(Y_BEACONDRIVEN_enum <span id=pn>newval</span>)',cmt:'<p>Changes the type of synchronisation of the data logger. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'either <tt>Y_BEACONDRIVEN_OFF</tt> or <tt>Y_BEACONDRIVEN_ON</tt>, according to the type of synchronisation of the data logger'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_logicalName']={syn:'Changes the logical name of the data logger.',lib:'datalogger&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the data logger. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the data logger.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_recording']={syn:'Changes the activation state of the data logger to start/stop recording data.',lib:'datalogger&rarr;set_recording()',pro:'int set_recording(Y_RECORDING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the data logger to start/stop recording data.</p>',par:{newval:'a value among <tt>Y_RECORDING_OFF</tt>, <tt>Y_RECORDING_ON</tt> and <tt>Y_RECORDING_PENDING</tt> corresponding to the activation state of the data logger to start/stop recording data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_timeUTC']={syn:'Changes the current UTC time reference used for recorded data.',lib:'datalogger&rarr;set_timeUTC()',pro:'int set_timeUTC(s64 <span id=pn>newval</span>)',cmt:'<p>Changes the current UTC time reference used for recorded data.</p>',par:{newval:'an integer corresponding to the current UTC time reference used for recorded data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DataLogger']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'datalogger&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DataLogger']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'datalogger&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DataLogger)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'External power supply control interface',inc:'#include &quot;yocto_dualpower.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to control the power source to use for module functions that require high current. The module can also automatically disconnect the external power when a voltage drop is observed on the external power source (external battery running out of power).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Retrieves a dual power control for a given identifier.',lib:'YDualPower::FindDualPower()',pro:'YDualPower* FindDualPower(string <span id=pn>func</span>)',cmt:'<p>Retrieves a dual power control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDualPower.isOnline()</tt> to test if the power control is indeed online at a given time. In case of ambiguity when looking for a dual power control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the power control'},ret:'a <tt>YDualPower</tt> object allowing you to drive the power control.'};
doc['DualPower']['FirstDualPower']={syn:'Starts the enumeration of dual power controls currently accessible.',lib:'YDualPower::FirstDualPower()',pro:'YDualPower* FirstDualPower()',cmt:'<p>Starts the enumeration of dual power controls currently accessible. Use the method <tt>YDualPower.nextDualPower()</tt> to iterate on next dual power controls.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to the first dual power control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DualPower']['clearCache']={syn:'Invalidates the cache.',lib:'dualpower&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the power control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DualPower']['describe']={syn:'Returns a short text that describes unambiguously the instance of the power control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DualPower']['get_advertisedValue']={syn:'Returns the current value of the power control (no more than 6 characters).',lib:'dualpower&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the power control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Returns the error message of the latest error with the power control.',lib:'dualpower&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power control object'};
doc['DualPower']['get_errorType']={syn:'Returns the numerical error code of the latest error with the power control.',lib:'dualpower&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power control object'};
doc['DualPower']['get_extVoltage']={syn:'Returns the measured voltage on the external power source, in millivolts.',lib:'dualpower&rarr;get_extVoltage()',pro:'int get_extVoltage()',cmt:'<p>Returns the measured voltage on the external power source, in millivolts.</p>',ret:'an integer corresponding to the measured voltage on the external power source, in millivolts',ext:'On failure, throws an exception or returns <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_friendlyName']={syn:'Returns a global identifier of the power control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'dualpower&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the power control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power control if they are defined, otherwise the serial number of the module and the hardware identifier of the power control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'dualpower&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DualPower']['get_functionId']={syn:'Returns the hardware identifier of the power control, without reference to the module.',lib:'dualpower&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the power control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DualPower']['get_hardwareId']={syn:'Returns the unique hardware identifier of the power control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'dualpower&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Returns the logical name of the power control.',lib:'dualpower&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the power control.</p>',ret:'a string corresponding to the logical name of the power control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'dualpower&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Returns the selected power source for module functions that require lots of current.',lib:'dualpower&rarr;get_powerControl()',pro:'Y_POWERCONTROL_enum get_powerControl()',cmt:'<p>Returns the selected power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Returns the current power source for module functions that require lots of current.',lib:'dualpower&rarr;get_powerState()',pro:'Y_POWERSTATE_enum get_powerState()',cmt:'<p>Returns the current power source for module functions that require lots of current.</p>',ret:'a value among <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> and <tt>Y_POWERSTATE_FROM_EXT</tt> corresponding to the current power source for module functions that require lots of current',ext:'On failure, throws an exception or returns <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'dualpower&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DualPower']['isOnline']={syn:'Checks if the power control is currently reachable, without raising any error.',lib:'dualpower&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the power control is currently reachable, without raising any error. If there is a cached value for the power control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power control.</p>',ret:'<tt>true</tt> if the power control can be reached, and <tt>false</tt> otherwise'};
doc['DualPower']['load']={syn:'Preloads the power control cache with a specified validity duration.',lib:'dualpower&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the power control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'dualpower&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DualPower']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'dualpower&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['nextDualPower']={syn:'Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.',lib:'dualpower&rarr;nextDualPower()',pro:'YDualPower * nextDualPower()',cmt:'<p>Continues the enumeration of dual power controls started using <tt>yFirstDualPower()</tt>.</p>',ret:'a pointer to a <tt>YDualPower</tt> object, corresponding to a dual power control currently online, or a <tt>null</tt> pointer if there are no more dual power controls to enumerate.'};
doc['DualPower']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'dualpower&rarr;registerValueCallback()',pro:'int registerValueCallback(YDualPowerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DualPower']['set_logicalName']={syn:'Changes the logical name of the power control.',lib:'dualpower&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_powerControl']={syn:'Changes the selected power source for module functions that require lots of current.',lib:'dualpower&rarr;set_powerControl()',pro:'int set_powerControl(Y_POWERCONTROL_enum <span id=pn>newval</span>)',cmt:'<p>Changes the selected power source for module functions that require lots of current.</p>',par:{newval:'a value among <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> and <tt>Y_POWERCONTROL_OFF</tt> corresponding to the selected power source for module functions that require lots of current'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DualPower']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'dualpower&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DualPower']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'dualpower&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Servo function interface',inc:'#include &quot;yocto_servo.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you not only to move a servo to a given position, but also to specify the time interval in which the move should be performed. This makes it possible to synchronize two servos involved in a same move.</p>'}};
doc['Servo']['FindServo']={syn:'Retrieves a servo for a given identifier.',lib:'YServo::FindServo()',pro:'YServo* FindServo(string <span id=pn>func</span>)',cmt:'<p>Retrieves a servo for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the servo is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YServo.isOnline()</tt> to test if the servo is indeed online at a given time. In case of ambiguity when looking for a servo by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the servo'},ret:'a <tt>YServo</tt> object allowing you to drive the servo.'};
doc['Servo']['FirstServo']={syn:'Starts the enumeration of servos currently accessible.',lib:'YServo::FirstServo()',pro:'YServo* FirstServo()',cmt:'<p>Starts the enumeration of servos currently accessible. Use the method <tt>YServo.nextServo()</tt> to iterate on next servos.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to the first servo currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Servo']['clearCache']={syn:'Invalidates the cache.',lib:'servo&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the servo attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Servo']['describe']={syn:'Returns a short text that describes unambiguously the instance of the servo in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'servo&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the servo in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the servo (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Servo']['get_advertisedValue']={syn:'Returns the current value of the servo (no more than 6 characters).',lib:'servo&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the servo (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the servo (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_enabled']={syn:'Returns the state of the servos.',lib:'servo&rarr;get_enabled()',pro:'Y_ENABLED_enum get_enabled()',cmt:'<p>Returns the state of the servos.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the state of the servos',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['Servo']['get_enabledAtPowerOn']={syn:'Returns the servo signal generator state at power up.',lib:'servo&rarr;get_enabledAtPowerOn()',pro:'Y_ENABLEDATPOWERON_enum get_enabledAtPowerOn()',cmt:'<p>Returns the servo signal generator state at power up.</p>',ret:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the servo signal generator state at power up',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Returns the error message of the latest error with the servo.',lib:'servo&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the servo. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the servo object'};
doc['Servo']['get_errorType']={syn:'Returns the numerical error code of the latest error with the servo.',lib:'servo&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the servo. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the servo object'};
doc['Servo']['get_friendlyName']={syn:'Returns a global identifier of the servo in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'servo&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the servo in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the servo if they are defined, otherwise the serial number of the module and the hardware identifier of the servo (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the servo using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Servo']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'servo&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Servo']['get_functionId']={syn:'Returns the hardware identifier of the servo, without reference to the module.',lib:'servo&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the servo, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the servo (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Servo']['get_hardwareId']={syn:'Returns the unique hardware identifier of the servo in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'servo&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the servo in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the servo (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the servo (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Returns the logical name of the servo.',lib:'servo&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the servo.</p>',ret:'a string corresponding to the logical name of the servo.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'servo&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Returns the duration in microseconds of a neutral pulse for the servo.',lib:'servo&rarr;get_neutral()',pro:'int get_neutral()',cmt:'<p>Returns the duration in microseconds of a neutral pulse for the servo.</p>',ret:'an integer corresponding to the duration in microseconds of a neutral pulse for the servo',ext:'On failure, throws an exception or returns <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Returns the current servo position.',lib:'servo&rarr;get_position()',pro:'int get_position()',cmt:'<p>Returns the current servo position.</p>',ret:'an integer corresponding to the current servo position',ext:'On failure, throws an exception or returns <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_positionAtPowerOn']={syn:'Returns the servo position at device power up.',lib:'servo&rarr;get_positionAtPowerOn()',pro:'int get_positionAtPowerOn()',cmt:'<p>Returns the servo position at device power up.</p>',ret:'an integer corresponding to the servo position at device power up',ext:'On failure, throws an exception or returns <tt>Y_POSITIONATPOWERON_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Returns the current range of use of the servo.',lib:'servo&rarr;get_range()',pro:'int get_range()',cmt:'<p>Returns the current range of use of the servo.</p>',ret:'an integer corresponding to the current range of use of the servo',ext:'On failure, throws an exception or returns <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'servo&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Servo']['isOnline']={syn:'Checks if the servo is currently reachable, without raising any error.',lib:'servo&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the servo is currently reachable, without raising any error. If there is a cached value for the servo in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the servo.</p>',ret:'<tt>true</tt> if the servo can be reached, and <tt>false</tt> otherwise'};
doc['Servo']['load']={syn:'Preloads the servo cache with a specified validity duration.',lib:'servo&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the servo cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'servo&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Servo']['move']={syn:'Performs a smooth move at constant speed toward a given position.',lib:'servo&rarr;move()',pro:'int move(int <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given position.</p>',par:{target:'new position at the end of the move',ms_duration:'total duration of the move, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'servo&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['nextServo']={syn:'Continues the enumeration of servos started using <tt>yFirstServo()</tt>.',lib:'servo&rarr;nextServo()',pro:'YServo * nextServo()',cmt:'<p>Continues the enumeration of servos started using <tt>yFirstServo()</tt>.</p>',ret:'a pointer to a <tt>YServo</tt> object, corresponding to a servo currently online, or a <tt>null</tt> pointer if there are no more servos to enumerate.'};
doc['Servo']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'servo&rarr;registerValueCallback()',pro:'int registerValueCallback(YServoValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Servo']['set_enabled']={syn:'Stops or starts the servo.',lib:'servo&rarr;set_enabled()',pro:'int set_enabled(Y_ENABLED_enum <span id=pn>newval</span>)',cmt:'<p>Stops or starts the servo.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_enabledAtPowerOn']={syn:'Configure the servo signal generator state at power up.',lib:'servo&rarr;set_enabledAtPowerOn()',pro:'int set_enabledAtPowerOn(Y_ENABLEDATPOWERON_enum <span id=pn>newval</span>)',cmt:'<p>Configure the servo signal generator state at power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_logicalName']={syn:'Changes the logical name of the servo.',lib:'servo&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the servo. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the servo.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_neutral']={syn:'Changes the duration of the pulse corresponding to the neutral position of the servo.',lib:'servo&rarr;set_neutral()',pro:'int set_neutral(int <span id=pn>newval</span>)',cmt:'<p>Changes the duration of the pulse corresponding to the neutral position of the servo. The duration is specified in microseconds, and the standard value is 1500 [us]. This setting makes it possible to shift the range of use of the servo. Be aware that using a range higher than what is supported by the servo is likely to damage the servo. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer corresponding to the duration of the pulse corresponding to the neutral position of the servo'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_position']={syn:'Changes immediately the servo driving position.',lib:'servo&rarr;set_position()',pro:'int set_position(int <span id=pn>newval</span>)',cmt:'<p>Changes immediately the servo driving position.</p>',par:{newval:'an integer corresponding to immediately the servo driving position'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_positionAtPowerOn']={syn:'Configure the servo position at device power up.',lib:'servo&rarr;set_positionAtPowerOn()',pro:'int set_positionAtPowerOn(int <span id=pn>newval</span>)',cmt:'<p>Configure the servo position at device power up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_range']={syn:'Changes the range of use of the servo, specified in per cents.',lib:'servo&rarr;set_range()',pro:'int set_range(int <span id=pn>newval</span>)',cmt:'<p>Changes the range of use of the servo, specified in per cents. A range of 100% corresponds to a standard control signal, that varies from 1 [ms] to 2 [ms], When using a servo that supports a double range, from 0.5 [ms] to 2.5 [ms], you can select a range of 200%. Be aware that using a range higher than what is supported by the servo is likely to damage the servo. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'an integer corresponding to the range of use of the servo, specified in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Servo']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'servo&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Servo']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'servo&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Relay function interface',inc:'#include &quot;yocto_relay.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to switch the relay state. This change is not persistent: the relay will automatically return to its idle position whenever power is lost or if the module is restarted. The library can also generate automatically short pulses of determined duration. On devices with two output for each relay (double throw), the two outputs are named A and B, with output A corresponding to the idle position (at power off) and the output B corresponding to the active state. If you prefer the alternate default state, simply switch your cables on the board.</p>'}};
doc['Relay']['FindRelay']={syn:'Retrieves a relay for a given identifier.',lib:'YRelay::FindRelay()',pro:'YRelay* FindRelay(string <span id=pn>func</span>)',cmt:'<p>Retrieves a relay for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the relay is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRelay.isOnline()</tt> to test if the relay is indeed online at a given time. In case of ambiguity when looking for a relay by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the relay'},ret:'a <tt>YRelay</tt> object allowing you to drive the relay.'};
doc['Relay']['FirstRelay']={syn:'Starts the enumeration of relays currently accessible.',lib:'YRelay::FirstRelay()',pro:'YRelay* FirstRelay()',cmt:'<p>Starts the enumeration of relays currently accessible. Use the method <tt>YRelay.nextRelay()</tt> to iterate on next relays.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to the first relay currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Relay']['clearCache']={syn:'Invalidates the cache.',lib:'relay&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the relay attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Relay']['delayedPulse']={syn:'Schedules a pulse.',lib:'relay&rarr;delayedPulse()',pro:'int delayedPulse(int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['describe']={syn:'Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'relay&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the relay in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the relay (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Relay']['get_advertisedValue']={syn:'Returns the current value of the relay (no more than 6 characters).',lib:'relay&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the relay (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the relay (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'relay&rarr;get_countdown()',pro:'s64 get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Returns the error message of the latest error with the relay.',lib:'relay&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the relay object'};
doc['Relay']['get_errorType']={syn:'Returns the numerical error code of the latest error with the relay.',lib:'relay&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the relay. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the relay object'};
doc['Relay']['get_friendlyName']={syn:'Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'relay&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the relay in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the relay if they are defined, otherwise the serial number of the module and the hardware identifier of the relay (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the relay using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Relay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'relay&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Relay']['get_functionId']={syn:'Returns the hardware identifier of the relay, without reference to the module.',lib:'relay&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the relay, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the relay (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Relay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'relay&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the relay in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the relay (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the relay (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Returns the logical name of the relay.',lib:'relay&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the relay.</p>',ret:'a string corresponding to the logical name of the relay.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'relay&rarr;get_maxTimeOnStateA()',pro:'s64 get_maxTimeOnStateA()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Relay']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'relay&rarr;get_maxTimeOnStateB()',pro:'s64 get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'relay&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Returns the output state of the relays, when used as a simple switch (single throw).',lib:'relay&rarr;get_output()',pro:'Y_OUTPUT_enum get_output()',cmt:'<p>Returns the output state of the relays, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation.',lib:'relay&rarr;get_pulseTimer()',pro:'s64 get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the relays is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Returns the state of the relays (A for the idle position, B for the active position).',lib:'relay&rarr;get_state()',pro:'Y_STATE_enum get_state()',cmt:'<p>Returns the state of the relays (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_stateAtPowerOn']={syn:'Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'relay&rarr;get_stateAtPowerOn()',pro:'Y_STATEATPOWERON_enum get_stateAtPowerOn()',cmt:'<p>Returns the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt> corresponding to the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:'On failure, throws an exception or returns <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'relay&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Relay']['isOnline']={syn:'Checks if the relay is currently reachable, without raising any error.',lib:'relay&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the relay is currently reachable, without raising any error. If there is a cached value for the relay in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the relay.</p>',ret:'<tt>true</tt> if the relay can be reached, and <tt>false</tt> otherwise'};
doc['Relay']['load']={syn:'Preloads the relay cache with a specified validity duration.',lib:'relay&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the relay cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'relay&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Relay']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'relay&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['nextRelay']={syn:'Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.',lib:'relay&rarr;nextRelay()',pro:'YRelay * nextRelay()',cmt:'<p>Continues the enumeration of relays started using <tt>yFirstRelay()</tt>.</p>',ret:'a pointer to a <tt>YRelay</tt> object, corresponding to a relay currently online, or a <tt>null</tt> pointer if there are no more relays to enumerate.'};
doc['Relay']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'relay&rarr;pulse()',pro:'int pulse(int <span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'relay&rarr;registerValueCallback()',pro:'int registerValueCallback(YRelayValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Relay']['set_logicalName']={syn:'Changes the logical name of the relay.',lib:'relay&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the relay. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the relay.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'relay&rarr;set_maxTimeOnStateA()',pro:'int set_maxTimeOnStateA(s64 <span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'relay&rarr;set_maxTimeOnStateB()',pro:'int set_maxTimeOnStateB(s64 <span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_output']={syn:'Changes the output state of the relays, when used as a simple switch (single throw).',lib:'relay&rarr;set_output()',pro:'int set_output(Y_OUTPUT_enum <span id=pn>newval</span>)',cmt:'<p>Changes the output state of the relays, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the relays, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_state']={syn:'Changes the state of the relays (A for the idle position, B for the active position).',lib:'relay&rarr;set_state()',pro:'int set_state(Y_STATE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the relays (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the relays (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_stateAtPowerOn']={syn:'Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'relay&rarr;set_stateAtPowerOn()',pro:'int set_stateAtPowerOn(Y_STATEATPOWERON_enum <span id=pn>newval</span>)',cmt:'<p>Preset the state of the relays at device startup (A for the idle position, B for the active position, UNCHANGED for no modification). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Relay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'relay&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Relay']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'relay&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Relay)
//--- (generated code: Led)
doc['Led']={'':{syn:'Led function interface',inc:'#include &quot;yocto_led.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you not only to drive the intensity of the LED, but also to have it blink at various preset frequencies.</p>'}};
doc['Led']['FindLed']={syn:'Retrieves a LED for a given identifier.',lib:'YLed::FindLed()',pro:'YLed* FindLed(string <span id=pn>func</span>)',cmt:'<p>Retrieves a LED for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the LED is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLed.isOnline()</tt> to test if the LED is indeed online at a given time. In case of ambiguity when looking for a LED by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the LED'},ret:'a <tt>YLed</tt> object allowing you to drive the LED.'};
doc['Led']['FirstLed']={syn:'Starts the enumeration of LEDs currently accessible.',lib:'YLed::FirstLed()',pro:'YLed* FirstLed()',cmt:'<p>Starts the enumeration of LEDs currently accessible. Use the method <tt>YLed.nextLed()</tt> to iterate on next LEDs.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to the first LED currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Led']['clearCache']={syn:'Invalidates the cache.',lib:'led&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the LED attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Led']['describe']={syn:'Returns a short text that describes unambiguously the instance of the LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'led&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Led']['get_advertisedValue']={syn:'Returns the current value of the LED (no more than 6 characters).',lib:'led&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the LED (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Returns the current LED signaling mode.',lib:'led&rarr;get_blinking()',pro:'Y_BLINKING_enum get_blinking()',cmt:'<p>Returns the current LED signaling mode.</p>',ret:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current LED signaling mode',ext:'On failure, throws an exception or returns <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Returns the error message of the latest error with the LED.',lib:'led&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the LED object'};
doc['Led']['get_errorType']={syn:'Returns the numerical error code of the latest error with the LED.',lib:'led&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the LED object'};
doc['Led']['get_friendlyName']={syn:'Returns a global identifier of the LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'led&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the LED if they are defined, otherwise the serial number of the module and the hardware identifier of the LED (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the LED using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Led']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'led&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Led']['get_functionId']={syn:'Returns the hardware identifier of the LED, without reference to the module.',lib:'led&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the LED, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the LED (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Led']['get_hardwareId']={syn:'Returns the unique hardware identifier of the LED in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'led&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the LED in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the LED (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Returns the logical name of the LED.',lib:'led&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the LED.</p>',ret:'a string corresponding to the logical name of the LED.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Returns the current LED intensity (in per cent).',lib:'led&rarr;get_luminosity()',pro:'int get_luminosity()',cmt:'<p>Returns the current LED intensity (in per cent).</p>',ret:'an integer corresponding to the current LED intensity (in per cent)',ext:'On failure, throws an exception or returns <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'led&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Returns the current LED state.',lib:'led&rarr;get_power()',pro:'Y_POWER_enum get_power()',cmt:'<p>Returns the current LED state.</p>',ret:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the current LED state',ext:'On failure, throws an exception or returns <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'led&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Led']['isOnline']={syn:'Checks if the LED is currently reachable, without raising any error.',lib:'led&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the LED is currently reachable, without raising any error. If there is a cached value for the LED in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the LED.</p>',ret:'<tt>true</tt> if the LED can be reached, and <tt>false</tt> otherwise'};
doc['Led']['load']={syn:'Preloads the LED cache with a specified validity duration.',lib:'led&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the LED cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'led&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Led']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'led&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['nextLed']={syn:'Continues the enumeration of LEDs started using <tt>yFirstLed()</tt>.',lib:'led&rarr;nextLed()',pro:'YLed * nextLed()',cmt:'<p>Continues the enumeration of LEDs started using <tt>yFirstLed()</tt>.</p>',ret:'a pointer to a <tt>YLed</tt> object, corresponding to a LED currently online, or a <tt>null</tt> pointer if there are no more LEDs to enumerate.'};
doc['Led']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'led&rarr;registerValueCallback()',pro:'int registerValueCallback(YLedValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Led']['set_blinking']={syn:'Changes the current LED signaling mode.',lib:'led&rarr;set_blinking()',pro:'int set_blinking(Y_BLINKING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the current LED signaling mode.</p>',par:{newval:'a value among <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> and <tt>Y_BLINKING_PANIC</tt> corresponding to the current LED signaling mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_logicalName']={syn:'Changes the logical name of the LED.',lib:'led&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the LED. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the LED.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_luminosity']={syn:'Changes the current LED intensity (in per cent).',lib:'led&rarr;set_luminosity()',pro:'int set_luminosity(int <span id=pn>newval</span>)',cmt:'<p>Changes the current LED intensity (in per cent).</p>',par:{newval:'an integer corresponding to the current LED intensity (in per cent)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_power']={syn:'Changes the state of the LED.',lib:'led&rarr;set_power()',pro:'int set_power(Y_POWER_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the LED.</p>',par:{newval:'either <tt>Y_POWER_OFF</tt> or <tt>Y_POWER_ON</tt>, according to the state of the LED'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Led']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'led&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Led']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'led&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Led)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Humidity function interface',inc:'#include &quot;yocto_humidity.h&quot;',cmt:'<p>The Yoctopuce class YHumidity allows you to read and configure Yoctopuce humidity sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Retrieves a humidity sensor for a given identifier.',lib:'YHumidity::FindHumidity()',pro:'YHumidity* FindHumidity(string <span id=pn>func</span>)',cmt:'<p>Retrieves a humidity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the humidity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHumidity.isOnline()</tt> to test if the humidity sensor is indeed online at a given time. In case of ambiguity when looking for a humidity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the humidity sensor'},ret:'a <tt>YHumidity</tt> object allowing you to drive the humidity sensor.'};
doc['Humidity']['FirstHumidity']={syn:'Starts the enumeration of humidity sensors currently accessible.',lib:'YHumidity::FirstHumidity()',pro:'YHumidity* FirstHumidity()',cmt:'<p>Starts the enumeration of humidity sensors currently accessible. Use the method <tt>YHumidity.nextHumidity()</tt> to iterate on next humidity sensors.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to the first humidity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Humidity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'humidity&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['clearCache']={syn:'Invalidates the cache.',lib:'humidity&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the humidity sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Humidity']['describe']={syn:'Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the humidity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the humidity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Humidity']['get_absHum']={syn:'Returns the current absolute humidity, in grams per cubic meter of air.',lib:'humidity&rarr;get_absHum()',pro:'double get_absHum()',cmt:'<p>Returns the current absolute humidity, in grams per cubic meter of air.</p>',ret:'a floating point number corresponding to the current absolute humidity, in grams per cubic meter of air',ext:'On failure, throws an exception or returns <tt>Y_ABSHUM_INVALID</tt>.'};
doc['Humidity']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'humidity&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Humidity']['get_advertisedValue']={syn:'Returns the current value of the humidity sensor (no more than 6 characters).',lib:'humidity&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the humidity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the humidity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.',lib:'humidity&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Returns the current value of the humidity, in %RH, as a floating point number.',lib:'humidity&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the humidity, in %RH, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the humidity, in %RH, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'humidity&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Humidity']['get_errorMessage']={syn:'Returns the error message of the latest error with the humidity sensor.',lib:'humidity&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the humidity sensor object'};
doc['Humidity']['get_errorType']={syn:'Returns the numerical error code of the latest error with the humidity sensor.',lib:'humidity&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the humidity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the humidity sensor object'};
doc['Humidity']['get_friendlyName']={syn:'Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'humidity&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the humidity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the humidity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the humidity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the humidity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Humidity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'humidity&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Humidity']['get_functionId']={syn:'Returns the hardware identifier of the humidity sensor, without reference to the module.',lib:'humidity&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the humidity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the humidity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Humidity']['get_hardwareId']={syn:'Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'humidity&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the humidity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the humidity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the humidity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Returns the maximal value observed for the humidity since the device was started.',lib:'humidity&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'humidity&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Returns the logical name of the humidity sensor.',lib:'humidity&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the humidity sensor.</p>',ret:'a string corresponding to the logical name of the humidity sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Returns the minimal value observed for the humidity since the device was started.',lib:'humidity&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the humidity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the humidity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'humidity&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Humidity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'humidity&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Humidity']['get_relHum']={syn:'Returns the current relative humidity, in per cents.',lib:'humidity&rarr;get_relHum()',pro:'double get_relHum()',cmt:'<p>Returns the current relative humidity, in per cents.</p>',ret:'a floating point number corresponding to the current relative humidity, in per cents',ext:'On failure, throws an exception or returns <tt>Y_RELHUM_INVALID</tt>.'};
doc['Humidity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'humidity&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Humidity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'humidity&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'humidity&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Returns the measuring unit for the humidity.',lib:'humidity&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the humidity.</p>',ret:'a string corresponding to the measuring unit for the humidity',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'humidity&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Humidity']['isOnline']={syn:'Checks if the humidity sensor is currently reachable, without raising any error.',lib:'humidity&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the humidity sensor is currently reachable, without raising any error. If there is a cached value for the humidity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the humidity sensor.</p>',ret:'<tt>true</tt> if the humidity sensor can be reached, and <tt>false</tt> otherwise'};
doc['Humidity']['load']={syn:'Preloads the humidity sensor cache with a specified validity duration.',lib:'humidity&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the humidity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'humidity&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Humidity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'humidity&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'humidity&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['nextHumidity']={syn:'Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.',lib:'humidity&rarr;nextHumidity()',pro:'YHumidity * nextHumidity()',cmt:'<p>Continues the enumeration of humidity sensors started using <tt>yFirstHumidity()</tt>.</p>',ret:'a pointer to a <tt>YHumidity</tt> object, corresponding to a humidity sensor currently online, or a <tt>null</tt> pointer if there are no more humidity sensors to enumerate.'};
doc['Humidity']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'humidity&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YHumidityTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Humidity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'humidity&rarr;registerValueCallback()',pro:'int registerValueCallback(YHumidityValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Humidity']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'humidity&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'humidity&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'humidity&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_logicalName']={syn:'Changes the logical name of the humidity sensor.',lib:'humidity&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the humidity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the humidity sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'humidity&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'humidity&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'humidity&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_unit']={syn:'Changes the primary unit for measuring humidity.',lib:'humidity&rarr;set_unit()',pro:'int set_unit(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the primary unit for measuring humidity. That unit is a string. If that strings starts with the letter \x27g\x27, the primary measured value is the absolute humidity, in g/m3. Otherwise, the primary measured value will be the relative humidity (RH), in per cents.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the primary unit for measuring humidity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Humidity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'humidity&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Humidity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'humidity&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Humidity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'humidity&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Humidity']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'humidity&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Humidity)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Pressure function interface',inc:'#include &quot;yocto_pressure.h&quot;',cmt:'<p>The Yoctopuce class YPressure allows you to read and configure Yoctopuce pressure sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Pressure']['FindPressure']={syn:'Retrieves a pressure sensor for a given identifier.',lib:'YPressure::FindPressure()',pro:'YPressure* FindPressure(string <span id=pn>func</span>)',cmt:'<p>Retrieves a pressure sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the pressure sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPressure.isOnline()</tt> to test if the pressure sensor is indeed online at a given time. In case of ambiguity when looking for a pressure sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the pressure sensor'},ret:'a <tt>YPressure</tt> object allowing you to drive the pressure sensor.'};
doc['Pressure']['FirstPressure']={syn:'Starts the enumeration of pressure sensors currently accessible.',lib:'YPressure::FirstPressure()',pro:'YPressure* FirstPressure()',cmt:'<p>Starts the enumeration of pressure sensors currently accessible. Use the method <tt>YPressure.nextPressure()</tt> to iterate on next pressure sensors.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to the first pressure sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Pressure']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pressure&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['clearCache']={syn:'Invalidates the cache.',lib:'pressure&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the pressure sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Pressure']['describe']={syn:'Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the pressure sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the pressure sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Pressure']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'pressure&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Pressure']['get_advertisedValue']={syn:'Returns the current value of the pressure sensor (no more than 6 characters).',lib:'pressure&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the pressure sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the pressure sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.',lib:'pressure&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Returns the current value of the pressure, in millibar (hPa), as a floating point number.',lib:'pressure&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the pressure, in millibar (hPa), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the pressure, in millibar (hPa), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'pressure&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Pressure']['get_errorMessage']={syn:'Returns the error message of the latest error with the pressure sensor.',lib:'pressure&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the pressure sensor object'};
doc['Pressure']['get_errorType']={syn:'Returns the numerical error code of the latest error with the pressure sensor.',lib:'pressure&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the pressure sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the pressure sensor object'};
doc['Pressure']['get_friendlyName']={syn:'Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pressure&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the pressure sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the pressure sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the pressure sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the pressure sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Pressure']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pressure&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Pressure']['get_functionId']={syn:'Returns the hardware identifier of the pressure sensor, without reference to the module.',lib:'pressure&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the pressure sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the pressure sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Pressure']['get_hardwareId']={syn:'Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pressure&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the pressure sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the pressure sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the pressure sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Returns the maximal value observed for the pressure since the device was started.',lib:'pressure&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'pressure&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Returns the logical name of the pressure sensor.',lib:'pressure&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the pressure sensor.</p>',ret:'a string corresponding to the logical name of the pressure sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Returns the minimal value observed for the pressure since the device was started.',lib:'pressure&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the pressure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the pressure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pressure&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Pressure']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'pressure&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Pressure']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'pressure&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Pressure']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pressure&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'pressure&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Returns the measuring unit for the pressure.',lib:'pressure&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the pressure.</p>',ret:'a string corresponding to the measuring unit for the pressure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pressure&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Pressure']['isOnline']={syn:'Checks if the pressure sensor is currently reachable, without raising any error.',lib:'pressure&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the pressure sensor is currently reachable, without raising any error. If there is a cached value for the pressure sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the pressure sensor.</p>',ret:'<tt>true</tt> if the pressure sensor can be reached, and <tt>false</tt> otherwise'};
doc['Pressure']['load']={syn:'Preloads the pressure sensor cache with a specified validity duration.',lib:'pressure&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the pressure sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pressure&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Pressure']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'pressure&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pressure&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['nextPressure']={syn:'Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.',lib:'pressure&rarr;nextPressure()',pro:'YPressure * nextPressure()',cmt:'<p>Continues the enumeration of pressure sensors started using <tt>yFirstPressure()</tt>.</p>',ret:'a pointer to a <tt>YPressure</tt> object, corresponding to a pressure sensor currently online, or a <tt>null</tt> pointer if there are no more pressure sensors to enumerate.'};
doc['Pressure']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'pressure&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YPressureTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Pressure']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pressure&rarr;registerValueCallback()',pro:'int registerValueCallback(YPressureValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Pressure']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'pressure&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pressure&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'pressure&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_logicalName']={syn:'Changes the logical name of the pressure sensor.',lib:'pressure&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the pressure sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the pressure sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pressure&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'pressure&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'pressure&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Pressure']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pressure&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Pressure']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'pressure&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Pressure']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'pressure&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Pressure']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pressure&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Pressure)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'LightSensor function interface',inc:'#include &quot;yocto_lightsensor.h&quot;',cmt:'<p>The Yoctopuce class YLightSensor allows you to read and configure Yoctopuce light sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor. For some light sensors with several working modes, this class can select the desired working mode.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Retrieves a light sensor for a given identifier.',lib:'YLightSensor::FindLightSensor()',pro:'YLightSensor* FindLightSensor(string <span id=pn>func</span>)',cmt:'<p>Retrieves a light sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the light sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLightSensor.isOnline()</tt> to test if the light sensor is indeed online at a given time. In case of ambiguity when looking for a light sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the light sensor'},ret:'a <tt>YLightSensor</tt> object allowing you to drive the light sensor.'};
doc['LightSensor']['FirstLightSensor']={syn:'Starts the enumeration of light sensors currently accessible.',lib:'YLightSensor::FirstLightSensor()',pro:'YLightSensor* FirstLightSensor()',cmt:'<p>Starts the enumeration of light sensors currently accessible. Use the method <tt>YLightSensor.nextLightSensor()</tt> to iterate on next light sensors.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to the first light sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['LightSensor']['calibrate']={syn:'Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).',lib:'lightsensor&rarr;calibrate()',pro:'int calibrate(double <span id=pn>calibratedVal</span>)',cmt:'<p>Changes the sensor-specific calibration parameter so that the current value matches a desired target (linear scaling).</p>',par:{calibratedVal:'the desired target value.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'lightsensor&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['clearCache']={syn:'Invalidates the cache.',lib:'lightsensor&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the light sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['LightSensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the light sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the light sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['LightSensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'lightsensor&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['LightSensor']['get_advertisedValue']={syn:'Returns the current value of the light sensor (no more than 6 characters).',lib:'lightsensor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the light sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the light sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'lightsensor&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Returns the current value of the ambient light, in the specified unit, as a floating point number.',lib:'lightsensor&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the ambient light, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ambient light, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'lightsensor&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['LightSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the light sensor.',lib:'lightsensor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the light sensor object'};
doc['LightSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the light sensor.',lib:'lightsensor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the light sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the light sensor object'};
doc['LightSensor']['get_friendlyName']={syn:'Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'lightsensor&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the light sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the light sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the light sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the light sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['LightSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'lightsensor&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['LightSensor']['get_functionId']={syn:'Returns the hardware identifier of the light sensor, without reference to the module.',lib:'lightsensor&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the light sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the light sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['LightSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'lightsensor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the light sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the light sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the light sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Returns the maximal value observed for the ambient light since the device was started.',lib:'lightsensor&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'lightsensor&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Returns the logical name of the light sensor.',lib:'lightsensor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the light sensor.</p>',ret:'a string corresponding to the logical name of the light sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the ambient light since the device was started.',lib:'lightsensor&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ambient light since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ambient light since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_measureType']={syn:'Returns the type of light measure.',lib:'lightsensor&rarr;get_measureType()',pro:'Y_MEASURETYPE_enum get_measureType()',cmt:'<p>Returns the type of light measure.</p>',ret:'a value among <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> and <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> corresponding to the type of light measure',ext:'On failure, throws an exception or returns <tt>Y_MEASURETYPE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'lightsensor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['LightSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'lightsensor&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['LightSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'lightsensor&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['LightSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'lightsensor&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'lightsensor&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Returns the measuring unit for the ambient light.',lib:'lightsensor&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the ambient light.</p>',ret:'a string corresponding to the measuring unit for the ambient light',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'lightsensor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['LightSensor']['isOnline']={syn:'Checks if the light sensor is currently reachable, without raising any error.',lib:'lightsensor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the light sensor is currently reachable, without raising any error. If there is a cached value for the light sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the light sensor.</p>',ret:'<tt>true</tt> if the light sensor can be reached, and <tt>false</tt> otherwise'};
doc['LightSensor']['load']={syn:'Preloads the light sensor cache with a specified validity duration.',lib:'lightsensor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the light sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'lightsensor&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['LightSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'lightsensor&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'lightsensor&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['nextLightSensor']={syn:'Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.',lib:'lightsensor&rarr;nextLightSensor()',pro:'YLightSensor * nextLightSensor()',cmt:'<p>Continues the enumeration of light sensors started using <tt>yFirstLightSensor()</tt>.</p>',ret:'a pointer to a <tt>YLightSensor</tt> object, corresponding to a light sensor currently online, or a <tt>null</tt> pointer if there are no more light sensors to enumerate.'};
doc['LightSensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'lightsensor&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YLightSensorTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['LightSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'lightsensor&rarr;registerValueCallback()',pro:'int registerValueCallback(YLightSensorValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['LightSensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'lightsensor&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'lightsensor&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'lightsensor&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_logicalName']={syn:'Changes the logical name of the light sensor.',lib:'lightsensor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the light sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the light sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'lightsensor&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_measureType']={syn:'Changes the light sensor type used in the device.',lib:'lightsensor&rarr;set_measureType()',pro:'int set_measureType(Y_MEASURETYPE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the light sensor type used in the device. The measure can either approximate the response of the human eye, focus on a specific light spectrum, depending on the capabilities of the light-sensitive cell. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_MEASURETYPE_HUMAN_EYE</tt>, <tt>Y_MEASURETYPE_WIDE_SPECTRUM</tt>, <tt>Y_MEASURETYPE_INFRARED</tt>, <tt>Y_MEASURETYPE_HIGH_RATE</tt> and <tt>Y_MEASURETYPE_HIGH_ENERGY</tt> corresponding to the light sensor type used in the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'lightsensor&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'lightsensor&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['LightSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'lightsensor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['LightSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'lightsensor&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['LightSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'lightsensor&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['LightSensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'lightsensor&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: LightSensor)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'ColorLed function interface',inc:'#include &quot;yocto_colorled.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color LED using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Retrieves an RGB LED for a given identifier.',lib:'YColorLed::FindColorLed()',pro:'YColorLed* FindColorLed(string <span id=pn>func</span>)',cmt:'<p>Retrieves an RGB LED for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB LED is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLed.isOnline()</tt> to test if the RGB LED is indeed online at a given time. In case of ambiguity when looking for an RGB LED by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RGB LED'},ret:'a <tt>YColorLed</tt> object allowing you to drive the RGB LED.'};
doc['ColorLed']['FirstColorLed']={syn:'Starts the enumeration of RGB LEDs currently accessible.',lib:'YColorLed::FirstColorLed()',pro:'YColorLed* FirstColorLed()',cmt:'<p>Starts the enumeration of RGB LEDs currently accessible. Use the method <tt>YColorLed.nextColorLed()</tt> to iterate on next RGB LEDs.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to the first RGB LED currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLed']['addHslMoveToBlinkSeq']={syn:'Add a new transition to the blinking sequence, the move will be performed in the HSL space.',lib:'colorled&rarr;addHslMoveToBlinkSeq()',pro:'int addHslMoveToBlinkSeq(int <span id=pn>HSLcolor</span>, int <span id=pn>msDelay</span>)',cmt:'<p>Add a new transition to the blinking sequence, the move will be performed in the HSL space.</p>',par:{HSLcolor:'desired HSL color when the traisntion is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['addRgbMoveToBlinkSeq']={syn:'Adds a new transition to the blinking sequence, the move is performed in the RGB space.',lib:'colorled&rarr;addRgbMoveToBlinkSeq()',pro:'int addRgbMoveToBlinkSeq(int <span id=pn>RGBcolor</span>, int <span id=pn>msDelay</span>)',cmt:'<p>Adds a new transition to the blinking sequence, the move is performed in the RGB space.</p>',par:{RGBcolor:'desired RGB color when the transition is completed',msDelay:'duration of the color transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['clearCache']={syn:'Invalidates the cache.',lib:'colorled&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RGB LED attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['ColorLed']['describe']={syn:'Returns a short text that describes unambiguously the instance of the RGB LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB LED in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB LED (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLed']['get_advertisedValue']={syn:'Returns the current value of the RGB LED (no more than 6 characters).',lib:'colorled&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the RGB LED (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of the blinking sequence.',lib:'colorled&rarr;get_blinkSeqMaxSize()',pro:'int get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of the blinking sequence.</p>',ret:'an integer corresponding to the maximum length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSignature']={syn:'Return the blinking sequence signature.',lib:'colorled&rarr;get_blinkSeqSignature()',pro:'int get_blinkSeqSignature()',cmt:'<p>Return the blinking sequence signature. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQSIGNATURE_INVALID</tt>.'};
doc['ColorLed']['get_blinkSeqSize']={syn:'Returns the current length of the blinking sequence.',lib:'colorled&rarr;get_blinkSeqSize()',pro:'int get_blinkSeqSize()',cmt:'<p>Returns the current length of the blinking sequence.</p>',ret:'an integer corresponding to the current length of the blinking sequence',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQSIZE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Returns the error message of the latest error with the RGB LED.',lib:'colorled&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB LED object'};
doc['ColorLed']['get_errorType']={syn:'Returns the numerical error code of the latest error with the RGB LED.',lib:'colorled&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB LED. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB LED object'};
doc['ColorLed']['get_friendlyName']={syn:'Returns a global identifier of the RGB LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'colorled&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB LED in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB LED if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB LED (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB LED using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorled&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLed']['get_functionId']={syn:'Returns the hardware identifier of the RGB LED, without reference to the module.',lib:'colorled&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB LED, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB LED (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the RGB LED in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorled&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB LED in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB LED (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB LED (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Returns the current HSL color of the LED.',lib:'colorled&rarr;get_hslColor()',pro:'int get_hslColor()',cmt:'<p>Returns the current HSL color of the LED.</p>',ret:'an integer corresponding to the current HSL color of the LED',ext:'On failure, throws an exception or returns <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Returns the logical name of the RGB LED.',lib:'colorled&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the RGB LED.</p>',ret:'a string corresponding to the logical name of the RGB LED.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorled&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Returns the current RGB color of the LED.',lib:'colorled&rarr;get_rgbColor()',pro:'int get_rgbColor()',cmt:'<p>Returns the current RGB color of the LED.</p>',ret:'an integer corresponding to the current RGB color of the LED',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Returns the configured color to be displayed when the module is turned on.',lib:'colorled&rarr;get_rgbColorAtPowerOn()',pro:'int get_rgbColorAtPowerOn()',cmt:'<p>Returns the configured color to be displayed when the module is turned on.</p>',ret:'an integer corresponding to the configured color to be displayed when the module is turned on',ext:'On failure, throws an exception or returns <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorled&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLed']['hslMove']={syn:'Performs a smooth transition in the HSL color space between the current color and a target color.',lib:'colorled&rarr;hslMove()',pro:'int hslMove(int <span id=pn>hsl_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the HSL color space between the current color and a target color.</p>',par:{hsl_target:'desired HSL color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['isOnline']={syn:'Checks if the RGB LED is currently reachable, without raising any error.',lib:'colorled&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the RGB LED is currently reachable, without raising any error. If there is a cached value for the RGB LED in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB LED.</p>',ret:'<tt>true</tt> if the RGB LED can be reached, and <tt>false</tt> otherwise'};
doc['ColorLed']['load']={syn:'Preloads the RGB LED cache with a specified validity duration.',lib:'colorled&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB LED cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'colorled&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['ColorLed']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'colorled&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['nextColorLed']={syn:'Continues the enumeration of RGB LEDs started using <tt>yFirstColorLed()</tt>.',lib:'colorled&rarr;nextColorLed()',pro:'YColorLed * nextColorLed()',cmt:'<p>Continues the enumeration of RGB LEDs started using <tt>yFirstColorLed()</tt>.</p>',ret:'a pointer to a <tt>YColorLed</tt> object, corresponding to an RGB LED currently online, or a <tt>null</tt> pointer if there are no more RGB LEDs to enumerate.'};
doc['ColorLed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorled&rarr;registerValueCallback()',pro:'int registerValueCallback(YColorLedValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLed']['resetBlinkSeq']={syn:'Resets the preprogrammed blinking sequence.',lib:'colorled&rarr;resetBlinkSeq()',pro:'int resetBlinkSeq()',cmt:'<p>Resets the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['rgbMove']={syn:'Performs a smooth transition in the RGB color space between the current color and a target color.',lib:'colorled&rarr;rgbMove()',pro:'int rgbMove(int <span id=pn>rgb_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transition in the RGB color space between the current color and a target color.</p>',par:{rgb_target:'desired RGB color at the end of the transition',ms_duration:'duration of the transition, in millisecond'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_hslColor']={syn:'Changes the current color of the LED, using a color HSL.',lib:'colorled&rarr;set_hslColor()',pro:'int set_hslColor(int <span id=pn>newval</span>)',cmt:'<p>Changes the current color of the LED, using a color HSL. Encoding is done as follows: 0xHHSSLL.</p>',par:{newval:'an integer corresponding to the current color of the LED, using a color HSL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_logicalName']={syn:'Changes the logical name of the RGB LED.',lib:'colorled&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB LED. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColor']={syn:'Changes the current color of the LED, using an RGB color.',lib:'colorled&rarr;set_rgbColor()',pro:'int set_rgbColor(int <span id=pn>newval</span>)',cmt:'<p>Changes the current color of the LED, using an RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{newval:'an integer corresponding to the current color of the LED, using an RGB color'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Changes the color that the LED will display by default when the module is turned on.',lib:'colorled&rarr;set_rgbColorAtPowerOn()',pro:'int set_rgbColorAtPowerOn(int <span id=pn>newval</span>)',cmt:'<p>Changes the color that the LED will display by default when the module is turned on.</p>',par:{newval:'an integer corresponding to the color that the LED will display by default when the module is turned on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorled&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['ColorLed']['startBlinkSeq']={syn:'Starts the preprogrammed blinking sequence.',lib:'colorled&rarr;startBlinkSeq()',pro:'int startBlinkSeq()',cmt:'<p>Starts the preprogrammed blinking sequence. The sequence is run in a loop until it is stopped by stopBlinkSeq or an explicit change.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['stopBlinkSeq']={syn:'Stops the preprogrammed blinking sequence.',lib:'colorled&rarr;stopBlinkSeq()',pro:'int stopBlinkSeq()',cmt:'<p>Stops the preprogrammed blinking sequence.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['ColorLed']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'colorled&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: ColorLed)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Yocto-hub port interface',inc:'#include &quot;yocto_hubport.h&quot;',cmt:'<p>YHubPort objects provide control over the power supply for every YoctoHub port and provide information about the device connected to it. The logical name of a YHubPort is always automatically set to the unique serial number of the Yoctopuce device connected to it.</p>'}};
doc['HubPort']['FindHubPort']={syn:'Retrieves a Yocto-hub port for a given identifier.',lib:'YHubPort::FindHubPort()',pro:'YHubPort* FindHubPort(string <span id=pn>func</span>)',cmt:'<p>Retrieves a Yocto-hub port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Yocto-hub port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YHubPort.isOnline()</tt> to test if the Yocto-hub port is indeed online at a given time. In case of ambiguity when looking for a Yocto-hub port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Yocto-hub port'},ret:'a <tt>YHubPort</tt> object allowing you to drive the Yocto-hub port.'};
doc['HubPort']['FirstHubPort']={syn:'Starts the enumeration of Yocto-hub ports currently accessible.',lib:'YHubPort::FirstHubPort()',pro:'YHubPort* FirstHubPort()',cmt:'<p>Starts the enumeration of Yocto-hub ports currently accessible. Use the method <tt>YHubPort.nextHubPort()</tt> to iterate on next Yocto-hub ports.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to the first Yocto-hub port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['HubPort']['clearCache']={syn:'Invalidates the cache.',lib:'hubport&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Yocto-hub port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['HubPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Yocto-hub port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Yocto-hub port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Yocto-hub port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['HubPort']['get_advertisedValue']={syn:'Returns the current value of the Yocto-hub port (no more than 6 characters).',lib:'hubport&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the Yocto-hub port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Yocto-hub port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Returns the current baud rate used by this Yocto-hub port, in kbps.',lib:'hubport&rarr;get_baudRate()',pro:'int get_baudRate()',cmt:'<p>Returns the current baud rate used by this Yocto-hub port, in kbps. The default value is 1000 kbps, but a slower rate may be used if communication problems are encountered.</p>',ret:'an integer corresponding to the current baud rate used by this Yocto-hub port, in kbps',ext:'On failure, throws an exception or returns <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Returns true if the Yocto-hub port is powered, false otherwise.',lib:'hubport&rarr;get_enabled()',pro:'Y_ENABLED_enum get_enabled()',cmt:'<p>Returns true if the Yocto-hub port is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the Yocto-hub port is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the Yocto-hub port.',lib:'hubport&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Yocto-hub port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Yocto-hub port object'};
doc['HubPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Yocto-hub port.',lib:'hubport&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Yocto-hub port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Yocto-hub port object'};
doc['HubPort']['get_friendlyName']={syn:'Returns a global identifier of the Yocto-hub port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'hubport&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the Yocto-hub port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Yocto-hub port if they are defined, otherwise the serial number of the module and the hardware identifier of the Yocto-hub port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Yocto-hub port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['HubPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'hubport&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['HubPort']['get_functionId']={syn:'Returns the hardware identifier of the Yocto-hub port, without reference to the module.',lib:'hubport&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the Yocto-hub port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Yocto-hub port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['HubPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Yocto-hub port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'hubport&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Yocto-hub port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Yocto-hub port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Yocto-hub port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Returns the logical name of the Yocto-hub port.',lib:'hubport&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the Yocto-hub port.</p>',ret:'a string corresponding to the logical name of the Yocto-hub port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'hubport&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Returns the current state of the Yocto-hub port.',lib:'hubport&rarr;get_portState()',pro:'Y_PORTSTATE_enum get_portState()',cmt:'<p>Returns the current state of the Yocto-hub port.</p>',ret:'a value among <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_OVRLD</tt>, <tt>Y_PORTSTATE_ON</tt>, <tt>Y_PORTSTATE_RUN</tt> and <tt>Y_PORTSTATE_PROG</tt> corresponding to the current state of the Yocto-hub port',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'hubport&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['HubPort']['isOnline']={syn:'Checks if the Yocto-hub port is currently reachable, without raising any error.',lib:'hubport&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the Yocto-hub port is currently reachable, without raising any error. If there is a cached value for the Yocto-hub port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Yocto-hub port.</p>',ret:'<tt>true</tt> if the Yocto-hub port can be reached, and <tt>false</tt> otherwise'};
doc['HubPort']['load']={syn:'Preloads the Yocto-hub port cache with a specified validity duration.',lib:'hubport&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the Yocto-hub port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'hubport&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['HubPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'hubport&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['nextHubPort']={syn:'Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.',lib:'hubport&rarr;nextHubPort()',pro:'YHubPort * nextHubPort()',cmt:'<p>Continues the enumeration of Yocto-hub ports started using <tt>yFirstHubPort()</tt>.</p>',ret:'a pointer to a <tt>YHubPort</tt> object, corresponding to a Yocto-hub port currently online, or a <tt>null</tt> pointer if there are no more Yocto-hub ports to enumerate.'};
doc['HubPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'hubport&rarr;registerValueCallback()',pro:'int registerValueCallback(YHubPortValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['HubPort']['set_enabled']={syn:'Changes the activation of the Yocto-hub port.',lib:'hubport&rarr;set_enabled()',pro:'int set_enabled(Y_ENABLED_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation of the Yocto-hub port. If the port is enabled, the connected module is powered. Otherwise, port power is shut down.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the activation of the Yocto-hub port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_logicalName']={syn:'Changes the logical name of the Yocto-hub port.',lib:'hubport&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Yocto-hub port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Yocto-hub port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['HubPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'hubport&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['HubPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'hubport&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'AnButton function interface',inc:'#include &quot;yocto_anbutton.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to measure the state of a simple button as well as to read an analog potentiometer (variable resistance). This can be use for instance with a continuous rotating knob, a throttle grip or a joystick. The module is capable to calibrate itself on min and max values, in order to compute a calibrated value that varies proportionally with the potentiometer position, regardless of its total resistance.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Retrieves an analog input for a given identifier.',lib:'YAnButton::FindAnButton()',pro:'YAnButton* FindAnButton(string <span id=pn>func</span>)',cmt:'<p>Retrieves an analog input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the analog input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAnButton.isOnline()</tt> to test if the analog input is indeed online at a given time. In case of ambiguity when looking for an analog input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the analog input'},ret:'a <tt>YAnButton</tt> object allowing you to drive the analog input.'};
doc['AnButton']['FirstAnButton']={syn:'Starts the enumeration of analog inputs currently accessible.',lib:'YAnButton::FirstAnButton()',pro:'YAnButton* FirstAnButton()',cmt:'<p>Starts the enumeration of analog inputs currently accessible. Use the method <tt>YAnButton.nextAnButton()</tt> to iterate on next analog inputs.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to the first analog input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AnButton']['clearCache']={syn:'Invalidates the cache.',lib:'anbutton&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the analog input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['AnButton']['describe']={syn:'Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the analog input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the analog input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AnButton']['get_advertisedValue']={syn:'Returns the current value of the analog input (no more than 6 characters).',lib:'anbutton&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the analog input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the analog input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Tells if a calibration process is currently ongoing.',lib:'anbutton&rarr;get_analogCalibration()',pro:'Y_ANALOGCALIBRATION_enum get_analogCalibration()',cmt:'<p>Tells if a calibration process is currently ongoing.</p>',ret:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'On failure, throws an exception or returns <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Returns the current calibrated input value (between 0 and 1000, included).',lib:'anbutton&rarr;get_calibratedValue()',pro:'int get_calibratedValue()',cmt:'<p>Returns the current calibrated input value (between 0 and 1000, included).</p>',ret:'an integer corresponding to the current calibrated input value (between 0 and 1000, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Returns the maximal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton&rarr;get_calibrationMax()',pro:'int get_calibrationMax()',cmt:'<p>Returns the maximal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the maximal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Returns the minimal value measured during the calibration (between 0 and 4095, included).',lib:'anbutton&rarr;get_calibrationMin()',pro:'int get_calibrationMin()',cmt:'<p>Returns the minimal value measured during the calibration (between 0 and 4095, included).</p>',ret:'an integer corresponding to the minimal value measured during the calibration (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Returns the error message of the latest error with the analog input.',lib:'anbutton&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the analog input object'};
doc['AnButton']['get_errorType']={syn:'Returns the numerical error code of the latest error with the analog input.',lib:'anbutton&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the analog input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the analog input object'};
doc['AnButton']['get_friendlyName']={syn:'Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'anbutton&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the analog input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the analog input if they are defined, otherwise the serial number of the module and the hardware identifier of the analog input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the analog input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AnButton']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'anbutton&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AnButton']['get_functionId']={syn:'Returns the hardware identifier of the analog input, without reference to the module.',lib:'anbutton&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the analog input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the analog input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AnButton']['get_hardwareId']={syn:'Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'anbutton&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the analog input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the analog input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the analog input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Returns true if the input (considered as binary) is active (closed contact), and false otherwise.',lib:'anbutton&rarr;get_isPressed()',pro:'Y_ISPRESSED_enum get_isPressed()',cmt:'<p>Returns true if the input (considered as binary) is active (closed contact), and false otherwise.</p>',ret:'either <tt>Y_ISPRESSED_FALSE</tt> or <tt>Y_ISPRESSED_TRUE</tt>, according to true if the input (considered as binary) is active (closed contact), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).',lib:'anbutton&rarr;get_lastTimePressed()',pro:'s64 get_lastTimePressed()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was pressed (the input contact transitioned from open to closed)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).',lib:'anbutton&rarr;get_lastTimeReleased()',pro:'s64 get_lastTimeReleased()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last time the input button was released (the input contact transitioned from closed to open)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Returns the logical name of the analog input.',lib:'anbutton&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the analog input.</p>',ret:'a string corresponding to the logical name of the analog input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'anbutton&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'anbutton&rarr;get_pulseCounter()',pro:'s64 get_pulseCounter()',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just \x09 call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms).',lib:'anbutton&rarr;get_pulseTimer()',pro:'s64 get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Returns the current measured input value as-is (between 0 and 4095, included).',lib:'anbutton&rarr;get_rawValue()',pro:'int get_rawValue()',cmt:'<p>Returns the current measured input value as-is (between 0 and 4095, included).</p>',ret:'an integer corresponding to the current measured input value as-is (between 0 and 4095, included)',ext:'On failure, throws an exception or returns <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton&rarr;get_sensitivity()',pro:'int get_sensitivity()',cmt:'<p>Returns the sensibility for the input (between 1 and 1000) for triggering user callbacks.</p>',ret:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks',ext:'On failure, throws an exception or returns <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'anbutton&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AnButton']['isOnline']={syn:'Checks if the analog input is currently reachable, without raising any error.',lib:'anbutton&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the analog input is currently reachable, without raising any error. If there is a cached value for the analog input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the analog input.</p>',ret:'<tt>true</tt> if the analog input can be reached, and <tt>false</tt> otherwise'};
doc['AnButton']['load']={syn:'Preloads the analog input cache with a specified validity duration.',lib:'anbutton&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the analog input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'anbutton&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['AnButton']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'anbutton&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['nextAnButton']={syn:'Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.',lib:'anbutton&rarr;nextAnButton()',pro:'YAnButton * nextAnButton()',cmt:'<p>Continues the enumeration of analog inputs started using <tt>yFirstAnButton()</tt>.</p>',ret:'a pointer to a <tt>YAnButton</tt> object, corresponding to an analog input currently online, or a <tt>null</tt> pointer if there are no more analog inputs to enumerate.'};
doc['AnButton']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'anbutton&rarr;registerValueCallback()',pro:'int registerValueCallback(YAnButtonValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AnButton']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'anbutton&rarr;resetCounter()',pro:'int resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_analogCalibration']={syn:'Starts or stops the calibration process.',lib:'anbutton&rarr;set_analogCalibration()',pro:'int set_analogCalibration(Y_ANALOGCALIBRATION_enum <span id=pn>newval</span>)',cmt:'<p>Starts or stops the calibration process. Remember to call the <tt>saveToFlash()</tt> method of the module at the end of the calibration if the modification must be kept.</p>',par:{newval:'either <tt>Y_ANALOGCALIBRATION_OFF</tt> or <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMax']={syn:'Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton&rarr;set_calibrationMax()',pro:'int set_calibrationMax(int <span id=pn>newval</span>)',cmt:'<p>Changes the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the maximal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_calibrationMin']={syn:'Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration.',lib:'anbutton&rarr;set_calibrationMin()',pro:'int set_calibrationMin(int <span id=pn>newval</span>)',cmt:'<p>Changes the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the minimal calibration value for the input (between 0 and 4095, included), without actually starting the automated calibration'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_logicalName']={syn:'Changes the logical name of the analog input.',lib:'anbutton&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the analog input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the analog input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_sensitivity']={syn:'Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks.',lib:'anbutton&rarr;set_sensitivity()',pro:'int set_sensitivity(int <span id=pn>newval</span>)',cmt:'<p>Changes the sensibility for the input (between 1 and 1000) for triggering user callbacks. The sensibility is used to filter variations around a fixed value, but does not preclude the transmission of events when the input value evolves constantly in the same direction. Special case: when the value 1000 is used, the callback will only be thrown when the logical state of the input switches from pressed to released and back. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the sensibility for the input (between 1 and 1000) for triggering user callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AnButton']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'anbutton&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['AnButton']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'anbutton&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Voltage function interface',inc:'#include &quot;yocto_voltage.h&quot;',cmt:'<p>The Yoctopuce class YVoltage allows you to read and configure Yoctopuce voltage sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Retrieves a voltage sensor for a given identifier.',lib:'YVoltage::FindVoltage()',pro:'YVoltage* FindVoltage(string <span id=pn>func</span>)',cmt:'<p>Retrieves a voltage sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltage.isOnline()</tt> to test if the voltage sensor is indeed online at a given time. In case of ambiguity when looking for a voltage sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage sensor'},ret:'a <tt>YVoltage</tt> object allowing you to drive the voltage sensor.'};
doc['Voltage']['FirstVoltage']={syn:'Starts the enumeration of voltage sensors currently accessible.',lib:'YVoltage::FirstVoltage()',pro:'YVoltage* FirstVoltage()',cmt:'<p>Starts the enumeration of voltage sensors currently accessible. Use the method <tt>YVoltage.nextVoltage()</tt> to iterate on next voltage sensors.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to the first voltage sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voltage']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voltage&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['clearCache']={syn:'Invalidates the cache.',lib:'voltage&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Voltage']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voltage']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'voltage&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Voltage']['get_advertisedValue']={syn:'Returns the current value of the voltage sensor (no more than 6 characters).',lib:'voltage&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the voltage sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.',lib:'voltage&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Returns the current value of the voltage, in Volt, as a floating point number.',lib:'voltage&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the voltage, in Volt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the voltage, in Volt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'voltage&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Voltage']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage sensor.',lib:'voltage&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage sensor object'};
doc['Voltage']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage sensor.',lib:'voltage&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage sensor object'};
doc['Voltage']['get_friendlyName']={syn:'Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voltage&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voltage']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltage&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voltage']['get_functionId']={syn:'Returns the hardware identifier of the voltage sensor, without reference to the module.',lib:'voltage&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voltage']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltage&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Returns the maximal value observed for the voltage since the device was started.',lib:'voltage&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'voltage&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Returns the logical name of the voltage sensor.',lib:'voltage&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the voltage sensor.</p>',ret:'a string corresponding to the logical name of the voltage sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Returns the minimal value observed for the voltage since the device was started.',lib:'voltage&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the voltage since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the voltage since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltage&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voltage']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'voltage&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voltage']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'voltage&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voltage']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voltage&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'voltage&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'voltage&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltage&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voltage']['isOnline']={syn:'Checks if the voltage sensor is currently reachable, without raising any error.',lib:'voltage&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the voltage sensor is currently reachable, without raising any error. If there is a cached value for the voltage sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage sensor.</p>',ret:'<tt>true</tt> if the voltage sensor can be reached, and <tt>false</tt> otherwise'};
doc['Voltage']['load']={syn:'Preloads the voltage sensor cache with a specified validity duration.',lib:'voltage&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'voltage&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Voltage']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'voltage&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'voltage&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['nextVoltage']={syn:'Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.',lib:'voltage&rarr;nextVoltage()',pro:'YVoltage * nextVoltage()',cmt:'<p>Continues the enumeration of voltage sensors started using <tt>yFirstVoltage()</tt>.</p>',ret:'a pointer to a <tt>YVoltage</tt> object, corresponding to a voltage sensor currently online, or a <tt>null</tt> pointer if there are no more voltage sensors to enumerate.'};
doc['Voltage']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'voltage&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YVoltageTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Voltage']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltage&rarr;registerValueCallback()',pro:'int registerValueCallback(YVoltageValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voltage']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'voltage&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voltage&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'voltage&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_logicalName']={syn:'Changes the logical name of the voltage sensor.',lib:'voltage&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voltage&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'voltage&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'voltage&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voltage']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltage&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Voltage']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'voltage&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voltage']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'voltage&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voltage']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'voltage&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Voltage)
//--- (generated code: Current)
doc['Current']={'':{syn:'Current function interface',inc:'#include &quot;yocto_current.h&quot;',cmt:'<p>The Yoctopuce class YCurrent allows you to read and configure Yoctopuce current sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Current']['FindCurrent']={syn:'Retrieves a current sensor for a given identifier.',lib:'YCurrent::FindCurrent()',pro:'YCurrent* FindCurrent(string <span id=pn>func</span>)',cmt:'<p>Retrieves a current sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the current sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrent.isOnline()</tt> to test if the current sensor is indeed online at a given time. In case of ambiguity when looking for a current sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the current sensor'},ret:'a <tt>YCurrent</tt> object allowing you to drive the current sensor.'};
doc['Current']['FirstCurrent']={syn:'Starts the enumeration of current sensors currently accessible.',lib:'YCurrent::FirstCurrent()',pro:'YCurrent* FirstCurrent()',cmt:'<p>Starts the enumeration of current sensors currently accessible. Use the method <tt>YCurrent.nextCurrent()</tt> to iterate on next current sensors.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to the first current sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Current']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'current&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['clearCache']={syn:'Invalidates the cache.',lib:'current&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the current sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Current']['describe']={syn:'Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'current&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the current sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the current sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Current']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'current&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Current']['get_advertisedValue']={syn:'Returns the current value of the current sensor (no more than 6 characters).',lib:'current&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the current sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the current sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.',lib:'current&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Returns the current value of the current, in mA, as a floating point number.',lib:'current&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the current, in mA, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the current, in mA, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'current&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Current']['get_errorMessage']={syn:'Returns the error message of the latest error with the current sensor.',lib:'current&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the current sensor object'};
doc['Current']['get_errorType']={syn:'Returns the numerical error code of the latest error with the current sensor.',lib:'current&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the current sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the current sensor object'};
doc['Current']['get_friendlyName']={syn:'Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'current&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the current sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the current sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the current sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the current sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Current']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'current&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Current']['get_functionId']={syn:'Returns the hardware identifier of the current sensor, without reference to the module.',lib:'current&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the current sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the current sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Current']['get_hardwareId']={syn:'Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'current&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the current sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the current sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the current sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Returns the maximal value observed for the current since the device was started.',lib:'current&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'current&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Returns the logical name of the current sensor.',lib:'current&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the current sensor.</p>',ret:'a string corresponding to the logical name of the current sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Returns the minimal value observed for the current since the device was started.',lib:'current&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the current since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the current since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'current&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Current']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'current&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Current']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'current&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Current']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'current&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'current&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Returns the measuring unit for the current.',lib:'current&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the current.</p>',ret:'a string corresponding to the measuring unit for the current',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'current&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Current']['isOnline']={syn:'Checks if the current sensor is currently reachable, without raising any error.',lib:'current&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the current sensor is currently reachable, without raising any error. If there is a cached value for the current sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the current sensor.</p>',ret:'<tt>true</tt> if the current sensor can be reached, and <tt>false</tt> otherwise'};
doc['Current']['load']={syn:'Preloads the current sensor cache with a specified validity duration.',lib:'current&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the current sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'current&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Current']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'current&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'current&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['nextCurrent']={syn:'Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.',lib:'current&rarr;nextCurrent()',pro:'YCurrent * nextCurrent()',cmt:'<p>Continues the enumeration of current sensors started using <tt>yFirstCurrent()</tt>.</p>',ret:'a pointer to a <tt>YCurrent</tt> object, corresponding to a current sensor currently online, or a <tt>null</tt> pointer if there are no more current sensors to enumerate.'};
doc['Current']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'current&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YCurrentTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Current']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'current&rarr;registerValueCallback()',pro:'int registerValueCallback(YCurrentValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Current']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'current&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'current&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'current&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_logicalName']={syn:'Changes the logical name of the current sensor.',lib:'current&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the current sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the current sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'current&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'current&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'current&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Current']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'current&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Current']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'current&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Current']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'current&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Current']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'current&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Current)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'CarbonDioxide function interface',inc:'#include &quot;yocto_carbondioxide.h&quot;',cmt:'<p>The Yoctopuce class YCarbonDioxide allows you to read and configure Yoctopuce CO2 sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to perform manual calibration if reuired.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Retrieves a CO2 sensor for a given identifier.',lib:'YCarbonDioxide::FindCarbonDioxide()',pro:'YCarbonDioxide* FindCarbonDioxide(string <span id=pn>func</span>)',cmt:'<p>Retrieves a CO2 sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the CO2 sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCarbonDioxide.isOnline()</tt> to test if the CO2 sensor is indeed online at a given time. In case of ambiguity when looking for a CO2 sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the CO2 sensor'},ret:'a <tt>YCarbonDioxide</tt> object allowing you to drive the CO2 sensor.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Starts the enumeration of CO2 sensors currently accessible.',lib:'YCarbonDioxide::FirstCarbonDioxide()',pro:'YCarbonDioxide* FirstCarbonDioxide()',cmt:'<p>Starts the enumeration of CO2 sensors currently accessible. Use the method <tt>YCarbonDioxide.nextCarbonDioxide()</tt> to iterate on next CO2 sensors.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to the first CO2 sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'carbondioxide&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['clearCache']={syn:'Invalidates the cache.',lib:'carbondioxide&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the CO2 sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['CarbonDioxide']['describe']={syn:'Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the CO2 sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the CO2 sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CarbonDioxide']['get_abcPeriod']={syn:'Returns the Automatic Baseline Calibration period, in hours.',lib:'carbondioxide&rarr;get_abcPeriod()',pro:'int get_abcPeriod()',cmt:'<p>Returns the Automatic Baseline Calibration period, in hours. A negative value means that automatic baseline calibration is disabled.</p>',ret:'an integer corresponding to the Automatic Baseline Calibration period, in hours',ext:'On failure, throws an exception or returns <tt>Y_ABCPERIOD_INVALID</tt>.'};
doc['CarbonDioxide']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'carbondioxide&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Returns the current value of the CO2 sensor (no more than 6 characters).',lib:'carbondioxide&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the CO2 sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the CO2 sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'carbondioxide&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.',lib:'carbondioxide&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the CO2 concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the CO2 concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'carbondioxide&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Returns the error message of the latest error with the CO2 sensor.',lib:'carbondioxide&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the CO2 sensor object'};
doc['CarbonDioxide']['get_errorType']={syn:'Returns the numerical error code of the latest error with the CO2 sensor.',lib:'carbondioxide&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the CO2 sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the CO2 sensor object'};
doc['CarbonDioxide']['get_friendlyName']={syn:'Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'carbondioxide&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the CO2 sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the CO2 sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the CO2 sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the CO2 sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'carbondioxide&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionId']={syn:'Returns the hardware identifier of the CO2 sensor, without reference to the module.',lib:'carbondioxide&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the CO2 sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the CO2 sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CarbonDioxide']['get_hardwareId']={syn:'Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'carbondioxide&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the CO2 sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the CO2 sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the CO2 sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Returns the maximal value observed for the CO2 concentration since the device was started.',lib:'carbondioxide&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'carbondioxide&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Returns the logical name of the CO2 sensor.',lib:'carbondioxide&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the CO2 sensor.</p>',ret:'a string corresponding to the logical name of the CO2 sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Returns the minimal value observed for the CO2 concentration since the device was started.',lib:'carbondioxide&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the CO2 concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the CO2 concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'carbondioxide&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CarbonDioxide']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'carbondioxide&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['CarbonDioxide']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'carbondioxide&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['CarbonDioxide']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'carbondioxide&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'carbondioxide&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Returns the measuring unit for the CO2 concentration.',lib:'carbondioxide&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the CO2 concentration.</p>',ret:'a string corresponding to the measuring unit for the CO2 concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'carbondioxide&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CarbonDioxide']['isOnline']={syn:'Checks if the CO2 sensor is currently reachable, without raising any error.',lib:'carbondioxide&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the CO2 sensor is currently reachable, without raising any error. If there is a cached value for the CO2 sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the CO2 sensor.</p>',ret:'<tt>true</tt> if the CO2 sensor can be reached, and <tt>false</tt> otherwise'};
doc['CarbonDioxide']['load']={syn:'Preloads the CO2 sensor cache with a specified validity duration.',lib:'carbondioxide&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the CO2 sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'carbondioxide&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['CarbonDioxide']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'carbondioxide&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'carbondioxide&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide&rarr;nextCarbonDioxide()',pro:'YCarbonDioxide * nextCarbonDioxide()',cmt:'<p>Continues the enumeration of CO2 sensors started using <tt>yFirstCarbonDioxide()</tt>.</p>',ret:'a pointer to a <tt>YCarbonDioxide</tt> object, corresponding to a CO2 sensor currently online, or a <tt>null</tt> pointer if there are no more CO2 sensors to enumerate.'};
doc['CarbonDioxide']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'carbondioxide&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YCarbonDioxideTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['CarbonDioxide']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'carbondioxide&rarr;registerValueCallback()',pro:'int registerValueCallback(YCarbonDioxideValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CarbonDioxide']['set_abcPeriod']={syn:'Changes Automatic Baseline Calibration period, in hours.',lib:'carbondioxide&rarr;set_abcPeriod()',pro:'int set_abcPeriod(int <span id=pn>newval</span>)',cmt:'<p>Changes Automatic Baseline Calibration period, in hours. If you need to disable automatic baseline calibration (for instance when using the sensor in an environment that is constantly above 400ppm CO2), set the period to -1. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to Automatic Baseline Calibration period, in hours'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'carbondioxide&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'carbondioxide&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'carbondioxide&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Changes the logical name of the CO2 sensor.',lib:'carbondioxide&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the CO2 sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the CO2 sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'carbondioxide&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'carbondioxide&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'carbondioxide&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'carbondioxide&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['CarbonDioxide']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'carbondioxide&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['CarbonDioxide']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'carbondioxide&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['CarbonDioxide']['triggerBaselineCalibration']={syn:'Triggers a baseline calibration at standard CO2 ambiant level (400ppm).',lib:'carbondioxide&rarr;triggerBaselineCalibration()',pro:'int triggerBaselineCalibration()',cmt:'<p>Triggers a baseline calibration at standard CO2 ambiant level (400ppm). It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a baseline calibration, make sure to put the sensor in a standard environment (e.g. outside in fresh air) at around 400ppm.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['triggerZeroCalibration']={syn:'Triggers a zero calibration of the sensor on carbon dioxide-free air.',lib:'carbondioxide&rarr;triggerZeroCalibration()',pro:'int triggerZeroCalibration()',cmt:'<p>Triggers a zero calibration of the sensor on carbon dioxide-free air. It is normally not necessary to manually calibrate the sensor, because the built-in automatic baseline calibration procedure will automatically fix any long-term drift based on the lowest level of CO2 observed over the automatic calibration period. However, if you disable automatic baseline calibration, you may want to manually trigger a calibration from time to time. Before starting a zero calibration, you should circulate carbon dioxide-free air within the sensor for a minute or two, using a small pipe connected to the sensor. Please contact support@yoctopuce.com for more details on the zero calibration procedure.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CarbonDioxide']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'carbondioxide&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Voltage source function interface',inc:'#include "yocto_vsource.h"',cmt:'<p>Yoctopuce application programming interface allows you to control the module voltage output. You affect absolute output values or make transitions</p>'}};
doc['VSource']['FindVSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YVSource::FindVSource()',pro:'YVSource* FindVSource(const string& <span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YVSource</tt> object allowing you to drive the voltage source.'};
doc['VSource']['FirstVSource']={syn:'Starts the enumeration of voltage sources currently accessible.',lib:'YVSource::FirstVSource()',pro:'YVSource* FirstVSource()',cmt:'<p>Starts the enumeration of voltage sources currently accessible. Use the method <tt>YVSource.nextVSource()</tt> to iterate on next voltage sources.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to the first voltage source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VSource']['describe']={syn:'Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL.FUNCTIONID</tt>.',lib:'vsource&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes the function in the form <tt>TYPE(NAME)=SERIAL.FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the function (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['VSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'vsource&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters)',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Returns the error message of the latest error with this function.',lib:'vsource&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using this function object'};
doc['VSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with this function.',lib:'vsource&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with this function. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occured while using this function object'};
doc['VSource']['get_extPowerFailure']={syn:'Returns true if external power supply voltage is too low.',lib:'vsource&rarr;get_extPowerFailure()',pro:'Y_EXTPOWERFAILURE_enum get_extPowerFailure()',cmt:'<p>Returns true if external power supply voltage is too low.</p>',ret:'either <tt>Y_EXTPOWERFAILURE_FALSE</tt> or <tt>Y_EXTPOWERFAILURE_TRUE</tt>, according to true if external power supply voltage is too low',ext:'On failure, throws an exception or returns <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Returns true if the module is in failure mode.',lib:'vsource&rarr;get_failure()',pro:'Y_FAILURE_enum get_failure()',cmt:'<p>Returns true if the module is in failure mode. More information can be obtained by testing get_overheat, get_overcurrent etc... When a error condition is met, the output voltage is set to z\xE9ro and cannot be changed until the reset() function is called.</p>',ret:'either <tt>Y_FAILURE_FALSE</tt> or <tt>Y_FAILURE_TRUE</tt>, according to true if the module is in failure mode',ext:'On failure, throws an exception or returns <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_friendlyName']={syn:'Returns a global identifier of the function in the format <tt>MODULE_NAME.FUNCTION_NAME</tt>.',lib:'vsource&rarr;get_friendlyName()',pro:'virtual string get_friendlyName()',cmt:'<p>Returns a global identifier of the function in the format <tt>MODULE_NAME.FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the function if they are defined, otherwise the serial number of the module and the hardware identifier of the function (for exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the function using logical names (ex: <tt>MyCustomName.relay1</tt>) On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'vsource&rarr;get_vsourceDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>. If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VSource']['get_functionId']={syn:'Returns the hardware identifier of the function, without reference to the module.',lib:'vsource&rarr;get_vsourceId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the function (ex: <tt>relay1</tt>) On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['VSource']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'vsource&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function. (for example <tt>RELAYLO1-123456.relay1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>RELAYLO1-123456.relay1</tt>) On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['VSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'vsource&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'vsource&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Returns true if the appliance connected to the device is too greedy .',lib:'vsource&rarr;get_overCurrent()',pro:'Y_OVERCURRENT_enum get_overCurrent()',cmt:'<p>Returns true if the appliance connected to the device is too greedy .</p>',ret:'either <tt>Y_OVERCURRENT_FALSE</tt> or <tt>Y_OVERCURRENT_TRUE</tt>, according to true if the appliance connected to the device is too greedy',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Returns TRUE if the module is overheating.',lib:'vsource&rarr;get_overHeat()',pro:'Y_OVERHEAT_enum get_overHeat()',cmt:'<p>Returns TRUE if the module is overheating.</p>',ret:'either <tt>Y_OVERHEAT_FALSE</tt> or <tt>Y_OVERHEAT_TRUE</tt>, according to TRUE if the module is overheating',ext:'On failure, throws an exception or returns <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Returns true if the device is not able to maintaint the requested voltage output .',lib:'vsource&rarr;get_overLoad()',pro:'Y_OVERLOAD_enum get_overLoad()',cmt:'<p>Returns true if the device is not able to maintaint the requested voltage output .</p>',ret:'either <tt>Y_OVERLOAD_FALSE</tt> or <tt>Y_OVERLOAD_TRUE</tt>, according to true if the device is not able to maintaint the requested voltage output',ext:'On failure, throws an exception or returns <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Returns true if the voltage output is too high regarding the requested voltage .',lib:'vsource&rarr;get_regulationFailure()',pro:'Y_REGULATIONFAILURE_enum get_regulationFailure()',cmt:'<p>Returns true if the voltage output is too high regarding the requested voltage .</p>',ret:'either <tt>Y_REGULATIONFAILURE_FALSE</tt> or <tt>Y_REGULATIONFAILURE_TRUE</tt>, according to true if the voltage output is too high regarding the requested voltage',ext:'On failure, throws an exception or returns <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Returns the measuring unit for the voltage.',lib:'vsource&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the voltage.</p>',ret:'a string corresponding to the measuring unit for the voltage',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'vsource&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VSource']['get_voltage']={syn:'Returns the voltage output command (mV) ',lib:'vsource&rarr;get_voltage()',pro:'int get_voltage()',cmt:'<p>Returns the voltage output command (mV)</p>',ret:'an integer corresponding to the voltage output command (mV)',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'Checks if the function is currently reachable, without raising any error.',lib:'vsource&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the function is currently reachable, without raising any error. If there is a cached value for the function in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the requested function.</p>',ret:'<tt>true</tt> if the function can be reached, and <tt>false</tt> otherwise'};
doc['VSource']['load']={syn:'Preloads the function cache with a specified validity duration.',lib:'vsource&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the function cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network trafic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['VSource']['nextVSource']={syn:'Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.',lib:'vsource&rarr;nextVSource()',pro:'YVSource * nextVSource()',cmt:'<p>Continues the enumeration of voltage sources started using <tt>yFirstVSource()</tt>.</p>',ret:'a pointer to a <tt>YVSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more voltage sources to enumerate.'};
doc['VSource']['pulse']={syn:'Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.',lib:'vsource&rarr;pulse()',pro:'int pulse(int <span id=pn>voltage</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Sets device output to a specific volatage, for a specified duration, then brings it automatically to 0V.</p>',par:{voltage:'pulse voltage, in millivolts',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'vsource&rarr;registerValueCallback()',pro:'void registerValueCallback(YDisplayUpdateCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'vsource&rarr;set_logicalName()',pro:'int set_logicalName(const string& <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'vsource&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VSource']['set_voltage']={syn:'Tunes the device output voltage (milliVolts).',lib:'vsource&rarr;set_voltage()',pro:'int set_voltage(int <span id=pn>newval</span>)',cmt:'<p>Tunes the device output voltage (milliVolts).</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VSource']['voltageMove']={syn:'Performs a smooth move at constant speed toward a given value.',lib:'vsource&rarr;voltageMove()',pro:'int voltageMove(int <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth move at constant speed toward a given value.</p>',par:{target:'new output value at end of transition, in milliVolts.',ms_duration:'transition duration, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: VSource)
//--- (generated code: Network)
doc['Network']={'':{syn:'Network function interface',inc:'#include &quot;yocto_network.h&quot;',cmt:'<p>YNetwork objects provide access to TCP/IP parameters of Yoctopuce modules that include a built-in network interface.</p>'}};
doc['Network']['FindNetwork']={syn:'Retrieves a network interface for a given identifier.',lib:'YNetwork::FindNetwork()',pro:'YNetwork* FindNetwork(string <span id=pn>func</span>)',cmt:'<p>Retrieves a network interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the network interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YNetwork.isOnline()</tt> to test if the network interface is indeed online at a given time. In case of ambiguity when looking for a network interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the network interface'},ret:'a <tt>YNetwork</tt> object allowing you to drive the network interface.'};
doc['Network']['FirstNetwork']={syn:'Starts the enumeration of network interfaces currently accessible.',lib:'YNetwork::FirstNetwork()',pro:'YNetwork* FirstNetwork()',cmt:'<p>Starts the enumeration of network interfaces currently accessible. Use the method <tt>YNetwork.nextNetwork()</tt> to iterate on next network interfaces.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to the first network interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Network']['callbackLogin']={syn:'Connects to the notification callback and saves the credentials required to log into it.',lib:'network&rarr;callbackLogin()',pro:'int callbackLogin(string <span id=pn>username</span>, string <span id=pn>password</span>)',cmt:'<p>Connects to the notification callback and saves the credentials required to log into it. The password is not stored into the module, only a hashed copy of the credentials are saved. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{username:'username required to log to the callback',password:'password required to log to the callback'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['clearCache']={syn:'Invalidates the cache.',lib:'network&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the network interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Network']['describe']={syn:'Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the network interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the network interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.',lib:'network&rarr;get_adminPassword()',pro:'string get_adminPassword()',cmt:'<p>Returns a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for user \x22admin\x22, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Returns the current value of the network interface (no more than 6 characters).',lib:'network&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the network interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the network interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.',lib:'network&rarr;get_callbackCredentials()',pro:'string get_callbackCredentials()',cmt:'<p>Returns a hashed version of the notification callback credentials if set, or an empty string otherwise.</p>',ret:'a string corresponding to a hashed version of the notification callback credentials if set, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Returns the encoding standard to use for representing notification values.',lib:'network&rarr;get_callbackEncoding()',pro:'Y_CALLBACKENCODING_enum get_callbackEncoding()',cmt:'<p>Returns the encoding standard to use for representing notification values.</p>',ret:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt>, <tt>Y_CALLBACKENCODING_INFLUXDB</tt>, <tt>Y_CALLBACKENCODING_MQTT</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API_JZON</tt> corresponding to the encoding standard to use for representing notification values',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackInitialDelay']={syn:'Returns the initial waiting time before first callback notifications, in seconds.',lib:'network&rarr;get_callbackInitialDelay()',pro:'int get_callbackInitialDelay()',cmt:'<p>Returns the initial waiting time before first callback notifications, in seconds.</p>',ret:'an integer corresponding to the initial waiting time before first callback notifications, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKINITIALDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Returns the waiting time between two HTTP callbacks when there is nothing new.',lib:'network&rarr;get_callbackMaxDelay()',pro:'int get_callbackMaxDelay()',cmt:'<p>Returns the waiting time between two HTTP callbacks when there is nothing new.</p>',ret:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Returns the HTTP method used to notify callbacks for significant state changes.',lib:'network&rarr;get_callbackMethod()',pro:'Y_CALLBACKMETHOD_enum get_callbackMethod()',cmt:'<p>Returns the HTTP method used to notify callbacks for significant state changes.</p>',ret:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Returns the minimum waiting time between two HTTP callbacks, in seconds.',lib:'network&rarr;get_callbackMinDelay()',pro:'int get_callbackMinDelay()',cmt:'<p>Returns the minimum waiting time between two HTTP callbacks, in seconds.</p>',ret:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackSchedule']={syn:'Returns the HTTP callback schedule strategy, as a text string.',lib:'network&rarr;get_callbackSchedule()',pro:'string get_callbackSchedule()',cmt:'<p>Returns the HTTP callback schedule strategy, as a text string.</p>',ret:'a string corresponding to the HTTP callback schedule strategy, as a text string',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKSCHEDULE_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Returns the callback URL to notify of significant state changes.',lib:'network&rarr;get_callbackUrl()',pro:'string get_callbackUrl()',cmt:'<p>Returns the callback URL to notify of significant state changes.</p>',ret:'a string corresponding to the callback URL to notify of significant state changes',ext:'On failure, throws an exception or returns <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_defaultPage']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'network&rarr;get_defaultPage()',pro:'string get_defaultPage()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'a string corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>Y_DEFAULTPAGE_INVALID</tt>.'};
doc['Network']['get_discoverable']={syn:'Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network&rarr;get_discoverable()',pro:'Y_DISCOVERABLE_enum get_discoverable()',cmt:'<p>Returns the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',ret:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)',ext:'On failure, throws an exception or returns <tt>Y_DISCOVERABLE_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Returns the error message of the latest error with the network interface.',lib:'network&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the network interface object'};
doc['Network']['get_errorType']={syn:'Returns the numerical error code of the latest error with the network interface.',lib:'network&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the network interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the network interface object'};
doc['Network']['get_friendlyName']={syn:'Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'network&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the network interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the network interface if they are defined, otherwise the serial number of the module and the hardware identifier of the network interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the network interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'network&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Network']['get_functionId']={syn:'Returns the hardware identifier of the network interface, without reference to the module.',lib:'network&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the network interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the network interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'network&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the network interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the network interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the network interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_httpPort']={syn:'Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.',lib:'network&rarr;get_httpPort()',pro:'int get_httpPort()',cmt:'<p>Returns the HTML page to serve for the URL \x22/\x22\x22 of the hub.</p>',ret:'an integer corresponding to the HTML page to serve for the URL \x22/\x22\x22 of the hub',ext:'On failure, throws an exception or returns <tt>Y_HTTPPORT_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Returns the IP address currently in use by the device.',lib:'network&rarr;get_ipAddress()',pro:'string get_ipAddress()',cmt:'<p>Returns the IP address currently in use by the device. The address may have been configured statically, or provided by a DHCP server.</p>',ret:'a string corresponding to the IP address currently in use by the device',ext:'On failure, throws an exception or returns <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_ipConfig']={syn:'Returns the IP configuration of the network interface.',lib:'network&rarr;get_ipConfig()',pro:'string get_ipConfig()',cmt:'<p>Returns the IP configuration of the network interface.</p><p> If the network interface is setup to use a static IP address, the string starts with \x22STATIC:\x22 and is followed by three parameters, separated by \x22/\x22. The first is the device IP address, followed by the subnet mask length, and finally the router IP address (default gateway). For instance: \x22STATIC:192.168.1.14/16/192.168.1.1\x22</p><p> If the network interface is configured to receive its IP from a DHCP server, the string start with \x22DHCP:\x22 and is followed by three parameters separated by \x22/\x22. The first is the fallback IP address, then the fallback subnet mask length and finally the fallback router IP address. These three parameters are used when no DHCP reply is received.</p>',ret:'a string corresponding to the IP configuration of the network interface',ext:'On failure, throws an exception or returns <tt>Y_IPCONFIG_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Returns the logical name of the network interface.',lib:'network&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the network interface.</p>',ret:'a string corresponding to the logical name of the network interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Returns the MAC address of the network interface.',lib:'network&rarr;get_macAddress()',pro:'string get_macAddress()',cmt:'<p>Returns the MAC address of the network interface. The MAC address is also available on a sticker on the module, in both numeric and barcode forms.</p>',ret:'a string corresponding to the MAC address of the network interface',ext:'On failure, throws an exception or returns <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'network&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Network']['get_ntpServer']={syn:'Returns the IP address of the NTP server to be used by the device.',lib:'network&rarr;get_ntpServer()',pro:'string get_ntpServer()',cmt:'<p>Returns the IP address of the NTP server to be used by the device.</p>',ret:'a string corresponding to the IP address of the NTP server to be used by the device',ext:'On failure, throws an exception or returns <tt>Y_NTPSERVER_INVALID</tt>.'};
doc['Network']['get_poeCurrent']={syn:'Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps.',lib:'network&rarr;get_poeCurrent()',pro:'int get_poeCurrent()',cmt:'<p>Returns the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps. The current consumption is measured after converting PoE source to 5 Volt, and should never exceed 1800 mA.</p>',ret:'an integer corresponding to the current consumed by the module from Power-over-Ethernet (PoE), in milli-amps',ext:'On failure, throws an exception or returns <tt>Y_POECURRENT_INVALID</tt>.'};
doc['Network']['get_primaryDNS']={syn:'Returns the IP address of the primary name server to be used by the module.',lib:'network&rarr;get_primaryDNS()',pro:'string get_primaryDNS()',cmt:'<p>Returns the IP address of the primary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the primary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Returns the current established working mode of the network interface.',lib:'network&rarr;get_readiness()',pro:'Y_READINESS_enum get_readiness()',cmt:'<p>Returns the current established working mode of the network interface. Level zero (DOWN_0) means that no hardware link has been detected. Either there is no signal on the network cable, or the selected wireless access point cannot be detected. Level 1 (LIVE_1) is reached when the network is detected, but is not yet connected. For a wireless network, this shows that the requested SSID is present. Level 2 (LINK_2) is reached when the hardware connection is established. For a wired network connection, level 2 means that the cable is attached at both ends. For a connection to a wireless access point, it shows that the security parameters are properly configured. For an ad-hoc wireless connection, it means that there is at least one other device connected on the ad-hoc network. Level 3 (DHCP_3) is reached when an IP address has been obtained using DHCP. Level 4 (DNS_4) is reached when the DNS server is reachable on the network. Level 5 (WWW_5) is reached when global connectivity is demonstrated by properly loading the current time from an NTP server.</p>',ret:'a value among <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> and <tt>Y_READINESS_WWW_OK</tt> corresponding to the current established working mode of the network interface',ext:'On failure, throws an exception or returns <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Returns the IP address of the router on the device subnet (default gateway).',lib:'network&rarr;get_router()',pro:'string get_router()',cmt:'<p>Returns the IP address of the router on the device subnet (default gateway).</p>',ret:'a string corresponding to the IP address of the router on the device subnet (default gateway)',ext:'On failure, throws an exception or returns <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Returns the IP address of the secondary name server to be used by the module.',lib:'network&rarr;get_secondaryDNS()',pro:'string get_secondaryDNS()',cmt:'<p>Returns the IP address of the secondary name server to be used by the module.</p>',ret:'a string corresponding to the IP address of the secondary name server to be used by the module',ext:'On failure, throws an exception or returns <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Returns the subnet mask currently used by the device.',lib:'network&rarr;get_subnetMask()',pro:'string get_subnetMask()',cmt:'<p>Returns the subnet mask currently used by the device.</p>',ret:'a string corresponding to the subnet mask currently used by the device',ext:'On failure, throws an exception or returns <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'network&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Network']['get_userPassword']={syn:'Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.',lib:'network&rarr;get_userPassword()',pro:'string get_userPassword()',cmt:'<p>Returns a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise.</p>',ret:'a string corresponding to a hash string if a password has been set for \x22user\x22 user, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['get_wwwWatchdogDelay']={syn:'Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network&rarr;get_wwwWatchdogDelay()',pro:'int get_wwwWatchdogDelay()',cmt:'<p>Returns the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss.</p>',ret:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity',ext:'On failure, throws an exception or returns <tt>Y_WWWWATCHDOGDELAY_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'Checks if the network interface is currently reachable, without raising any error.',lib:'network&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the network interface is currently reachable, without raising any error. If there is a cached value for the network interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the network interface.</p>',ret:'<tt>true</tt> if the network interface can be reached, and <tt>false</tt> otherwise'};
doc['Network']['load']={syn:'Preloads the network interface cache with a specified validity duration.',lib:'network&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the network interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'network&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Network']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'network&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['nextNetwork']={syn:'Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.',lib:'network&rarr;nextNetwork()',pro:'YNetwork * nextNetwork()',cmt:'<p>Continues the enumeration of network interfaces started using <tt>yFirstNetwork()</tt>.</p>',ret:'a pointer to a <tt>YNetwork</tt> object, corresponding to a network interface currently online, or a <tt>null</tt> pointer if there are no more network interfaces to enumerate.'};
doc['Network']['ping']={syn:'Pings host to test the network connectivity.',lib:'network&rarr;ping()',pro:'string ping(string <span id=pn>host</span>)',cmt:'<p>Pings host to test the network connectivity. Sends four ICMP ECHO_REQUEST requests from the module to the target host. This method returns a string with the result of the 4 ICMP ECHO_REQUEST requests.</p>',par:{host:'the hostname or the IP address of the target'},ret:'a string with the result of the ping.'};
doc['Network']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'network&rarr;registerValueCallback()',pro:'int registerValueCallback(YNetworkValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Network']['set_adminPassword']={syn:'Changes the password for the \x22admin\x22 user.',lib:'network&rarr;set_adminPassword()',pro:'int set_adminPassword(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22admin\x22 user. This password becomes instantly required to perform any change of the module state. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22admin\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackCredentials']={syn:'Changes the credentials required to connect to the callback address.',lib:'network&rarr;set_callbackCredentials()',pro:'int set_callbackCredentials(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the credentials required to connect to the callback address. The credentials must be provided as returned by function <tt>get_callbackCredentials</tt>, in the form <tt>username:hash</tt>. The method used to compute the hash varies according to the the authentication scheme implemented by the callback, For Basic authentication, the hash is the MD5 of the string <tt>username:password</tt>. For Digest authentication, the hash is the MD5 of the string <tt>username:realm:password</tt>. For a simpler way to configure callback credentials, use function <tt>callbackLogin</tt> instead. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the credentials required to connect to the callback address'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackEncoding']={syn:'Changes the encoding standard to use for representing notification values.',lib:'network&rarr;set_callbackEncoding()',pro:'int set_callbackEncoding(Y_CALLBACKENCODING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the encoding standard to use for representing notification values.</p>',par:{newval:'a value among <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt>, <tt>Y_CALLBACKENCODING_YOCTO_API</tt>, <tt>Y_CALLBACKENCODING_JSON_NUM</tt>, <tt>Y_CALLBACKENCODING_EMONCMS</tt>, <tt>Y_CALLBACKENCODING_AZURE</tt>, <tt>Y_CALLBACKENCODING_INFLUXDB</tt>, <tt>Y_CALLBACKENCODING_MQTT</tt> and <tt>Y_CALLBACKENCODING_YOCTO_API_JZON</tt> corresponding to the encoding standard to use for representing notification values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackInitialDelay']={syn:'Changes the initial waiting time before first callback notifications, in seconds.',lib:'network&rarr;set_callbackInitialDelay()',pro:'int set_callbackInitialDelay(int <span id=pn>newval</span>)',cmt:'<p>Changes the initial waiting time before first callback notifications, in seconds.</p>',par:{newval:'an integer corresponding to the initial waiting time before first callback notifications, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMaxDelay']={syn:'Changes the waiting time between two HTTP callbacks when there is nothing new.',lib:'network&rarr;set_callbackMaxDelay()',pro:'int set_callbackMaxDelay(int <span id=pn>newval</span>)',cmt:'<p>Changes the waiting time between two HTTP callbacks when there is nothing new.</p>',par:{newval:'an integer corresponding to the waiting time between two HTTP callbacks when there is nothing new'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMethod']={syn:'Changes the HTTP method used to notify callbacks for significant state changes.',lib:'network&rarr;set_callbackMethod()',pro:'int set_callbackMethod(Y_CALLBACKMETHOD_enum <span id=pn>newval</span>)',cmt:'<p>Changes the HTTP method used to notify callbacks for significant state changes.</p>',par:{newval:'a value among <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> and <tt>Y_CALLBACKMETHOD_PUT</tt> corresponding to the HTTP method used to notify callbacks for significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackMinDelay']={syn:'Changes the minimum waiting time between two HTTP callbacks, in seconds.',lib:'network&rarr;set_callbackMinDelay()',pro:'int set_callbackMinDelay(int <span id=pn>newval</span>)',cmt:'<p>Changes the minimum waiting time between two HTTP callbacks, in seconds.</p>',par:{newval:'an integer corresponding to the minimum waiting time between two HTTP callbacks, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackSchedule']={syn:'Changes the HTTP callback schedule strategy, as a text string.',lib:'network&rarr;set_callbackSchedule()',pro:'int set_callbackSchedule(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the HTTP callback schedule strategy, as a text string.</p>',par:{newval:'a string corresponding to the HTTP callback schedule strategy, as a text string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_callbackUrl']={syn:'Changes the callback URL to notify significant state changes.',lib:'network&rarr;set_callbackUrl()',pro:'int set_callbackUrl(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the callback URL to notify significant state changes. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the callback URL to notify significant state changes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_defaultPage']={syn:'Changes the default HTML page returned by the hub.',lib:'network&rarr;set_defaultPage()',pro:'int set_defaultPage(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible de change this page for file that has been uploaded on the hub.</p>',par:{newval:'a string corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_discoverable']={syn:'Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).',lib:'network&rarr;set_discoverable()',pro:'int set_discoverable(Y_DISCOVERABLE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol).</p>',par:{newval:'either <tt>Y_DISCOVERABLE_FALSE</tt> or <tt>Y_DISCOVERABLE_TRUE</tt>, according to the activation state of the multicast announce protocols to allow easy discovery of the module in the network neighborhood (uPnP/Bonjour protocol)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_httpPort']={syn:'Changes the default HTML page returned by the hub.',lib:'network&rarr;set_httpPort()',pro:'int set_httpPort(int <span id=pn>newval</span>)',cmt:'<p>Changes the default HTML page returned by the hub. If not value are set the hub return \x22index.html\x22 which is the web interface of the hub. It is possible de change this page for file that has been uploaded on the hub.</p>',par:{newval:'an integer corresponding to the default HTML page returned by the hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_logicalName']={syn:'Changes the logical name of the network interface.',lib:'network&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the network interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the network interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_ntpServer']={syn:'Changes the IP address of the NTP server to be used by the module.',lib:'network&rarr;set_ntpServer()',pro:'int set_ntpServer(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the NTP server to be used by the module. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the NTP server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_periodicCallbackSchedule']={syn:'Setup periodic HTTP callbacks (simplifed function).',lib:'network&rarr;set_periodicCallbackSchedule()',pro:'int set_periodicCallbackSchedule(string <span id=pn>interval</span>, int <span id=pn>offset</span>)',cmt:'<p>Setup periodic HTTP callbacks (simplifed function).</p>',par:{interval:'a string representing the callback periodicity, expressed in seconds, minutes or hours, eg. \x2260s\x22, \x225m\x22, \x221h\x22, \x2248h\x22.',offset:'an integer representing the time offset relative to the period when the callback should occur. For instance, if the periodicity is 24h, an offset of 7 will make the callback occur each day at 7AM.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_primaryDNS']={syn:'Changes the IP address of the primary name server to be used by the module.',lib:'network&rarr;set_primaryDNS()',pro:'int set_primaryDNS(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the primary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the primary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_secondaryDNS']={syn:'Changes the IP address of the secondary name server to be used by the module.',lib:'network&rarr;set_secondaryDNS()',pro:'int set_secondaryDNS(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the IP address of the secondary name server to be used by the module. When using DHCP, if a value is specified, it overrides the value received from the DHCP server. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'a string corresponding to the IP address of the secondary name server to be used by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'network&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Network']['set_userPassword']={syn:'Changes the password for the \x22user\x22 user.',lib:'network&rarr;set_userPassword()',pro:'int set_userPassword(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the password for the \x22user\x22 user. This password becomes instantly required to perform any use of the module. If the specified value is an empty string, a password is not required anymore. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the password for the \x22user\x22 user'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['set_wwwWatchdogDelay']={syn:'Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity.',lib:'network&rarr;set_wwwWatchdogDelay()',pro:'int set_wwwWatchdogDelay(int <span id=pn>newval</span>)',cmt:'<p>Changes the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity. A zero value disables automated reboot in case of Internet connectivity loss. The smallest valid non-zero timeout is 90 seconds.</p>',par:{newval:'an integer corresponding to the allowed downtime of the WWW link (in seconds) before triggering an automated reboot to try to recover Internet connectivity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['triggerCallback']={syn:'Trigger an HTTP callback quickly.',lib:'network&rarr;triggerCallback()',pro:'int triggerCallback()',cmt:'<p>Trigger an HTTP callback quickly. This function can even be called within an HTTP callback, in which case the next callback will be triggered 5 seconds after the end of the current callback, regardless if the minimum time between callbacks configured in the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'network&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCP']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network&rarr;useDHCP()',pro:'int useDHCP(string <span id=pn>fallbackIpAddr</span>,&nbsp;int <span id=pn>fallbackSubnetMaskLen</span>,&nbsp;string <span id=pn>fallbackRouter</span>)',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses the IP parameters specified to this function. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{fallbackIpAddr:'fallback IP address, to be used when no DHCP reply is received',fallbackSubnetMaskLen:'fallback subnet mask length when no DHCP reply is received, as an integer (eg. 24 means 255.255.255.0)',fallbackRouter:'fallback router IP address, to be used when no DHCP reply is received'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useDHCPauto']={syn:'Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server.',lib:'network&rarr;useDHCPauto()',pro:'int useDHCPauto()',cmt:'<p>Changes the configuration of the network interface to enable the use of an IP address received from a DHCP server. Until an address is received from a DHCP server, the module uses an IP of the network 169.254.0.0/16 (APIPA). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Network']['useStaticIP']={syn:'Changes the configuration of the network interface to use a static IP address.',lib:'network&rarr;useStaticIP()',pro:'int useStaticIP(string <span id=pn>ipAddress</span>, int <span id=pn>subnetMaskLen</span>, string <span id=pn>router</span>)',cmt:'<p>Changes the configuration of the network interface to use a static IP address. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ipAddress:'device IP address',subnetMaskLen:'subnet mask length, as an integer (eg. 24 means 255.255.255.0)',router:'router IP address (default gateway)'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Wireless function interface',inc:'#include &quot;yocto_wireless.h&quot;',cmt:'<p>YWireless functions provides control over wireless network parameters and status for devices that are wireless-enabled.</p>'}};
doc['Wireless']['FindWireless']={syn:'Retrieves a wireless lan interface for a given identifier.',lib:'YWireless::FindWireless()',pro:'YWireless* FindWireless(string <span id=pn>func</span>)',cmt:'<p>Retrieves a wireless lan interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wireless lan interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWireless.isOnline()</tt> to test if the wireless lan interface is indeed online at a given time. In case of ambiguity when looking for a wireless lan interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wireless lan interface'},ret:'a <tt>YWireless</tt> object allowing you to drive the wireless lan interface.'};
doc['Wireless']['FirstWireless']={syn:'Starts the enumeration of wireless lan interfaces currently accessible.',lib:'YWireless::FirstWireless()',pro:'YWireless* FirstWireless()',cmt:'<p>Starts the enumeration of wireless lan interfaces currently accessible. Use the method <tt>YWireless.nextWireless()</tt> to iterate on next wireless lan interfaces.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to the first wireless lan interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Wireless']['adhocNetwork']={syn:'Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point.',lib:'wireless&rarr;adhocNetwork()',pro:'int adhocNetwork(string <span id=pn>ssid</span>, string <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create an ad-hoc wireless network, without using an access point. On the YoctoHub-Wireless-g, it is best to use softAPNetworkInstead(), which emulates an access point (Soft AP) which is more efficient and more widely supported than ad-hoc networks.</p><p> When a security key is specified for an ad-hoc network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['clearCache']={syn:'Invalidates the cache.',lib:'wireless&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wireless lan interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Wireless']['describe']={syn:'Returns a short text that describes unambiguously the instance of the wireless lan interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wireless lan interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wireless lan interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Wireless']['get_advertisedValue']={syn:'Returns the current value of the wireless lan interface (no more than 6 characters).',lib:'wireless&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the wireless lan interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wireless lan interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Returns the 802.11 channel currently used, or 0 when the selected network has not been found.',lib:'wireless&rarr;get_channel()',pro:'int get_channel()',cmt:'<p>Returns the 802.11 channel currently used, or 0 when the selected network has not been found.</p>',ret:'an integer corresponding to the 802.11 channel currently used, or 0 when the selected network has not been found',ext:'On failure, throws an exception or returns <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_detectedWlans']={syn:'Returns a list of YWlanRecord objects that describe detected Wireless networks.',lib:'wireless&rarr;get_detectedWlans()',pro:'vector&lt;YWlanRecord&gt; get_detectedWlans()',cmt:'<p>Returns a list of YWlanRecord objects that describe detected Wireless networks. This list is not updated when the module is already connected to an acces point (infrastructure mode). To force an update of this list, <tt>startWlanScan()</tt> must be called. Note that an languages without garbage collections, the returned list must be freed by the caller.</p>',ret:'a list of <tt>YWlanRecord</tt> objects, containing the SSID, channel, link quality and the type of security of the wireless network.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Wireless']['get_errorMessage']={syn:'Returns the error message of the latest error with the wireless lan interface.',lib:'wireless&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wireless lan interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wireless lan interface object'};
doc['Wireless']['get_errorType']={syn:'Returns the numerical error code of the latest error with the wireless lan interface.',lib:'wireless&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wireless lan interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wireless lan interface object'};
doc['Wireless']['get_friendlyName']={syn:'Returns a global identifier of the wireless lan interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wireless&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the wireless lan interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wireless lan interface if they are defined, otherwise the serial number of the module and the hardware identifier of the wireless lan interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wireless lan interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Wireless']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wireless&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Wireless']['get_functionId']={syn:'Returns the hardware identifier of the wireless lan interface, without reference to the module.',lib:'wireless&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the wireless lan interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wireless lan interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Wireless']['get_hardwareId']={syn:'Returns the unique hardware identifier of the wireless lan interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wireless&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wireless lan interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wireless lan interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wireless lan interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'wireless&rarr;get_linkQuality()',pro:'int get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Returns the logical name of the wireless lan interface.',lib:'wireless&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the wireless lan interface.</p>',ret:'a string corresponding to the logical name of the wireless lan interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'wireless&rarr;get_message()',pro:'string get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wireless&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Returns the security algorithm used by the selected wireless network.',lib:'wireless&rarr;get_security()',pro:'Y_SECURITY_enum get_security()',cmt:'<p>Returns the security algorithm used by the selected wireless network.</p>',ret:'a value among <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> and <tt>Y_SECURITY_WPA2</tt> corresponding to the security algorithm used by the selected wireless network',ext:'On failure, throws an exception or returns <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Returns the wireless network name (SSID).',lib:'wireless&rarr;get_ssid()',pro:'string get_ssid()',cmt:'<p>Returns the wireless network name (SSID).</p>',ret:'a string corresponding to the wireless network name (SSID)',ext:'On failure, throws an exception or returns <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wireless&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Wireless']['get_wlanState']={syn:'Returns the current state of the wireless interface.',lib:'wireless&rarr;get_wlanState()',pro:'Y_WLANSTATE_enum get_wlanState()',cmt:'<p>Returns the current state of the wireless interface. The state <tt>Y_WLANSTATE_DOWN</tt> means that the network interface is not connected to a network. The state <tt>Y_WLANSTATE_SCANNING</tt> means that the network interface is scanning available frequencies. During this stage, the device is not reachable, and the network settings are not yet applied. The state <tt>Y_WLANSTATE_CONNECTED</tt> means that the network settings have been successfully applied ant that the device is reachable from the wireless network. If the device is configured to use ad-hoc or Soft AP mode, it means that the wireless network is up and that other devices can join the network. The state <tt>Y_WLANSTATE_REJECTED</tt> means that the network interface has not been able to join the requested network. The description of the error can be obtain with the <tt>get_message()</tt> method.</p>',ret:'a value among <tt>Y_WLANSTATE_DOWN</tt>, <tt>Y_WLANSTATE_SCANNING</tt>, <tt>Y_WLANSTATE_CONNECTED</tt> and <tt>Y_WLANSTATE_REJECTED</tt> corresponding to the current state of the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_WLANSTATE_INVALID</tt>.'};
doc['Wireless']['isOnline']={syn:'Checks if the wireless lan interface is currently reachable, without raising any error.',lib:'wireless&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the wireless lan interface is currently reachable, without raising any error. If there is a cached value for the wireless lan interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wireless lan interface.</p>',ret:'<tt>true</tt> if the wireless lan interface can be reached, and <tt>false</tt> otherwise'};
doc['Wireless']['joinNetwork']={syn:'Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode).',lib:'wireless&rarr;joinNetwork()',pro:'int joinNetwork(string <span id=pn>ssid</span>, string <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to connect to an existing access point (infrastructure mode). Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['load']={syn:'Preloads the wireless lan interface cache with a specified validity duration.',lib:'wireless&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the wireless lan interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'wireless&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Wireless']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'wireless&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['nextWireless']={syn:'Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.',lib:'wireless&rarr;nextWireless()',pro:'YWireless * nextWireless()',cmt:'<p>Continues the enumeration of wireless lan interfaces started using <tt>yFirstWireless()</tt>.</p>',ret:'a pointer to a <tt>YWireless</tt> object, corresponding to a wireless lan interface currently online, or a <tt>null</tt> pointer if there are no more wireless lan interfaces to enumerate.'};
doc['Wireless']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wireless&rarr;registerValueCallback()',pro:'int registerValueCallback(YWirelessValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Wireless']['set_logicalName']={syn:'Changes the logical name of the wireless lan interface.',lib:'wireless&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wireless lan interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wireless lan interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wireless&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Wireless']['softAPNetwork']={syn:'Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP).',lib:'wireless&rarr;softAPNetwork()',pro:'int softAPNetwork(string <span id=pn>ssid</span>, string <span id=pn>securityKey</span>)',cmt:'<p>Changes the configuration of the wireless lan interface to create a new wireless network by emulating a WiFi access point (Soft AP). This function can only be used with the YoctoHub-Wireless-g.</p><p> When a security key is specified for a SoftAP network, the network is protected by a WEP40 key (5 characters or 10 hexadecimal digits) or WEP128 key (13 characters or 26 hexadecimal digits). It is recommended to use a well-randomized WEP128 key using 26 hexadecimal digits to maximize security. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{ssid:'the name of the network to connect to',securityKey:'the network key, as a character string'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Wireless']['startWlanScan']={syn:'Triggers a scan of the wireless frequency and builds the list of available networks.',lib:'wireless&rarr;startWlanScan()',pro:'int startWlanScan()',cmt:'<p>Triggers a scan of the wireless frequency and builds the list of available networks. The scan forces a disconnection from the current network. At then end of the process, the the network interface attempts to reconnect to the previous network. During the scan, the <tt>wlanState</tt> switches to <tt>Y_WLANSTATE_DOWN</tt>, then to <tt>Y_WLANSTATE_SCANNING</tt>. When the scan is completed, <tt>get_wlanState()</tt> returns either <tt>Y_WLANSTATE_DOWN</tt> or <tt>Y_WLANSTATE_SCANNING</tt>. At this point, the list of detected network can be retrieved with the <tt>get_detectedWlans()</tt> method.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['Wireless']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'wireless&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Wireless)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Voc function interface',inc:'#include &quot;yocto_voc.h&quot;',cmt:'<p>The Yoctopuce class YVoc allows you to read and configure Yoctopuce Volatile Organic Compound sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Voc']['FindVoc']={syn:'Retrieves a Volatile Organic Compound sensor for a given identifier.',lib:'YVoc::FindVoc()',pro:'YVoc* FindVoc(string <span id=pn>func</span>)',cmt:'<p>Retrieves a Volatile Organic Compound sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the Volatile Organic Compound sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoc.isOnline()</tt> to test if the Volatile Organic Compound sensor is indeed online at a given time. In case of ambiguity when looking for a Volatile Organic Compound sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the Volatile Organic Compound sensor'},ret:'a <tt>YVoc</tt> object allowing you to drive the Volatile Organic Compound sensor.'};
doc['Voc']['FirstVoc']={syn:'Starts the enumeration of Volatile Organic Compound sensors currently accessible.',lib:'YVoc::FirstVoc()',pro:'YVoc* FirstVoc()',cmt:'<p>Starts the enumeration of Volatile Organic Compound sensors currently accessible. Use the method <tt>YVoc.nextVoc()</tt> to iterate on next Volatile Organic Compound sensors.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to the first Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Voc']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'voc&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['clearCache']={syn:'Invalidates the cache.',lib:'voc&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the Volatile Organic Compound sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Voc']['describe']={syn:'Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voc&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the Volatile Organic Compound sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the Volatile Organic Compound sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voc']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'voc&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Voc']['get_advertisedValue']={syn:'Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).',lib:'voc&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the Volatile Organic Compound sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the Volatile Organic Compound sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.',lib:'voc&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.',lib:'voc&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the estimated VOC concentration, in ppm (vol), as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the estimated VOC concentration, in ppm (vol), as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'voc&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Voc']['get_errorMessage']={syn:'Returns the error message of the latest error with the Volatile Organic Compound sensor.',lib:'voc&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the Volatile Organic Compound sensor object'};
doc['Voc']['get_errorType']={syn:'Returns the numerical error code of the latest error with the Volatile Organic Compound sensor.',lib:'voc&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the Volatile Organic Compound sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the Volatile Organic Compound sensor object'};
doc['Voc']['get_friendlyName']={syn:'Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voc&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the Volatile Organic Compound sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the Volatile Organic Compound sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the Volatile Organic Compound sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voc']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voc&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Voc']['get_functionId']={syn:'Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module.',lib:'voc&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the Volatile Organic Compound sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the Volatile Organic Compound sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voc']['get_hardwareId']={syn:'Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voc&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the Volatile Organic Compound sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the Volatile Organic Compound sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the Volatile Organic Compound sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Returns the maximal value observed for the estimated VOC concentration since the device was started.',lib:'voc&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'voc&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Returns the logical name of the Volatile Organic Compound sensor.',lib:'voc&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the Volatile Organic Compound sensor.</p>',ret:'a string corresponding to the logical name of the Volatile Organic Compound sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Returns the minimal value observed for the estimated VOC concentration since the device was started.',lib:'voc&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the estimated VOC concentration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the estimated VOC concentration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voc&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Voc']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'voc&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Voc']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'voc&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Voc']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'voc&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'voc&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Returns the measuring unit for the estimated VOC concentration.',lib:'voc&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the estimated VOC concentration.</p>',ret:'a string corresponding to the measuring unit for the estimated VOC concentration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voc&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Voc']['isOnline']={syn:'Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error.',lib:'voc&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the Volatile Organic Compound sensor is currently reachable, without raising any error. If there is a cached value for the Volatile Organic Compound sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the Volatile Organic Compound sensor.</p>',ret:'<tt>true</tt> if the Volatile Organic Compound sensor can be reached, and <tt>false</tt> otherwise'};
doc['Voc']['load']={syn:'Preloads the Volatile Organic Compound sensor cache with a specified validity duration.',lib:'voc&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the Volatile Organic Compound sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'voc&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Voc']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'voc&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'voc&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['nextVoc']={syn:'Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.',lib:'voc&rarr;nextVoc()',pro:'YVoc * nextVoc()',cmt:'<p>Continues the enumeration of Volatile Organic Compound sensors started using <tt>yFirstVoc()</tt>.</p>',ret:'a pointer to a <tt>YVoc</tt> object, corresponding to a Volatile Organic Compound sensor currently online, or a <tt>null</tt> pointer if there are no more Volatile Organic Compound sensors to enumerate.'};
doc['Voc']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'voc&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YVocTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Voc']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voc&rarr;registerValueCallback()',pro:'int registerValueCallback(YVocValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Voc']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'voc&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'voc&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'voc&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_logicalName']={syn:'Changes the logical name of the Volatile Organic Compound sensor.',lib:'voc&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the Volatile Organic Compound sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the Volatile Organic Compound sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'voc&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'voc&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'voc&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Voc']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voc&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Voc']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'voc&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voc']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'voc&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Voc']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'voc&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Watchdog function interface',inc:'#include &quot;yocto_watchdog.h&quot;',cmt:'<p>The watchog function works like a relay and can cause a brief power cut to an appliance after a preset delay to force this appliance to reset. The Watchdog must be called from time to time to reset the timer and prevent the appliance reset. The watchdog can be driven direcly with <i>pulse</i> and <i>delayedpulse</i> methods to switch off an appliance for a given duration.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Retrieves a watchdog for a given identifier.',lib:'YWatchdog::FindWatchdog()',pro:'YWatchdog* FindWatchdog(string <span id=pn>func</span>)',cmt:'<p>Retrieves a watchdog for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the watchdog is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWatchdog.isOnline()</tt> to test if the watchdog is indeed online at a given time. In case of ambiguity when looking for a watchdog by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the watchdog'},ret:'a <tt>YWatchdog</tt> object allowing you to drive the watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Starts the enumeration of watchdog currently accessible.',lib:'YWatchdog::FirstWatchdog()',pro:'YWatchdog* FirstWatchdog()',cmt:'<p>Starts the enumeration of watchdog currently accessible. Use the method <tt>YWatchdog.nextWatchdog()</tt> to iterate on next watchdog.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to the first watchdog currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Watchdog']['clearCache']={syn:'Invalidates the cache.',lib:'watchdog&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the watchdog attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Watchdog']['delayedPulse']={syn:'Schedules a pulse.',lib:'watchdog&rarr;delayedPulse()',pro:'int delayedPulse(int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse.</p>',par:{ms_delay:'waiting time before the pulse, in millisecondes',ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['describe']={syn:'Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the watchdog in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the watchdog (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Watchdog']['get_advertisedValue']={syn:'Returns the current value of the watchdog (no more than 6 characters).',lib:'watchdog&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the watchdog (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the watchdog (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Returns the watchdog runing state at module power on.',lib:'watchdog&rarr;get_autoStart()',pro:'Y_AUTOSTART_enum get_autoStart()',cmt:'<p>Returns the watchdog runing state at module power on.</p>',ret:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runing state at module power on',ext:'On failure, throws an exception or returns <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.',lib:'watchdog&rarr;get_countdown()',pro:'s64 get_countdown()',cmt:'<p>Returns the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before a pulse (delayedPulse() call) When there is no scheduled pulse, returns zero',ext:'On failure, throws an exception or returns <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Returns the error message of the latest error with the watchdog.',lib:'watchdog&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the watchdog object'};
doc['Watchdog']['get_errorType']={syn:'Returns the numerical error code of the latest error with the watchdog.',lib:'watchdog&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the watchdog. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the watchdog object'};
doc['Watchdog']['get_friendlyName']={syn:'Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'watchdog&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the watchdog in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the watchdog if they are defined, otherwise the serial number of the module and the hardware identifier of the watchdog (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the watchdog using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Watchdog']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'watchdog&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Watchdog']['get_functionId']={syn:'Returns the hardware identifier of the watchdog, without reference to the module.',lib:'watchdog&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the watchdog, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the watchdog (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Watchdog']['get_hardwareId']={syn:'Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'watchdog&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the watchdog in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the watchdog (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the watchdog (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Returns the logical name of the watchdog.',lib:'watchdog&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the watchdog.</p>',ret:'a string corresponding to the logical name of the watchdog.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateA']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'watchdog&rarr;get_maxTimeOnStateA()',pro:'s64 get_maxTimeOnStateA()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEA_INVALID</tt>.'};
doc['Watchdog']['get_maxTimeOnStateB']={syn:'Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'watchdog&rarr;get_maxTimeOnStateB()',pro:'s64 get_maxTimeOnStateB()',cmt:'<p>Retourne the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Zero means no maximum time.</p>',ret:'an integer',ext:'On failure, throws an exception or returns <tt>Y_MAXTIMEONSTATEB_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'watchdog&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Returns the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog&rarr;get_output()',pro:'Y_OUTPUT_enum get_output()',cmt:'<p>Returns the output state of the watchdog, when used as a simple switch (single throw).</p>',ret:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)',ext:'On failure, throws an exception or returns <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation.',lib:'watchdog&rarr;get_pulseTimer()',pro:'s64 get_pulseTimer()',cmt:'<p>Returns the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation. When there is no ongoing pulse, returns zero.</p>',ret:'an integer corresponding to the number of milliseconds remaining before the watchdog is returned to idle position (state A), during a measured pulse generation',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Returns the watchdog running state.',lib:'watchdog&rarr;get_running()',pro:'Y_RUNNING_enum get_running()',cmt:'<p>Returns the watchdog running state.</p>',ret:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the watchdog running state',ext:'On failure, throws an exception or returns <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Returns the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog&rarr;get_state()',pro:'Y_STATE_enum get_state()',cmt:'<p>Returns the state of the watchdog (A for the idle position, B for the active position).</p>',ret:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)',ext:'On failure, throws an exception or returns <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_stateAtPowerOn']={syn:'Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).',lib:'watchdog&rarr;get_stateAtPowerOn()',pro:'Y_STATEATPOWERON_enum get_stateAtPowerOn()',cmt:'<p>Returns the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change).</p>',ret:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt> corresponding to the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no change)',ext:'On failure, throws an exception or returns <tt>Y_STATEATPOWERON_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.',lib:'watchdog&rarr;get_triggerDelay()',pro:'s64 get_triggerDelay()',cmt:'<p>Returns the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the waiting duration before a reset is automatically triggered by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Returns the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog&rarr;get_triggerDuration()',pro:'s64 get_triggerDuration()',cmt:'<p>Returns the duration of resets caused by the watchdog, in milliseconds.</p>',ret:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'watchdog&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Watchdog']['isOnline']={syn:'Checks if the watchdog is currently reachable, without raising any error.',lib:'watchdog&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the watchdog is currently reachable, without raising any error. If there is a cached value for the watchdog in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the watchdog.</p>',ret:'<tt>true</tt> if the watchdog can be reached, and <tt>false</tt> otherwise'};
doc['Watchdog']['load']={syn:'Preloads the watchdog cache with a specified validity duration.',lib:'watchdog&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the watchdog cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'watchdog&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Watchdog']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'watchdog&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['nextWatchdog']={syn:'Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.',lib:'watchdog&rarr;nextWatchdog()',pro:'YWatchdog * nextWatchdog()',cmt:'<p>Continues the enumeration of watchdog started using <tt>yFirstWatchdog()</tt>.</p>',ret:'a pointer to a <tt>YWatchdog</tt> object, corresponding to a watchdog currently online, or a <tt>null</tt> pointer if there are no more watchdog to enumerate.'};
doc['Watchdog']['pulse']={syn:'Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).',lib:'watchdog&rarr;pulse()',pro:'int pulse(int <span id=pn>ms_duration</span>)',cmt:'<p>Sets the relay to output B (active) for a specified duration, then brings it automatically back to output A (idle state).</p>',par:{ms_duration:'pulse duration, in millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'watchdog&rarr;registerValueCallback()',pro:'int registerValueCallback(YWatchdogValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Watchdog']['resetWatchdog']={syn:'Resets the watchdog.',lib:'watchdog&rarr;resetWatchdog()',pro:'int resetWatchdog()',cmt:'<p>Resets the watchdog. When the watchdog is running, this function must be called on a regular basis to prevent the watchog to trigger</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_autoStart']={syn:'Changes the watchdog runningsttae at module power on.',lib:'watchdog&rarr;set_autoStart()',pro:'int set_autoStart(Y_AUTOSTART_enum <span id=pn>newval</span>)',cmt:'<p>Changes the watchdog runningsttae at module power on. Remember to call the <tt>saveToFlash()</tt> method and then to reboot the module to apply this setting.</p>',par:{newval:'either <tt>Y_AUTOSTART_OFF</tt> or <tt>Y_AUTOSTART_ON</tt>, according to the watchdog runningsttae at module power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_logicalName']={syn:'Changes the logical name of the watchdog.',lib:'watchdog&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the watchdog. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the watchdog.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_maxTimeOnStateA']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state.',lib:'watchdog&rarr;set_maxTimeOnStateA()',pro:'int set_maxTimeOnStateA(s64 <span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state A before automatically switching back in to B state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_maxTimeOnStateB']={syn:'Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state.',lib:'watchdog&rarr;set_maxTimeOnStateB()',pro:'int set_maxTimeOnStateB(s64 <span id=pn>newval</span>)',cmt:'<p>Sets the maximum time (ms) allowed for $THEFUNCTIONS$ to stay in state B before automatically switching back in to A state. Use zero for no maximum time.</p>',par:{newval:'an integer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_output']={syn:'Changes the output state of the watchdog, when used as a simple switch (single throw).',lib:'watchdog&rarr;set_output()',pro:'int set_output(Y_OUTPUT_enum <span id=pn>newval</span>)',cmt:'<p>Changes the output state of the watchdog, when used as a simple switch (single throw).</p>',par:{newval:'either <tt>Y_OUTPUT_OFF</tt> or <tt>Y_OUTPUT_ON</tt>, according to the output state of the watchdog, when used as a simple switch (single throw)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_running']={syn:'Changes the running state of the watchdog.',lib:'watchdog&rarr;set_running()',pro:'int set_running(Y_RUNNING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the running state of the watchdog.</p>',par:{newval:'either <tt>Y_RUNNING_OFF</tt> or <tt>Y_RUNNING_ON</tt>, according to the running state of the watchdog'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_state']={syn:'Changes the state of the watchdog (A for the idle position, B for the active position).',lib:'watchdog&rarr;set_state()',pro:'int set_state(Y_STATE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the watchdog (A for the idle position, B for the active position).</p>',par:{newval:'either <tt>Y_STATE_A</tt> or <tt>Y_STATE_B</tt>, according to the state of the watchdog (A for the idle position, B for the active position)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_stateAtPowerOn']={syn:'Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification).',lib:'watchdog&rarr;set_stateAtPowerOn()',pro:'int set_stateAtPowerOn(Y_STATEATPOWERON_enum <span id=pn>newval</span>)',cmt:'<p>Preset the state of the watchdog at device startup (A for the idle position, B for the active position, UNCHANGED for no modification). Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a value among <tt>Y_STATEATPOWERON_UNCHANGED</tt>, <tt>Y_STATEATPOWERON_A</tt> and <tt>Y_STATEATPOWERON_B</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDelay']={syn:'Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.',lib:'watchdog&rarr;set_triggerDelay()',pro:'int set_triggerDelay(s64 <span id=pn>newval</span>)',cmt:'<p>Changes the waiting delay before a reset is triggered by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the waiting delay before a reset is triggered by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_triggerDuration']={syn:'Changes the duration of resets caused by the watchdog, in milliseconds.',lib:'watchdog&rarr;set_triggerDuration()',pro:'int set_triggerDuration(s64 <span id=pn>newval</span>)',cmt:'<p>Changes the duration of resets caused by the watchdog, in milliseconds.</p>',par:{newval:'an integer corresponding to the duration of resets caused by the watchdog, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Watchdog']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'watchdog&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Watchdog']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'watchdog&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Power function interface',inc:'#include &quot;yocto_power.h&quot;',cmt:'<p>The Yoctopuce class YPower allows you to read and configure Yoctopuce power sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to access the energy counter and the power factor.</p>'}};
doc['Power']['FindPower']={syn:'Retrieves a electrical power sensor for a given identifier.',lib:'YPower::FindPower()',pro:'YPower* FindPower(string <span id=pn>func</span>)',cmt:'<p>Retrieves a electrical power sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the electrical power sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPower.isOnline()</tt> to test if the electrical power sensor is indeed online at a given time. In case of ambiguity when looking for a electrical power sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the electrical power sensor'},ret:'a <tt>YPower</tt> object allowing you to drive the electrical power sensor.'};
doc['Power']['FirstPower']={syn:'Starts the enumeration of electrical power sensors currently accessible.',lib:'YPower::FirstPower()',pro:'YPower* FirstPower()',cmt:'<p>Starts the enumeration of electrical power sensors currently accessible. Use the method <tt>YPower.nextPower()</tt> to iterate on next electrical power sensors.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to the first electrical power sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Power']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'power&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['clearCache']={syn:'Invalidates the cache.',lib:'power&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the electrical power sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Power']['describe']={syn:'Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'power&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the electrical power sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the electrical power sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Power']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'power&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Power']['get_advertisedValue']={syn:'Returns the current value of the electrical power sensor (no more than 6 characters).',lib:'power&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the electrical power sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the electrical power sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).',lib:'power&rarr;get_cosPhi()',pro:'double get_cosPhi()',cmt:'<p>Returns the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA).</p>',ret:'a floating point number corresponding to the power factor (the ratio between the real power consumed, measured in W, and the apparent power provided, measured in VA)',ext:'On failure, throws an exception or returns <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.',lib:'power&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Returns the current value of the electrical power, in Watt, as a floating point number.',lib:'power&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the electrical power, in Watt, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the electrical power, in Watt, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'power&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Power']['get_errorMessage']={syn:'Returns the error message of the latest error with the electrical power sensor.',lib:'power&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the electrical power sensor object'};
doc['Power']['get_errorType']={syn:'Returns the numerical error code of the latest error with the electrical power sensor.',lib:'power&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the electrical power sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the electrical power sensor object'};
doc['Power']['get_friendlyName']={syn:'Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'power&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the electrical power sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the electrical power sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the electrical power sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the electrical power sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Power']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'power&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Power']['get_functionId']={syn:'Returns the hardware identifier of the electrical power sensor, without reference to the module.',lib:'power&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the electrical power sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the electrical power sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Power']['get_hardwareId']={syn:'Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'power&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the electrical power sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the electrical power sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the electrical power sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Returns the maximal value observed for the electrical power since the device was started.',lib:'power&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'power&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Returns the logical name of the electrical power sensor.',lib:'power&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the electrical power sensor.</p>',ret:'a string corresponding to the logical name of the electrical power sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Returns the minimal value observed for the electrical power since the device was started.',lib:'power&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the electrical power since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the electrical power since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time.',lib:'power&rarr;get_meter()',pro:'double get_meter()',cmt:'<p>Returns the energy counter, maintained by the wattmeter by integrating the power consumption over time. Note that this counter is reset at each start of the device.</p>',ret:'a floating point number corresponding to the energy counter, maintained by the wattmeter by integrating the power consumption over time',ext:'On failure, throws an exception or returns <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Returns the elapsed time since last energy counter reset, in seconds.',lib:'power&rarr;get_meterTimer()',pro:'int get_meterTimer()',cmt:'<p>Returns the elapsed time since last energy counter reset, in seconds.</p>',ret:'an integer corresponding to the elapsed time since last energy counter reset, in seconds',ext:'On failure, throws an exception or returns <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'power&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Power']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'power&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Power']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'power&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Power']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'power&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'power&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Returns the measuring unit for the electrical power.',lib:'power&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the electrical power.</p>',ret:'a string corresponding to the measuring unit for the electrical power',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'power&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Power']['isOnline']={syn:'Checks if the electrical power sensor is currently reachable, without raising any error.',lib:'power&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the electrical power sensor is currently reachable, without raising any error. If there is a cached value for the electrical power sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the electrical power sensor.</p>',ret:'<tt>true</tt> if the electrical power sensor can be reached, and <tt>false</tt> otherwise'};
doc['Power']['load']={syn:'Preloads the electrical power sensor cache with a specified validity duration.',lib:'power&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the electrical power sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'power&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Power']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'power&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'power&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['nextPower']={syn:'Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.',lib:'power&rarr;nextPower()',pro:'YPower * nextPower()',cmt:'<p>Continues the enumeration of electrical power sensors started using <tt>yFirstPower()</tt>.</p>',ret:'a pointer to a <tt>YPower</tt> object, corresponding to a electrical power sensor currently online, or a <tt>null</tt> pointer if there are no more electrical power sensors to enumerate.'};
doc['Power']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'power&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YPowerTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Power']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'power&rarr;registerValueCallback()',pro:'int registerValueCallback(YPowerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Power']['reset']={syn:'Resets the energy counter.',lib:'power&rarr;reset()',pro:'int reset()',cmt:'<p>Resets the energy counter.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'power&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'power&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'power&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_logicalName']={syn:'Changes the logical name of the electrical power sensor.',lib:'power&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the electrical power sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the electrical power sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'power&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'power&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'power&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Power']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'power&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Power']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'power&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Power']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'power&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Power']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'power&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Display function interface',inc:'#include &quot;yocto_display.h&quot;',cmt:'<p>Yoctopuce display interface has been designed to easily show information and images. The device provides built-in multi-layer rendering. Layers can be drawn offline, individually, and freely moved on the display. It can also replay recorded sequences (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Retrieves a display for a given identifier.',lib:'YDisplay::FindDisplay()',pro:'YDisplay* FindDisplay(string <span id=pn>func</span>)',cmt:'<p>Retrieves a display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the display is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDisplay.isOnline()</tt> to test if the display is indeed online at a given time. In case of ambiguity when looking for a display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the display'},ret:'a <tt>YDisplay</tt> object allowing you to drive the display.'};
doc['Display']['FirstDisplay']={syn:'Starts the enumeration of displays currently accessible.',lib:'YDisplay::FirstDisplay()',pro:'YDisplay* FirstDisplay()',cmt:'<p>Starts the enumeration of displays currently accessible. Use the method <tt>YDisplay.nextDisplay()</tt> to iterate on next displays.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to the first display currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Display']['clearCache']={syn:'Invalidates the cache.',lib:'display&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the display attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Display']['copyLayerContent']={syn:'Copies the whole content of a layer to another layer.',lib:'display&rarr;copyLayerContent()',pro:'int copyLayerContent(int <span id=pn>srcLayerId</span>, int <span id=pn>dstLayerId</span>)',cmt:'<p>Copies the whole content of a layer to another layer. The color and transparency of all the pixels from the destination layer are set to match the source pixels. This method only affects the displayed content, but does not change any property of the layer object. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{srcLayerId:'the identifier of the source layer (a number in range 0..layerCount-1)',dstLayerId:'the identifier of the destination layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['describe']={syn:'Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'display&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the display in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the display (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Display']['fade']={syn:'Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.',lib:'display&rarr;fade()',pro:'int fade(int <span id=pn>brightness</span>, int <span id=pn>duration</span>)',cmt:'<p>Smoothly changes the brightness of the screen to produce a fade-in or fade-out effect.</p>',par:{brightness:'the new screen brightness',duration:'duration of the brightness transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['get_advertisedValue']={syn:'Returns the current value of the display (no more than 6 characters).',lib:'display&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the display (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the display (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Returns the luminosity of the module informative leds (from 0 to 100).',lib:'display&rarr;get_brightness()',pro:'int get_brightness()',cmt:'<p>Returns the luminosity of the module informative leds (from 0 to 100).</p>',ret:'an integer corresponding to the luminosity of the module informative leds (from 0 to 100)',ext:'On failure, throws an exception or returns <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'display&rarr;get_displayHeight()',pro:'int get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayLayer']={syn:'Returns a YDisplayLayer object that can be used to draw on the specified layer.',lib:'display&rarr;get_displayLayer()',pro:'YDisplayLayer* get_displayLayer(unsigned <span id=pn>layerId</span>)',cmt:'<p>Returns a YDisplayLayer object that can be used to draw on the specified layer. The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>',par:{layerId:'the identifier of the layer (a number in range 0..layerCount-1)'},ret:'an <tt>YDisplayLayer</tt> object',ext:'On failure, throws an exception or returns <tt>null</tt>.'};
doc['Display']['get_displayType']={syn:'Returns the display type: monochrome, gray levels or full color.',lib:'display&rarr;get_displayType()',pro:'Y_DISPLAYTYPE_enum get_displayType()',cmt:'<p>Returns the display type: monochrome, gray levels or full color.</p>',ret:'a value among <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> and <tt>Y_DISPLAYTYPE_RGB</tt> corresponding to the display type: monochrome, gray levels or full color',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'display&rarr;get_displayWidth()',pro:'int get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_enabled']={syn:'Returns true if the screen is powered, false otherwise.',lib:'display&rarr;get_enabled()',pro:'Y_ENABLED_enum get_enabled()',cmt:'<p>Returns true if the screen is powered, false otherwise.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to true if the screen is powered, false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Returns the error message of the latest error with the display.',lib:'display&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the display object'};
doc['Display']['get_errorType']={syn:'Returns the numerical error code of the latest error with the display.',lib:'display&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the display. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the display object'};
doc['Display']['get_friendlyName']={syn:'Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'display&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the display in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the display if they are defined, otherwise the serial number of the module and the hardware identifier of the display (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the display using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Display']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'display&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Display']['get_functionId']={syn:'Returns the hardware identifier of the display, without reference to the module.',lib:'display&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the display, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the display (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Display']['get_hardwareId']={syn:'Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'display&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the display in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the display (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the display (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Returns the number of available layers to draw on.',lib:'display&rarr;get_layerCount()',pro:'int get_layerCount()',cmt:'<p>Returns the number of available layers to draw on.</p>',ret:'an integer corresponding to the number of available layers to draw on',ext:'On failure, throws an exception or returns <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'display&rarr;get_layerHeight()',pro:'int get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'display&rarr;get_layerWidth()',pro:'int get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Returns the logical name of the display.',lib:'display&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the display.</p>',ret:'a string corresponding to the logical name of the display.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'display&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Returns the currently selected display orientation.',lib:'display&rarr;get_orientation()',pro:'Y_ORIENTATION_enum get_orientation()',cmt:'<p>Returns the currently selected display orientation.</p>',ret:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the currently selected display orientation',ext:'On failure, throws an exception or returns <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Returns the name of the sequence to play when the displayed is powered on.',lib:'display&rarr;get_startupSeq()',pro:'string get_startupSeq()',cmt:'<p>Returns the name of the sequence to play when the displayed is powered on.</p>',ret:'a string corresponding to the name of the sequence to play when the displayed is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'display&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Display']['isOnline']={syn:'Checks if the display is currently reachable, without raising any error.',lib:'display&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the display is currently reachable, without raising any error. If there is a cached value for the display in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the display.</p>',ret:'<tt>true</tt> if the display can be reached, and <tt>false</tt> otherwise'};
doc['Display']['load']={syn:'Preloads the display cache with a specified validity duration.',lib:'display&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the display cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'display&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Display']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'display&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['newSequence']={syn:'Starts to record all display commands into a sequence, for later replay.',lib:'display&rarr;newSequence()',pro:'int newSequence()',cmt:'<p>Starts to record all display commands into a sequence, for later replay. The name used to store the sequence is specified when calling <tt>saveSequence()</tt>, once the recording is complete.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['nextDisplay']={syn:'Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.',lib:'display&rarr;nextDisplay()',pro:'YDisplay * nextDisplay()',cmt:'<p>Continues the enumeration of displays started using <tt>yFirstDisplay()</tt>.</p>',ret:'a pointer to a <tt>YDisplay</tt> object, corresponding to a display currently online, or a <tt>null</tt> pointer if there are no more displays to enumerate.'};
doc['Display']['pauseSequence']={syn:'Waits for a specified delay (in milliseconds) before playing next commands in current sequence.',lib:'display&rarr;pauseSequence()',pro:'int pauseSequence(int <span id=pn>delay_ms</span>)',cmt:'<p>Waits for a specified delay (in milliseconds) before playing next commands in current sequence. This method can be used while recording a display sequence, to insert a timed wait in the sequence (without any immediate effect). It can also be used dynamically while playing a pre-recorded sequence, to suspend or resume the execution of the sequence. To cancel a delay, call the same method with a zero delay.</p>',par:{delay_ms:'the duration to wait, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['playSequence']={syn:'Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.',lib:'display&rarr;playSequence()',pro:'int playSequence(string <span id=pn>sequenceName</span>)',cmt:'<p>Replays a display sequence previously recorded using <tt>newSequence()</tt> and <tt>saveSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'display&rarr;registerValueCallback()',pro:'int registerValueCallback(YDisplayValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Display']['resetAll']={syn:'Clears the display screen and resets all display layers to their default state.',lib:'display&rarr;resetAll()',pro:'int resetAll()',cmt:'<p>Clears the display screen and resets all display layers to their default state. Using this function in a sequence will kill the sequence play-back. Don\x27t use that function to reset the display at sequence start-up.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['saveSequence']={syn:'Stops recording display commands and saves the sequence into the specified file on the display internal memory.',lib:'display&rarr;saveSequence()',pro:'int saveSequence(string <span id=pn>sequenceName</span>)',cmt:'<p>Stops recording display commands and saves the sequence into the specified file on the display internal memory. The sequence can be later replayed using <tt>playSequence()</tt>.</p>',par:{sequenceName:'the name of the newly created sequence'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_brightness']={syn:'Changes the brightness of the display.',lib:'display&rarr;set_brightness()',pro:'int set_brightness(int <span id=pn>newval</span>)',cmt:'<p>Changes the brightness of the display. The parameter is a value between 0 and 100. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'an integer corresponding to the brightness of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_enabled']={syn:'Changes the power state of the display.',lib:'display&rarr;set_enabled()',pro:'int set_enabled(Y_ENABLED_enum <span id=pn>newval</span>)',cmt:'<p>Changes the power state of the display.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the power state of the display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_logicalName']={syn:'Changes the logical name of the display.',lib:'display&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the display. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the display.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_orientation']={syn:'Changes the display orientation.',lib:'display&rarr;set_orientation()',pro:'int set_orientation(Y_ORIENTATION_enum <span id=pn>newval</span>)',cmt:'<p>Changes the display orientation. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> and <tt>Y_ORIENTATION_DOWN</tt> corresponding to the display orientation'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_startupSeq']={syn:'Changes the name of the sequence to play when the displayed is powered on.',lib:'display&rarr;set_startupSeq()',pro:'int set_startupSeq(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the name of the sequence to play when the displayed is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the name of the sequence to play when the displayed is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'display&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Display']['stopSequence']={syn:'Stops immediately any ongoing sequence replay.',lib:'display&rarr;stopSequence()',pro:'int stopSequence()',cmt:'<p>Stops immediately any ongoing sequence replay. The display is left as is.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['swapLayerContent']={syn:'Swaps the whole content of two layers.',lib:'display&rarr;swapLayerContent()',pro:'int swapLayerContent(int <span id=pn>layerIdA</span>, int <span id=pn>layerIdB</span>)',cmt:'<p>Swaps the whole content of two layers. The color and transparency of all the pixels from the two layers are swapped. This method only affects the displayed content, but does not change any property of the layer objects. In particular, the visibility of each layer stays unchanged. When used between onae hidden layer and a visible layer, this method makes it possible to easily implement double-buffering. Note that layer 0 has no transparency support (it is always completely opaque).</p>',par:{layerIdA:'the first layer (a number in range 0..layerCount-1)',layerIdB:'the second layer (a number in range 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'display&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Display']['upload']={syn:'Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name.',lib:'display&rarr;upload()',pro:'int upload(string <span id=pn>pathname</span>, string <span id=pn>content</span>)',cmt:'<p>Uploads an arbitrary file (for instance a GIF file) to the display, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Display)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'DisplayLayer object interface',inc:'#include &quot;yocto_display.h&quot;',cmt:'<p>A DisplayLayer is an image layer containing objects to display (bitmaps, text, etc.). The content is displayed only when the layer is active on the screen (and not masked by other overlapping layers).</p>'}};
doc['DisplayLayer']['clear']={syn:'Erases the whole content of the layer (makes it fully transparent).',lib:'displaylayer&rarr;clear()',pro:'int clear()',cmt:'<p>Erases the whole content of the layer (makes it fully transparent). This method does not change any other attribute of the layer. To reinitialize the layer attributes to defaults settings, use the method <tt>reset()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['clearConsole']={syn:'Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.',lib:'displaylayer&rarr;clearConsole()',pro:'int clearConsole()',cmt:'<p>Blanks the console area within console margins, and resets the console pointer to the upper left corner of the console.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['consoleOut']={syn:'Outputs a message in the console area, and advances the console pointer accordingly.',lib:'displaylayer&rarr;consoleOut()',pro:'int consoleOut(string <span id=pn>text</span>)',cmt:'<p>Outputs a message in the console area, and advances the console pointer accordingly. The console pointer position is automatically moved to the beginning of the next line when a newline character is met, or when the right margin is hit. When the new text to display extends below the lower margin, the console area is automatically scrolled up.</p>',par:{text:'the message to display'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBar']={syn:'Draws a filled rectangular bar at a specified position.',lib:'displaylayer&rarr;drawBar()',pro:'int drawBar(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Draws a filled rectangular bar at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawBitmap']={syn:'Draws a bitmap at the specified position.',lib:'displaylayer&rarr;drawBitmap()',pro:'int drawBitmap(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>w</span>, string <span id=pn>bitmap</span>, int <span id=pn>bgcol</span>)',cmt:'<p>Draws a bitmap at the specified position. The bitmap is provided as a binary object, where each pixel maps to a bit, from left to right and from top to bottom. The most significant bit of each byte maps to the leftmost pixel, and the least significant bit maps to the rightmost pixel. Bits set to 1 are drawn using the layer selected pen color. Bits set to 0 are drawn using the specified background gray level, unless -1 is specified, in which case they are not drawn at all (as if transparent).</p>',par:{x:'the distance from left of layer to the left of the bitmap, in pixels',y:'the distance from top of layer to the top of the bitmap, in pixels',w:'the width of the bitmap, in pixels',bitmap:'a binary object',bgcol:'the background gray level to use for zero bits (0 = black, 255 = white), or -1 to leave the pixels unchanged'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawCircle']={syn:'Draws an empty circle at a specified position.',lib:'displaylayer&rarr;drawCircle()',pro:'int drawCircle(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>r</span>)',cmt:'<p>Draws an empty circle at a specified position.</p>',par:{x:'the distance from left of layer to the center of the circle, in pixels',y:'the distance from top of layer to the center of the circle, in pixels',r:'the radius of the circle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawDisc']={syn:'Draws a filled disc at a given position.',lib:'displaylayer&rarr;drawDisc()',pro:'int drawDisc(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>r</span>)',cmt:'<p>Draws a filled disc at a given position.</p>',par:{x:'the distance from left of layer to the center of the disc, in pixels',y:'the distance from top of layer to the center of the disc, in pixels',r:'the radius of the disc, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawImage']={syn:'Draws a GIF image at the specified position.',lib:'displaylayer&rarr;drawImage()',pro:'int drawImage(int <span id=pn>x</span>, int <span id=pn>y</span>, string <span id=pn>imagename</span>)',cmt:'<p>Draws a GIF image at the specified position. The GIF image must have been previously uploaded to the device built-in memory. If you experience problems using an image file, check the device logs for any error message such as missing image file or bad image file format.</p>',par:{x:'the distance from left of layer to the left of the image, in pixels',y:'the distance from top of layer to the top of the image, in pixels',imagename:'the GIF file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawPixel']={syn:'Draws a single pixel at the specified position.',lib:'displaylayer&rarr;drawPixel()',pro:'int drawPixel(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Draws a single pixel at the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawRect']={syn:'Draws an empty rectangle at a specified position.',lib:'displaylayer&rarr;drawRect()',pro:'int drawRect(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Draws an empty rectangle at a specified position.</p>',par:{x1:'the distance from left of layer to the left border of the rectangle, in pixels',y1:'the distance from top of layer to the top border of the rectangle, in pixels',x2:'the distance from left of layer to the right border of the rectangle, in pixels',y2:'the distance from top of layer to the bottom border of the rectangle, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['drawText']={syn:'Draws a text string at the specified position.',lib:'displaylayer&rarr;drawText()',pro:'int drawText(int <span id=pn>x</span>, int <span id=pn>y</span>, Y_ALIGN <span id=pn>anchor</span>, string <span id=pn>text</span>)',cmt:'<p>Draws a text string at the specified position. The point of the text that is aligned to the specified pixel position is called the anchor point, and can be chosen among several options. Text is rendered from left to right, without implicit wrapping.</p>',par:{x:'the distance from left of layer to the text anchor point, in pixels',y:'the distance from top of layer to the text anchor point, in pixels',anchor:'the text anchor point, chosen among the <tt>Y_ALIGN</tt> enumeration: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'the text string to draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['get_display']={syn:'Gets parent YDisplay.',lib:'displaylayer&rarr;get_display()',pro:'YDisplay* get_display()',cmt:'<p>Gets parent YDisplay. Returns the parent YDisplay object of the current YDisplayLayer.</p>',ret:'an <tt>YDisplay</tt> object'};
doc['DisplayLayer']['get_displayHeight']={syn:'Returns the display height, in pixels.',lib:'displaylayer&rarr;get_displayHeight()',pro:'int get_displayHeight()',cmt:'<p>Returns the display height, in pixels.</p>',ret:'an integer corresponding to the display height, in pixels',ext:'On failure, throws an exception or returns Y_DISPLAYHEIGHT_INVALID.'};
doc['DisplayLayer']['get_displayWidth']={syn:'Returns the display width, in pixels.',lib:'displaylayer&rarr;get_displayWidth()',pro:'int get_displayWidth()',cmt:'<p>Returns the display width, in pixels.</p>',ret:'an integer corresponding to the display width, in pixels',ext:'On failure, throws an exception or returns Y_DISPLAYWIDTH_INVALID.'};
doc['DisplayLayer']['get_layerHeight']={syn:'Returns the height of the layers to draw on, in pixels.',lib:'displaylayer&rarr;get_layerHeight()',pro:'int get_layerHeight()',cmt:'<p>Returns the height of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the height of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERHEIGHT_INVALID.'};
doc['DisplayLayer']['get_layerWidth']={syn:'Returns the width of the layers to draw on, in pixels.',lib:'displaylayer&rarr;get_layerWidth()',pro:'int get_layerWidth()',cmt:'<p>Returns the width of the layers to draw on, in pixels.</p>',ret:'an integer corresponding to the width of the layers to draw on, in pixels',ext:'On failure, throws an exception or returns Y_LAYERWIDTH_INVALID.'};
doc['DisplayLayer']['hide']={syn:'Hides the layer.',lib:'displaylayer&rarr;hide()',pro:'int hide()',cmt:'<p>Hides the layer. The state of the layer is perserved but the layer is not displayed on the screen until the next call to <tt>unhide()</tt>. Hiding the layer can positively affect the drawing speed, since it postpones the rendering until all operations are completed (double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['lineTo']={syn:'Draws a line from current drawing pointer position to the specified position.',lib:'displaylayer&rarr;lineTo()',pro:'int lineTo(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Draws a line from current drawing pointer position to the specified position. The specified destination pixel is included in the line. The pointer position is then moved to the end point of the line.</p>',par:{x:'the distance from left of layer to the end point of the line, in pixels',y:'the distance from top of layer to the end point of the line, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['moveTo']={syn:'Moves the drawing pointer of this layer to the specified position.',lib:'displaylayer&rarr;moveTo()',pro:'int moveTo(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Moves the drawing pointer of this layer to the specified position.</p>',par:{x:'the distance from left of layer, in pixels',y:'the distance from top of layer, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['reset']={syn:'Reverts the layer to its initial state (fully transparent, default settings).',lib:'displaylayer&rarr;reset()',pro:'int reset()',cmt:'<p>Reverts the layer to its initial state (fully transparent, default settings). Reinitializes the drawing pointer to the upper left position, and selects the most visible pen color. If you only want to erase the layer content, use the method <tt>clear()</tt> instead.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectColorPen']={syn:'Selects the pen color for all subsequent drawing functions, including text drawing.',lib:'displaylayer&rarr;selectColorPen()',pro:'int selectColorPen(int <span id=pn>color</span>)',cmt:'<p>Selects the pen color for all subsequent drawing functions, including text drawing. The pen color is provided as an RGB value. For grayscale or monochrome displays, the value is automatically converted to the proper range.</p>',par:{color:'the desired pen color, as a 24-bit RGB value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectEraser']={syn:'Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions.',lib:'displaylayer&rarr;selectEraser()',pro:'int selectEraser()',cmt:'<p>Selects an eraser instead of a pen for all subsequent drawing functions, except for bitmap copy functions. Any point drawn using the eraser becomes transparent (as when the layer is empty), showing the other layers beneath it.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectFont']={syn:'Selects a font to use for the next text drawing functions, by providing the name of the font file.',lib:'displaylayer&rarr;selectFont()',pro:'int selectFont(string <span id=pn>fontname</span>)',cmt:'<p>Selects a font to use for the next text drawing functions, by providing the name of the font file. You can use a built-in font as well as a font file that you have previously uploaded to the device built-in memory. If you experience problems selecting a font file, check the device logs for any error message such as missing font file or bad font file format.</p>',par:{fontname:'the font file name'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Selects the pen gray level for all subsequent drawing functions, including text drawing.',lib:'displaylayer&rarr;selectGrayPen()',pro:'int selectGrayPen(int <span id=pn>graylevel</span>)',cmt:'<p>Selects the pen gray level for all subsequent drawing functions, including text drawing. The gray level is provided as a number between 0 (black) and 255 (white, or whichever the lighest color is). For monochrome displays (without gray levels), any value lower than 128 is rendered as black, and any value equal or above to 128 is non-black.</p>',par:{graylevel:'the desired gray level, from 0 to 255'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Enables or disables anti-aliasing for drawing oblique lines and circles.',lib:'displaylayer&rarr;setAntialiasingMode()',pro:'int setAntialiasingMode(bool <span id=pn>mode</span>)',cmt:'<p>Enables or disables anti-aliasing for drawing oblique lines and circles. Anti-aliasing provides a smoother aspect when looked from far enough, but it can add fuzzyness when the display is looked from very close. At the end of the day, it is your personal choice. Anti-aliasing is enabled by default on grayscale and color displays, but you can disable it if you prefer. This setting has no effect on monochrome displays.</p>',par:{mode:'<tt>true</tt> to enable antialiasing, <tt>false</tt> to disable it.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.',lib:'displaylayer&rarr;setConsoleBackground()',pro:'int setConsoleBackground(int <span id=pn>bgcol</span>)',cmt:'<p>Sets up the background color used by the <tt>clearConsole</tt> function and by the console scrolling feature.</p>',par:{bgcol:'the background gray level to use when scrolling (0 = black, 255 = white), or -1 for transparent'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Sets up display margins for the <tt>consoleOut</tt> function.',lib:'displaylayer&rarr;setConsoleMargins()',pro:'int setConsoleMargins(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Sets up display margins for the <tt>consoleOut</tt> function.</p>',par:{x1:'the distance from left of layer to the left margin, in pixels',y1:'the distance from top of layer to the top margin, in pixels',x2:'the distance from left of layer to the right margin, in pixels',y2:'the distance from top of layer to the bottom margin, in pixels'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.',lib:'displaylayer&rarr;setConsoleWordWrap()',pro:'int setConsoleWordWrap(bool <span id=pn>wordwrap</span>)',cmt:'<p>Sets up the wrapping behaviour used by the <tt>consoleOut</tt> function.</p>',par:{wordwrap:'<tt>true</tt> to wrap only between words, <tt>false</tt> to wrap on the last column anyway.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['setLayerPosition']={syn:'Sets the position of the layer relative to the display upper left corner.',lib:'displaylayer&rarr;setLayerPosition()',pro:'int setLayerPosition(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>scrollTime</span>)',cmt:'<p>Sets the position of the layer relative to the display upper left corner. When smooth scrolling is used, the display offset of the layer is automatically updated during the next milliseconds to animate the move of the layer.</p>',par:{x:'the distance from left of display to the upper left corner of the layer',y:'the distance from top of display to the upper left corner of the layer',scrollTime:'number of milliseconds to use for smooth scrolling, or 0 if the scrolling should be immediate.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DisplayLayer']['unhide']={syn:'Shows the layer.',lib:'displaylayer&rarr;unhide()',pro:'int unhide()',cmt:'<p>Shows the layer. Shows the layer again after a hide command.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Files)
doc['Files']={'':{syn:'Files function interface',inc:'#include &quot;yocto_files.h&quot;',cmt:'<p>The filesystem interface makes it possible to store files on some devices, for instance to design a custom web UI (for networked devices) or to add fonts (on display devices).</p>'}};
doc['Files']['FindFiles']={syn:'Retrieves a filesystem for a given identifier.',lib:'YFiles::FindFiles()',pro:'YFiles* FindFiles(string <span id=pn>func</span>)',cmt:'<p>Retrieves a filesystem for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the filesystem is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YFiles.isOnline()</tt> to test if the filesystem is indeed online at a given time. In case of ambiguity when looking for a filesystem by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the filesystem'},ret:'a <tt>YFiles</tt> object allowing you to drive the filesystem.'};
doc['Files']['FirstFiles']={syn:'Starts the enumeration of filesystems currently accessible.',lib:'YFiles::FirstFiles()',pro:'YFiles* FirstFiles()',cmt:'<p>Starts the enumeration of filesystems currently accessible. Use the method <tt>YFiles.nextFiles()</tt> to iterate on next filesystems.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to the first filesystem currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Files']['clearCache']={syn:'Invalidates the cache.',lib:'files&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the filesystem attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Files']['describe']={syn:'Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'files&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the filesystem in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the filesystem (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Files']['download']={syn:'Downloads the requested file and returns a binary buffer with its content.',lib:'files&rarr;download()',pro:'string download(string <span id=pn>pathname</span>)',cmt:'<p>Downloads the requested file and returns a binary buffer with its content.</p>',par:{pathname:'path and name of the file to download'},ret:'a binary buffer with the file content',ext:'On failure, throws an exception or returns an empty content.'};
doc['Files']['fileExist']={syn:'Test if a file exist on the filesystem of the module.',lib:'files&rarr;fileExist()',pro:'bool fileExist(string <span id=pn>filename</span>)',cmt:'<p>Test if a file exist on the filesystem of the module.</p>',par:{filename:'the file name to test.'},ret:'a true if the file existe, false ortherwise.',ext:'On failure, throws an exception.'};
doc['Files']['format_fs']={syn:'Reinitialize the filesystem to its clean, unfragmented, empty state.',lib:'files&rarr;format_fs()',pro:'int format_fs()',cmt:'<p>Reinitialize the filesystem to its clean, unfragmented, empty state. All files previously uploaded are permanently lost.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['get_advertisedValue']={syn:'Returns the current value of the filesystem (no more than 6 characters).',lib:'files&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the filesystem (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the filesystem (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Returns the error message of the latest error with the filesystem.',lib:'files&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the filesystem object'};
doc['Files']['get_errorType']={syn:'Returns the numerical error code of the latest error with the filesystem.',lib:'files&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the filesystem. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the filesystem object'};
doc['Files']['get_filesCount']={syn:'Returns the number of files currently loaded in the filesystem.',lib:'files&rarr;get_filesCount()',pro:'int get_filesCount()',cmt:'<p>Returns the number of files currently loaded in the filesystem.</p>',ret:'an integer corresponding to the number of files currently loaded in the filesystem',ext:'On failure, throws an exception or returns <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Returns the free space for uploading new files to the filesystem, in bytes.',lib:'files&rarr;get_freeSpace()',pro:'int get_freeSpace()',cmt:'<p>Returns the free space for uploading new files to the filesystem, in bytes.</p>',ret:'an integer corresponding to the free space for uploading new files to the filesystem, in bytes',ext:'On failure, throws an exception or returns <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_friendlyName']={syn:'Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'files&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the filesystem in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the filesystem if they are defined, otherwise the serial number of the module and the hardware identifier of the filesystem (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the filesystem using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'files&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Files']['get_functionId']={syn:'Returns the hardware identifier of the filesystem, without reference to the module.',lib:'files&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the filesystem, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the filesystem (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Files']['get_hardwareId']={syn:'Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'files&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the filesystem in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the filesystem (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the filesystem (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Files']['get_list']={syn:'Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.',lib:'files&rarr;get_list()',pro:'vector&lt;YFileRecord&gt; get_list(string <span id=pn>pattern</span>)',cmt:'<p>Returns a list of YFileRecord objects that describe files currently loaded in the filesystem.</p>',par:{pattern:'an optional filter pattern, using star and question marks as wildcards. When an empty pattern is provided, all file records are returned.'},ret:'a list of <tt>YFileRecord</tt> objects, containing the file path and name, byte size and 32-bit CRC of the file content.',ext:'On failure, throws an exception or returns an empty list.'};
doc['Files']['get_logicalName']={syn:'Returns the logical name of the filesystem.',lib:'files&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the filesystem.</p>',ret:'a string corresponding to the logical name of the filesystem.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'files&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'files&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Files']['isOnline']={syn:'Checks if the filesystem is currently reachable, without raising any error.',lib:'files&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the filesystem is currently reachable, without raising any error. If there is a cached value for the filesystem in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the filesystem.</p>',ret:'<tt>true</tt> if the filesystem can be reached, and <tt>false</tt> otherwise'};
doc['Files']['load']={syn:'Preloads the filesystem cache with a specified validity duration.',lib:'files&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the filesystem cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'files&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Files']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'files&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['nextFiles']={syn:'Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.',lib:'files&rarr;nextFiles()',pro:'YFiles * nextFiles()',cmt:'<p>Continues the enumeration of filesystems started using <tt>yFirstFiles()</tt>.</p>',ret:'a pointer to a <tt>YFiles</tt> object, corresponding to a filesystem currently online, or a <tt>null</tt> pointer if there are no more filesystems to enumerate.'};
doc['Files']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'files&rarr;registerValueCallback()',pro:'int registerValueCallback(YFilesValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Files']['remove']={syn:'Deletes a file, given by its full path name, from the filesystem.',lib:'files&rarr;remove()',pro:'int remove(string <span id=pn>pathname</span>)',cmt:'<p>Deletes a file, given by its full path name, from the filesystem. Because of filesystem fragmentation, deleting a file may not always free up the whole space used by the file. However, rewriting a file with the same path name will always reuse any space not freed previously. If you need to ensure that no space is taken by previously deleted files, you can use <tt>format_fs</tt> to fully reinitialize the filesystem.</p>',par:{pathname:'path and name of the file to remove.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_logicalName']={syn:'Changes the logical name of the filesystem.',lib:'files&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the filesystem. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the filesystem.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'files&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Files']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'files&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Files']['upload']={syn:'Uploads a file to the filesystem, to the specified full path name.',lib:'files&rarr;upload()',pro:'int upload(string <span id=pn>pathname</span>, string <span id=pn>content</span>)',cmt:'<p>Uploads a file to the filesystem, to the specified full path name. If a file already exists with the same path name, its content is overwritten.</p>',par:{pathname:'path and name of the new file to create',content:'binary buffer with the content to set'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Files)
//--- (generated code: RealTimeClock)
doc['RealTimeClock']={'':{syn:'Real Time Clock function interface',inc:'#include &quot;yocto_realtimeclock.h&quot;',cmt:'<p>The RealTimeClock function maintains and provides current date and time, even accross power cut lasting several days. It is the base for automated wake-up functions provided by the WakeUpScheduler. The current time may represent a local time as well as an UTC time, but no automatic time change will occur to account for daylight saving time.</p>'}};
doc['RealTimeClock']['FindRealTimeClock']={syn:'Retrieves a clock for a given identifier.',lib:'YRealTimeClock::FindRealTimeClock()',pro:'YRealTimeClock* FindRealTimeClock(string <span id=pn>func</span>)',cmt:'<p>Retrieves a clock for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the clock is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRealTimeClock.isOnline()</tt> to test if the clock is indeed online at a given time. In case of ambiguity when looking for a clock by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the clock'},ret:'a <tt>YRealTimeClock</tt> object allowing you to drive the clock.'};
doc['RealTimeClock']['FirstRealTimeClock']={syn:'Starts the enumeration of clocks currently accessible.',lib:'YRealTimeClock::FirstRealTimeClock()',pro:'YRealTimeClock* FirstRealTimeClock()',cmt:'<p>Starts the enumeration of clocks currently accessible. Use the method <tt>YRealTimeClock.nextRealTimeClock()</tt> to iterate on next clocks.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to the first clock currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RealTimeClock']['clearCache']={syn:'Invalidates the cache.',lib:'realtimeclock&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the clock attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['RealTimeClock']['describe']={syn:'Returns a short text that describes unambiguously the instance of the clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'realtimeclock&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the clock in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the clock (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RealTimeClock']['get_advertisedValue']={syn:'Returns the current value of the clock (no more than 6 characters).',lib:'realtimeclock&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the clock (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the clock (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RealTimeClock']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'realtimeclock&rarr;get_dateTime()',pro:'string get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['RealTimeClock']['get_errorMessage']={syn:'Returns the error message of the latest error with the clock.',lib:'realtimeclock&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the clock object'};
doc['RealTimeClock']['get_errorType']={syn:'Returns the numerical error code of the latest error with the clock.',lib:'realtimeclock&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the clock. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the clock object'};
doc['RealTimeClock']['get_friendlyName']={syn:'Returns a global identifier of the clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'realtimeclock&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the clock in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the clock if they are defined, otherwise the serial number of the module and the hardware identifier of the clock (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the clock using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'realtimeclock&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RealTimeClock']['get_functionId']={syn:'Returns the hardware identifier of the clock, without reference to the module.',lib:'realtimeclock&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the clock, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the clock (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RealTimeClock']['get_hardwareId']={syn:'Returns the unique hardware identifier of the clock in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'realtimeclock&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the clock in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the clock (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the clock (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RealTimeClock']['get_logicalName']={syn:'Returns the logical name of the clock.',lib:'realtimeclock&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the clock.</p>',ret:'a string corresponding to the logical name of the clock.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RealTimeClock']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'realtimeclock&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RealTimeClock']['get_timeSet']={syn:'Returns true if the clock has been set, and false otherwise.',lib:'realtimeclock&rarr;get_timeSet()',pro:'Y_TIMESET_enum get_timeSet()',cmt:'<p>Returns true if the clock has been set, and false otherwise.</p>',ret:'either <tt>Y_TIMESET_FALSE</tt> or <tt>Y_TIMESET_TRUE</tt>, according to true if the clock has been set, and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_TIMESET_INVALID</tt>.'};
doc['RealTimeClock']['get_unixTime']={syn:'Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).',lib:'realtimeclock&rarr;get_unixTime()',pro:'s64 get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of elapsed seconds since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['RealTimeClock']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'realtimeclock&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RealTimeClock']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock&rarr;get_utcOffset()',pro:'int get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['RealTimeClock']['isOnline']={syn:'Checks if the clock is currently reachable, without raising any error.',lib:'realtimeclock&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the clock is currently reachable, without raising any error. If there is a cached value for the clock in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the clock.</p>',ret:'<tt>true</tt> if the clock can be reached, and <tt>false</tt> otherwise'};
doc['RealTimeClock']['load']={syn:'Preloads the clock cache with a specified validity duration.',lib:'realtimeclock&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the clock cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'realtimeclock&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['RealTimeClock']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'realtimeclock&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['nextRealTimeClock']={syn:'Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.',lib:'realtimeclock&rarr;nextRealTimeClock()',pro:'YRealTimeClock * nextRealTimeClock()',cmt:'<p>Continues the enumeration of clocks started using <tt>yFirstRealTimeClock()</tt>.</p>',ret:'a pointer to a <tt>YRealTimeClock</tt> object, corresponding to a clock currently online, or a <tt>null</tt> pointer if there are no more clocks to enumerate.'};
doc['RealTimeClock']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'realtimeclock&rarr;registerValueCallback()',pro:'int registerValueCallback(YRealTimeClockValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RealTimeClock']['set_logicalName']={syn:'Changes the logical name of the clock.',lib:'realtimeclock&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the clock. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the clock.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_unixTime']={syn:'Changes the current time.',lib:'realtimeclock&rarr;set_unixTime()',pro:'int set_unixTime(s64 <span id=pn>newval</span>)',cmt:'<p>Changes the current time. Time is specifid in Unix format (number of elapsed seconds since Jan 1st, 1970).</p>',par:{newval:'an integer corresponding to the current time'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'realtimeclock&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RealTimeClock']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'realtimeclock&rarr;set_utcOffset()',pro:'int set_utcOffset(int <span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RealTimeClock']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'realtimeclock&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RealTimeClock)
//--- (generated code: WakeUpMonitor)
doc['WakeUpMonitor']={'':{syn:'WakeUpMonitor function interface',inc:'#include &quot;yocto_wakeupmonitor.h&quot;',cmt:'<p>The WakeUpMonitor function handles globally all wake-up sources, as well as automated sleep mode.</p>'}};
doc['WakeUpMonitor']['FindWakeUpMonitor']={syn:'Retrieves a monitor for a given identifier.',lib:'YWakeUpMonitor::FindWakeUpMonitor()',pro:'YWakeUpMonitor* FindWakeUpMonitor(string <span id=pn>func</span>)',cmt:'<p>Retrieves a monitor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the monitor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpMonitor.isOnline()</tt> to test if the monitor is indeed online at a given time. In case of ambiguity when looking for a monitor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the monitor'},ret:'a <tt>YWakeUpMonitor</tt> object allowing you to drive the monitor.'};
doc['WakeUpMonitor']['FirstWakeUpMonitor']={syn:'Starts the enumeration of monitors currently accessible.',lib:'YWakeUpMonitor::FirstWakeUpMonitor()',pro:'YWakeUpMonitor* FirstWakeUpMonitor()',cmt:'<p>Starts the enumeration of monitors currently accessible. Use the method <tt>YWakeUpMonitor.nextWakeUpMonitor()</tt> to iterate on next monitors.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to the first monitor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpMonitor']['clearCache']={syn:'Invalidates the cache.',lib:'wakeupmonitor&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the monitor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['WakeUpMonitor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupmonitor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the monitor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the monitor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpMonitor']['get_advertisedValue']={syn:'Returns the current value of the monitor (no more than 6 characters).',lib:'wakeupmonitor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the monitor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the monitor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpMonitor']['get_errorMessage']={syn:'Returns the error message of the latest error with the monitor.',lib:'wakeupmonitor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the monitor object'};
doc['WakeUpMonitor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the monitor.',lib:'wakeupmonitor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the monitor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the monitor object'};
doc['WakeUpMonitor']['get_friendlyName']={syn:'Returns a global identifier of the monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wakeupmonitor&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the monitor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the monitor if they are defined, otherwise the serial number of the module and the hardware identifier of the monitor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the monitor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupmonitor&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpMonitor']['get_functionId']={syn:'Returns the hardware identifier of the monitor, without reference to the module.',lib:'wakeupmonitor&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the monitor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the monitor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the monitor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupmonitor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the monitor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the monitor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the monitor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpMonitor']['get_logicalName']={syn:'Returns the logical name of the monitor.',lib:'wakeupmonitor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the monitor.</p>',ret:'a string corresponding to the logical name of the monitor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpMonitor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupmonitor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpMonitor']['get_nextWakeUp']={syn:'Returns the next scheduled wake up date/time (UNIX format).',lib:'wakeupmonitor&rarr;get_nextWakeUp()',pro:'s64 get_nextWakeUp()',cmt:'<p>Returns the next scheduled wake up date/time (UNIX format).</p>',ret:'an integer corresponding to the next scheduled wake up date/time (UNIX format)',ext:'On failure, throws an exception or returns <tt>Y_NEXTWAKEUP_INVALID</tt>.'};
doc['WakeUpMonitor']['get_powerDuration']={syn:'Returns the maximal wake up time (in seconds) before automatically going to sleep.',lib:'wakeupmonitor&rarr;get_powerDuration()',pro:'int get_powerDuration()',cmt:'<p>Returns the maximal wake up time (in seconds) before automatically going to sleep.</p>',ret:'an integer corresponding to the maximal wake up time (in seconds) before automatically going to sleep',ext:'On failure, throws an exception or returns <tt>Y_POWERDURATION_INVALID</tt>.'};
doc['WakeUpMonitor']['get_sleepCountdown']={syn:'Returns the delay before the next sleep period.',lib:'wakeupmonitor&rarr;get_sleepCountdown()',pro:'int get_sleepCountdown()',cmt:'<p>Returns the delay before the next sleep period.</p>',ret:'an integer corresponding to the delay before the next sleep period',ext:'On failure, throws an exception or returns <tt>Y_SLEEPCOUNTDOWN_INVALID</tt>.'};
doc['WakeUpMonitor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupmonitor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpMonitor']['get_wakeUpReason']={syn:'Returns the latest wake up reason.',lib:'wakeupmonitor&rarr;get_wakeUpReason()',pro:'Y_WAKEUPREASON_enum get_wakeUpReason()',cmt:'<p>Returns the latest wake up reason.</p>',ret:'a value among <tt>Y_WAKEUPREASON_USBPOWER</tt>, <tt>Y_WAKEUPREASON_EXTPOWER</tt>, <tt>Y_WAKEUPREASON_ENDOFSLEEP</tt>, <tt>Y_WAKEUPREASON_EXTSIG1</tt>, <tt>Y_WAKEUPREASON_SCHEDULE1</tt> and <tt>Y_WAKEUPREASON_SCHEDULE2</tt> corresponding to the latest wake up reason',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPREASON_INVALID</tt>.'};
doc['WakeUpMonitor']['get_wakeUpState']={syn:'Returns the current state of the monitor.',lib:'wakeupmonitor&rarr;get_wakeUpState()',pro:'Y_WAKEUPSTATE_enum get_wakeUpState()',cmt:'<p>Returns the current state of the monitor.</p>',ret:'either <tt>Y_WAKEUPSTATE_SLEEPING</tt> or <tt>Y_WAKEUPSTATE_AWAKE</tt>, according to the current state of the monitor',ext:'On failure, throws an exception or returns <tt>Y_WAKEUPSTATE_INVALID</tt>.'};
doc['WakeUpMonitor']['isOnline']={syn:'Checks if the monitor is currently reachable, without raising any error.',lib:'wakeupmonitor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the monitor is currently reachable, without raising any error. If there is a cached value for the monitor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the monitor.</p>',ret:'<tt>true</tt> if the monitor can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpMonitor']['load']={syn:'Preloads the monitor cache with a specified validity duration.',lib:'wakeupmonitor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the monitor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'wakeupmonitor&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['WakeUpMonitor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'wakeupmonitor&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['nextWakeUpMonitor']={syn:'Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.',lib:'wakeupmonitor&rarr;nextWakeUpMonitor()',pro:'YWakeUpMonitor * nextWakeUpMonitor()',cmt:'<p>Continues the enumeration of monitors started using <tt>yFirstWakeUpMonitor()</tt>.</p>',ret:'a pointer to a <tt>YWakeUpMonitor</tt> object, corresponding to a monitor currently online, or a <tt>null</tt> pointer if there are no more monitors to enumerate.'};
doc['WakeUpMonitor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupmonitor&rarr;registerValueCallback()',pro:'int registerValueCallback(YWakeUpMonitorValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpMonitor']['resetSleepCountDown']={syn:'Resets the sleep countdown.',lib:'wakeupmonitor&rarr;resetSleepCountDown()',pro:'int resetSleepCountDown()',cmt:'<p>Resets the sleep countdown.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_logicalName']={syn:'Changes the logical name of the monitor.',lib:'wakeupmonitor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the monitor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the monitor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_nextWakeUp']={syn:'Changes the days of the week when a wake up must take place.',lib:'wakeupmonitor&rarr;set_nextWakeUp()',pro:'int set_nextWakeUp(s64 <span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_powerDuration']={syn:'Changes the maximal wake up time (seconds) before automatically going to sleep.',lib:'wakeupmonitor&rarr;set_powerDuration()',pro:'int set_powerDuration(int <span id=pn>newval</span>)',cmt:'<p>Changes the maximal wake up time (seconds) before automatically going to sleep.</p>',par:{newval:'an integer corresponding to the maximal wake up time (seconds) before automatically going to sleep'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_sleepCountdown']={syn:'Changes the delay before the next sleep period.',lib:'wakeupmonitor&rarr;set_sleepCountdown()',pro:'int set_sleepCountdown(int <span id=pn>newval</span>)',cmt:'<p>Changes the delay before the next sleep period.</p>',par:{newval:'an integer corresponding to the delay before the next sleep period'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupmonitor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpMonitor']['sleep']={syn:'Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor&rarr;sleep()',pro:'int sleep(int <span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep until the next wake up condition is met, the RTC time must have been set before calling this function.</p>',par:{secBeforeSleep:'number of seconds before going into sleep mode,'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepFor']={syn:'Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor&rarr;sleepFor()',pro:'int sleepFor(int <span id=pn>secUntilWakeUp</span>, int <span id=pn>secBeforeSleep</span>)',cmt:'<p>Goes to sleep for a specific duration or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{secUntilWakeUp:'number of seconds before next wake up',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['sleepUntil']={syn:'Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function.',lib:'wakeupmonitor&rarr;sleepUntil()',pro:'int sleepUntil(int <span id=pn>wakeUpTime</span>, int <span id=pn>secBeforeSleep</span>)',cmt:'<p>Go to sleep until a specific date is reached or until the next wake up condition is met, the RTC time must have been set before calling this function. The count down before sleep can be canceled with resetSleepCountDown.</p>',par:{wakeUpTime:'wake-up datetime (UNIX format)',secBeforeSleep:'number of seconds before going into sleep mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'wakeupmonitor&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpMonitor']['wakeUp']={syn:'Forces a wake up.',lib:'wakeupmonitor&rarr;wakeUp()',pro:'int wakeUp()',cmt:'<p>Forces a wake up.</p>'};
//--- (end of generated code: WakeUpMonitor)
//--- (generated code: WakeUpSchedule)
doc['WakeUpSchedule']={'':{syn:'WakeUpSchedule function interface',inc:'#include &quot;yocto_wakeupschedule.h&quot;',cmt:'<p>The WakeUpSchedule function implements a wake up condition. The wake up time is specified as a set of months and/or days and/or hours and/or minutes when the wake up should happen.</p>'}};
doc['WakeUpSchedule']['FindWakeUpSchedule']={syn:'Retrieves a wake up schedule for a given identifier.',lib:'YWakeUpSchedule::FindWakeUpSchedule()',pro:'YWakeUpSchedule* FindWakeUpSchedule(string <span id=pn>func</span>)',cmt:'<p>Retrieves a wake up schedule for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the wake up schedule is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWakeUpSchedule.isOnline()</tt> to test if the wake up schedule is indeed online at a given time. In case of ambiguity when looking for a wake up schedule by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the wake up schedule'},ret:'a <tt>YWakeUpSchedule</tt> object allowing you to drive the wake up schedule.'};
doc['WakeUpSchedule']['FirstWakeUpSchedule']={syn:'Starts the enumeration of wake up schedules currently accessible.',lib:'YWakeUpSchedule::FirstWakeUpSchedule()',pro:'YWakeUpSchedule* FirstWakeUpSchedule()',cmt:'<p>Starts the enumeration of wake up schedules currently accessible. Use the method <tt>YWakeUpSchedule.nextWakeUpSchedule()</tt> to iterate on next wake up schedules.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to the first wake up schedule currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WakeUpSchedule']['clearCache']={syn:'Invalidates the cache.',lib:'wakeupschedule&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the wake up schedule attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['WakeUpSchedule']['describe']={syn:'Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wakeupschedule&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the wake up schedule in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the wake up schedule (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WakeUpSchedule']['get_advertisedValue']={syn:'Returns the current value of the wake up schedule (no more than 6 characters).',lib:'wakeupschedule&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the wake up schedule (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the wake up schedule (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_errorMessage']={syn:'Returns the error message of the latest error with the wake up schedule.',lib:'wakeupschedule&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the wake up schedule object'};
doc['WakeUpSchedule']['get_errorType']={syn:'Returns the numerical error code of the latest error with the wake up schedule.',lib:'wakeupschedule&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the wake up schedule. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the wake up schedule object'};
doc['WakeUpSchedule']['get_friendlyName']={syn:'Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'wakeupschedule&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the wake up schedule in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the wake up schedule if they are defined, otherwise the serial number of the module and the hardware identifier of the wake up schedule (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the wake up schedule using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'wakeupschedule&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WakeUpSchedule']['get_functionId']={syn:'Returns the hardware identifier of the wake up schedule, without reference to the module.',lib:'wakeupschedule&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the wake up schedule, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the wake up schedule (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hardwareId']={syn:'Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'wakeupschedule&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the wake up schedule in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the wake up schedule (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the wake up schedule (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WakeUpSchedule']['get_hours']={syn:'Returns the hours scheduled for wake up.',lib:'wakeupschedule&rarr;get_hours()',pro:'int get_hours()',cmt:'<p>Returns the hours scheduled for wake up.</p>',ret:'an integer corresponding to the hours scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_HOURS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_logicalName']={syn:'Returns the logical name of the wake up schedule.',lib:'wakeupschedule&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the wake up schedule.</p>',ret:'a string corresponding to the logical name of the wake up schedule.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutes']={syn:'Returns all the minutes of each hour that are scheduled for wake up.',lib:'wakeupschedule&rarr;get_minutes()',pro:'s64 get_minutes()',cmt:'<p>Returns all the minutes of each hour that are scheduled for wake up.</p>'};
doc['WakeUpSchedule']['get_minutesA']={syn:'Returns the minutes in the 00-29 interval of each hour scheduled for wake up.',lib:'wakeupschedule&rarr;get_minutesA()',pro:'int get_minutesA()',cmt:'<p>Returns the minutes in the 00-29 interval of each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 00-29 interval of each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESA_INVALID</tt>.'};
doc['WakeUpSchedule']['get_minutesB']={syn:'Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.',lib:'wakeupschedule&rarr;get_minutesB()',pro:'int get_minutesB()',cmt:'<p>Returns the minutes in the 30-59 intervalof each hour scheduled for wake up.</p>',ret:'an integer corresponding to the minutes in the 30-59 intervalof each hour scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MINUTESB_INVALID</tt>.'};
doc['WakeUpSchedule']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'wakeupschedule&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WakeUpSchedule']['get_monthDays']={syn:'Returns the days of the month scheduled for wake up.',lib:'wakeupschedule&rarr;get_monthDays()',pro:'int get_monthDays()',cmt:'<p>Returns the days of the month scheduled for wake up.</p>',ret:'an integer corresponding to the days of the month scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MONTHDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_months']={syn:'Returns the months scheduled for wake up.',lib:'wakeupschedule&rarr;get_months()',pro:'int get_months()',cmt:'<p>Returns the months scheduled for wake up.</p>',ret:'an integer corresponding to the months scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_MONTHS_INVALID</tt>.'};
doc['WakeUpSchedule']['get_nextOccurence']={syn:'Returns the date/time (seconds) of the next wake up occurence.',lib:'wakeupschedule&rarr;get_nextOccurence()',pro:'s64 get_nextOccurence()',cmt:'<p>Returns the date/time (seconds) of the next wake up occurence.</p>',ret:'an integer corresponding to the date/time (seconds) of the next wake up occurence',ext:'On failure, throws an exception or returns <tt>Y_NEXTOCCURENCE_INVALID</tt>.'};
doc['WakeUpSchedule']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'wakeupschedule&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WakeUpSchedule']['get_weekDays']={syn:'Returns the days of the week scheduled for wake up.',lib:'wakeupschedule&rarr;get_weekDays()',pro:'int get_weekDays()',cmt:'<p>Returns the days of the week scheduled for wake up.</p>',ret:'an integer corresponding to the days of the week scheduled for wake up',ext:'On failure, throws an exception or returns <tt>Y_WEEKDAYS_INVALID</tt>.'};
doc['WakeUpSchedule']['isOnline']={syn:'Checks if the wake up schedule is currently reachable, without raising any error.',lib:'wakeupschedule&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the wake up schedule is currently reachable, without raising any error. If there is a cached value for the wake up schedule in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the wake up schedule.</p>',ret:'<tt>true</tt> if the wake up schedule can be reached, and <tt>false</tt> otherwise'};
doc['WakeUpSchedule']['load']={syn:'Preloads the wake up schedule cache with a specified validity duration.',lib:'wakeupschedule&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the wake up schedule cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'wakeupschedule&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['WakeUpSchedule']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'wakeupschedule&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['nextWakeUpSchedule']={syn:'Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>.',lib:'wakeupschedule&rarr;nextWakeUpSchedule()',pro:'YWakeUpSchedule * nextWakeUpSchedule()',cmt:'<p>Continues the enumeration of wake up schedules started using <tt>yFirstWakeUpSchedule()</tt>.</p>',ret:'a pointer to a <tt>YWakeUpSchedule</tt> object, corresponding to a wake up schedule currently online, or a <tt>null</tt> pointer if there are no more wake up schedules to enumerate.'};
doc['WakeUpSchedule']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'wakeupschedule&rarr;registerValueCallback()',pro:'int registerValueCallback(YWakeUpScheduleValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WakeUpSchedule']['set_hours']={syn:'Changes the hours when a wake up must take place.',lib:'wakeupschedule&rarr;set_hours()',pro:'int set_hours(int <span id=pn>newval</span>)',cmt:'<p>Changes the hours when a wake up must take place.</p>',par:{newval:'an integer corresponding to the hours when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_logicalName']={syn:'Changes the logical name of the wake up schedule.',lib:'wakeupschedule&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the wake up schedule. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the wake up schedule.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutes']={syn:'Changes all the minutes where a wake up must take place.',lib:'wakeupschedule&rarr;set_minutes()',pro:'int set_minutes(s64 <span id=pn>bitmap</span>)',cmt:'<p>Changes all the minutes where a wake up must take place.</p>',par:{bitmap:'Minutes 00-59 of each hour scheduled for wake up.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesA']={syn:'Changes the minutes in the 00-29 interval when a wake up must take place.',lib:'wakeupschedule&rarr;set_minutesA()',pro:'int set_minutesA(int <span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 00-29 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 00-29 interval when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_minutesB']={syn:'Changes the minutes in the 30-59 interval when a wake up must take place.',lib:'wakeupschedule&rarr;set_minutesB()',pro:'int set_minutesB(int <span id=pn>newval</span>)',cmt:'<p>Changes the minutes in the 30-59 interval when a wake up must take place.</p>',par:{newval:'an integer corresponding to the minutes in the 30-59 interval when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_monthDays']={syn:'Changes the days of the month when a wake up must take place.',lib:'wakeupschedule&rarr;set_monthDays()',pro:'int set_monthDays(int <span id=pn>newval</span>)',cmt:'<p>Changes the days of the month when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the month when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_months']={syn:'Changes the months when a wake up must take place.',lib:'wakeupschedule&rarr;set_months()',pro:'int set_months(int <span id=pn>newval</span>)',cmt:'<p>Changes the months when a wake up must take place.</p>',par:{newval:'an integer corresponding to the months when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'wakeupschedule&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WakeUpSchedule']['set_weekDays']={syn:'Changes the days of the week when a wake up must take place.',lib:'wakeupschedule&rarr;set_weekDays()',pro:'int set_weekDays(int <span id=pn>newval</span>)',cmt:'<p>Changes the days of the week when a wake up must take place.</p>',par:{newval:'an integer corresponding to the days of the week when a wake up must take place'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WakeUpSchedule']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'wakeupschedule&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: WakeUpSchedule)
//--- (generated code: GenericSensor)
doc['GenericSensor']={'':{syn:'GenericSensor function interface',inc:'#include &quot;yocto_genericsensor.h&quot;',cmt:'<p>The YGenericSensor class allows you to read and configure Yoctopuce signal transducers. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the automatic conversion between the measured signal and the corresponding engineering unit.</p>'}};
doc['GenericSensor']['FindGenericSensor']={syn:'Retrieves a generic sensor for a given identifier.',lib:'YGenericSensor::FindGenericSensor()',pro:'YGenericSensor* FindGenericSensor(string <span id=pn>func</span>)',cmt:'<p>Retrieves a generic sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the generic sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGenericSensor.isOnline()</tt> to test if the generic sensor is indeed online at a given time. In case of ambiguity when looking for a generic sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the generic sensor'},ret:'a <tt>YGenericSensor</tt> object allowing you to drive the generic sensor.'};
doc['GenericSensor']['FirstGenericSensor']={syn:'Starts the enumeration of generic sensors currently accessible.',lib:'YGenericSensor::FirstGenericSensor()',pro:'YGenericSensor* FirstGenericSensor()',cmt:'<p>Starts the enumeration of generic sensors currently accessible. Use the method <tt>YGenericSensor.nextGenericSensor()</tt> to iterate on next generic sensors.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to the first generic sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GenericSensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'genericsensor&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['clearCache']={syn:'Invalidates the cache.',lib:'genericsensor&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the generic sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['GenericSensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'genericsensor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the generic sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the generic sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GenericSensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'genericsensor&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['GenericSensor']['get_advertisedValue']={syn:'Returns the current value of the generic sensor (no more than 6 characters).',lib:'genericsensor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the generic sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the generic sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor.',lib:'genericsensor&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_currentValue']={syn:'Returns the current measured value.',lib:'genericsensor&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current measured value.</p>',ret:'a floating point number corresponding to the current measured value',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'genericsensor&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['GenericSensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the generic sensor.',lib:'genericsensor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the generic sensor object'};
doc['GenericSensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the generic sensor.',lib:'genericsensor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the generic sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the generic sensor object'};
doc['GenericSensor']['get_friendlyName']={syn:'Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'genericsensor&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the generic sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the generic sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the generic sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the generic sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GenericSensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'genericsensor&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GenericSensor']['get_functionId']={syn:'Returns the hardware identifier of the generic sensor, without reference to the module.',lib:'genericsensor&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the generic sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the generic sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GenericSensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'genericsensor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the generic sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the generic sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the generic sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GenericSensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'genericsensor&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'genericsensor&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_logicalName']={syn:'Returns the logical name of the generic sensor.',lib:'genericsensor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the generic sensor.</p>',ret:'a string corresponding to the logical name of the generic sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GenericSensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'genericsensor&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'genericsensor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GenericSensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'genericsensor&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GenericSensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'genericsensor&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GenericSensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'genericsensor&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GenericSensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'genericsensor&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['GenericSensor']['get_signalBias']={syn:'Returns the electric signal bias for zero shift adjustment.',lib:'genericsensor&rarr;get_signalBias()',pro:'double get_signalBias()',cmt:'<p>Returns the electric signal bias for zero shift adjustment. A positive bias means that the signal is over-reporting the measure, while a negative bias means that the signal is underreporting the measure.</p>',ret:'a floating point number corresponding to the electric signal bias for zero shift adjustment',ext:'On failure, throws an exception or returns <tt>Y_SIGNALBIAS_INVALID</tt>.'};
doc['GenericSensor']['get_signalRange']={syn:'Returns the electric signal range used by the sensor.',lib:'genericsensor&rarr;get_signalRange()',pro:'string get_signalRange()',cmt:'<p>Returns the electric signal range used by the sensor.</p>',ret:'a string corresponding to the electric signal range used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALRANGE_INVALID</tt>.'};
doc['GenericSensor']['get_signalSampling']={syn:'Returns the electric signal sampling method to use.',lib:'genericsensor&rarr;get_signalSampling()',pro:'Y_SIGNALSAMPLING_enum get_signalSampling()',cmt:'<p>Returns the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',ret:'a value among <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt> and <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> corresponding to the electric signal sampling method to use',ext:'On failure, throws an exception or returns <tt>Y_SIGNALSAMPLING_INVALID</tt>.'};
doc['GenericSensor']['get_signalUnit']={syn:'Returns the measuring unit of the electrical signal used by the sensor.',lib:'genericsensor&rarr;get_signalUnit()',pro:'string get_signalUnit()',cmt:'<p>Returns the measuring unit of the electrical signal used by the sensor.</p>',ret:'a string corresponding to the measuring unit of the electrical signal used by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALUNIT_INVALID</tt>.'};
doc['GenericSensor']['get_signalValue']={syn:'Returns the current value of the electrical signal measured by the sensor.',lib:'genericsensor&rarr;get_signalValue()',pro:'double get_signalValue()',cmt:'<p>Returns the current value of the electrical signal measured by the sensor.</p>',ret:'a floating point number corresponding to the current value of the electrical signal measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['GenericSensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'genericsensor&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GenericSensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'genericsensor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GenericSensor']['get_valueRange']={syn:'Returns the physical value range measured by the sensor.',lib:'genericsensor&rarr;get_valueRange()',pro:'string get_valueRange()',cmt:'<p>Returns the physical value range measured by the sensor.</p>',ret:'a string corresponding to the physical value range measured by the sensor',ext:'On failure, throws an exception or returns <tt>Y_VALUERANGE_INVALID</tt>.'};
doc['GenericSensor']['isOnline']={syn:'Checks if the generic sensor is currently reachable, without raising any error.',lib:'genericsensor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the generic sensor is currently reachable, without raising any error. If there is a cached value for the generic sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the generic sensor.</p>',ret:'<tt>true</tt> if the generic sensor can be reached, and <tt>false</tt> otherwise'};
doc['GenericSensor']['load']={syn:'Preloads the generic sensor cache with a specified validity duration.',lib:'genericsensor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the generic sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'genericsensor&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['GenericSensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'genericsensor&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'genericsensor&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['nextGenericSensor']={syn:'Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.',lib:'genericsensor&rarr;nextGenericSensor()',pro:'YGenericSensor * nextGenericSensor()',cmt:'<p>Continues the enumeration of generic sensors started using <tt>yFirstGenericSensor()</tt>.</p>',ret:'a pointer to a <tt>YGenericSensor</tt> object, corresponding to a generic sensor currently online, or a <tt>null</tt> pointer if there are no more generic sensors to enumerate.'};
doc['GenericSensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'genericsensor&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YGenericSensorTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['GenericSensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'genericsensor&rarr;registerValueCallback()',pro:'int registerValueCallback(YGenericSensorValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GenericSensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'genericsensor&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'genericsensor&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'genericsensor&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_logicalName']={syn:'Changes the logical name of the generic sensor.',lib:'genericsensor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the generic sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the generic sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'genericsensor&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'genericsensor&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'genericsensor&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalBias']={syn:'Changes the electric signal bias for zero shift adjustment.',lib:'genericsensor&rarr;set_signalBias()',pro:'int set_signalBias(double <span id=pn>newval</span>)',cmt:'<p>Changes the electric signal bias for zero shift adjustment. If your electric signal reads positif when it should be zero, setup a positive signalBias of the same value to fix the zero shift.</p>',par:{newval:'a floating point number corresponding to the electric signal bias for zero shift adjustment'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalRange']={syn:'Changes the electric signal range used by the sensor.',lib:'genericsensor&rarr;set_signalRange()',pro:'int set_signalRange(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the electric signal range used by the sensor. Default value is \x22-999999.999...999999.999\x22.</p>',par:{newval:'a string corresponding to the electric signal range used by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_signalSampling']={syn:'Changes the electric signal sampling method to use.',lib:'genericsensor&rarr;set_signalSampling()',pro:'int set_signalSampling(Y_SIGNALSAMPLING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the electric signal sampling method to use. The <tt>HIGH_RATE</tt> method uses the highest sampling frequency, without any filtering. The <tt>HIGH_RATE_FILTERED</tt> method adds a windowed 7-sample median filter. The <tt>LOW_NOISE</tt> method uses a reduced acquisition frequency to reduce noise. The <tt>LOW_NOISE_FILTERED</tt> method combines a reduced frequency with the median filter to get measures as stable as possible when working on a noisy signal.</p>',par:{newval:'a value among <tt>Y_SIGNALSAMPLING_HIGH_RATE</tt>, <tt>Y_SIGNALSAMPLING_HIGH_RATE_FILTERED</tt>, <tt>Y_SIGNALSAMPLING_LOW_NOISE</tt> and <tt>Y_SIGNALSAMPLING_LOW_NOISE_FILTERED</tt> corresponding to the electric signal sampling method to use'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_unit']={syn:'Changes the measuring unit for the measured value.',lib:'genericsensor&rarr;set_unit()',pro:'int set_unit(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured value. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the measured value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'genericsensor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GenericSensor']['set_valueRange']={syn:'Changes the physical value range measured by the sensor.',lib:'genericsensor&rarr;set_valueRange()',pro:'int set_valueRange(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the physical value range measured by the sensor. As a side effect, the range modification may automatically modify the display resolution. Default value is \x22-999999.999...999999.999\x22.</p>',par:{newval:'a string corresponding to the physical value range measured by the sensor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'genericsensor&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GenericSensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'genericsensor&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GenericSensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'genericsensor&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GenericSensor']['zeroAdjust']={syn:'Adjusts the signal bias so that the current signal value is need precisely as zero.',lib:'genericsensor&rarr;zeroAdjust()',pro:'int zeroAdjust()',cmt:'<p>Adjusts the signal bias so that the current signal value is need precisely as zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: GenericSensor)
//--- (generated code: DigitalIO)
doc['DigitalIO']={'':{syn:'Digital IO function interface',inc:'#include &quot;yocto_digitalio.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to switch the state of each bit of the I/O port. You can switch all bits at once, or one by one. The library can also automatically generate short pulses of a determined duration. Electrical behavior of each I/O can be modified (open drain and reverse polarity).</p>'}};
doc['DigitalIO']['FindDigitalIO']={syn:'Retrieves a digital IO port for a given identifier.',lib:'YDigitalIO::FindDigitalIO()',pro:'YDigitalIO* FindDigitalIO(string <span id=pn>func</span>)',cmt:'<p>Retrieves a digital IO port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the digital IO port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDigitalIO.isOnline()</tt> to test if the digital IO port is indeed online at a given time. In case of ambiguity when looking for a digital IO port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the digital IO port'},ret:'a <tt>YDigitalIO</tt> object allowing you to drive the digital IO port.'};
doc['DigitalIO']['FirstDigitalIO']={syn:'Starts the enumeration of digital IO ports currently accessible.',lib:'YDigitalIO::FirstDigitalIO()',pro:'YDigitalIO* FirstDigitalIO()',cmt:'<p>Starts the enumeration of digital IO ports currently accessible. Use the method <tt>YDigitalIO.nextDigitalIO()</tt> to iterate on next digital IO ports.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to the first digital IO port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DigitalIO']['clearCache']={syn:'Invalidates the cache.',lib:'digitalio&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the digital IO port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DigitalIO']['delayedPulse']={syn:'Schedules a pulse on a single bit for a specified duration.',lib:'digitalio&rarr;delayedPulse()',pro:'int delayedPulse(int <span id=pn>bitno</span>, int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Schedules a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_delay:'waiting time before the pulse, in milliseconds',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['describe']={syn:'Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'digitalio&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the digital IO port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the digital IO port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DigitalIO']['get_advertisedValue']={syn:'Returns the current value of the digital IO port (no more than 6 characters).',lib:'digitalio&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the digital IO port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the digital IO port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DigitalIO']['get_bitDirection']={syn:'Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1 an output).',lib:'digitalio&rarr;get_bitDirection()',pro:'int get_bitDirection(int <span id=pn>bitno</span>)',cmt:'<p>Returns the direction of a single bit from the I/O port (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitOpenDrain']={syn:'Returns the type of electrical interface of a single bit from the I/O port.',lib:'digitalio&rarr;get_bitOpenDrain()',pro:'int get_bitOpenDrain(int <span id=pn>bitno</span>)',cmt:'<p>Returns the type of electrical interface of a single bit from the I/O port. (0 means the bit is an input, 1 an output).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'0 means the a bit is a regular input/output, 1 means the bit is an open-drain (open-collector) input/output.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitPolarity']={syn:'Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).',lib:'digitalio&rarr;get_bitPolarity()',pro:'int get_bitPolarity(int <span id=pn>bitno</span>)',cmt:'<p>Returns the polarity of a single bit from the I/O port (0 means the I/O works in regular mode, 1 means the I/O works in reverse mode).</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_bitState']={syn:'Returns the state of a single bit of the I/O port.',lib:'digitalio&rarr;get_bitState()',pro:'int get_bitState(int <span id=pn>bitno</span>)',cmt:'<p>Returns the state of a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'the bit state (0 or 1)',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['get_errorMessage']={syn:'Returns the error message of the latest error with the digital IO port.',lib:'digitalio&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the digital IO port object'};
doc['DigitalIO']['get_errorType']={syn:'Returns the numerical error code of the latest error with the digital IO port.',lib:'digitalio&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the digital IO port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the digital IO port object'};
doc['DigitalIO']['get_friendlyName']={syn:'Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'digitalio&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the digital IO port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the digital IO port if they are defined, otherwise the serial number of the module and the hardware identifier of the digital IO port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the digital IO port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DigitalIO']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'digitalio&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DigitalIO']['get_functionId']={syn:'Returns the hardware identifier of the digital IO port, without reference to the module.',lib:'digitalio&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the digital IO port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the digital IO port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DigitalIO']['get_hardwareId']={syn:'Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'digitalio&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the digital IO port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the digital IO port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the digital IO port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DigitalIO']['get_logicalName']={syn:'Returns the logical name of the digital IO port.',lib:'digitalio&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the digital IO port.</p>',ret:'a string corresponding to the logical name of the digital IO port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DigitalIO']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'digitalio&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DigitalIO']['get_outputVoltage']={syn:'Returns the voltage source used to drive output bits.',lib:'digitalio&rarr;get_outputVoltage()',pro:'Y_OUTPUTVOLTAGE_enum get_outputVoltage()',cmt:'<p>Returns the voltage source used to drive output bits.</p>',ret:'a value among <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> and <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits',ext:'On failure, throws an exception or returns <tt>Y_OUTPUTVOLTAGE_INVALID</tt>.'};
doc['DigitalIO']['get_portDiags']={syn:'Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only).',lib:'digitalio&rarr;get_portDiags()',pro:'int get_portDiags()',cmt:'<p>Returns the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only). Bit 0 indicates a shortcut on output 0, etc. Bit 8 indicates a power failure, and bit 9 signals overheating (overcurrent). During normal use, all diagnostic bits should stay clear.</p>',ret:'an integer corresponding to the port state diagnostics (Yocto-IO and Yocto-MaxiIO-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_PORTDIAGS_INVALID</tt>.'};
doc['DigitalIO']['get_portDirection']={syn:'Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'digitalio&rarr;get_portDirection()',pro:'int get_portDirection()',cmt:'<p>Returns the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.</p>',ret:'an integer corresponding to the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output',ext:'On failure, throws an exception or returns <tt>Y_PORTDIRECTION_INVALID</tt>.'};
doc['DigitalIO']['get_portOpenDrain']={syn:'Returns the electrical interface for each bit of the port.',lib:'digitalio&rarr;get_portOpenDrain()',pro:'int get_portOpenDrain()',cmt:'<p>Returns the electrical interface for each bit of the port. For each bit set to 0 the matching I/O works in the regular, intuitive way, for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the electrical interface for each bit of the port',ext:'On failure, throws an exception or returns <tt>Y_PORTOPENDRAIN_INVALID</tt>.'};
doc['DigitalIO']['get_portPolarity']={syn:'Returns the polarity of all the bits of the port.',lib:'digitalio&rarr;get_portPolarity()',pro:'int get_portPolarity()',cmt:'<p>Returns the polarity of all the bits of the port. For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.</p>',ret:'an integer corresponding to the polarity of all the bits of the port',ext:'On failure, throws an exception or returns <tt>Y_PORTPOLARITY_INVALID</tt>.'};
doc['DigitalIO']['get_portSize']={syn:'Returns the number of bits implemented in the I/O port.',lib:'digitalio&rarr;get_portSize()',pro:'int get_portSize()',cmt:'<p>Returns the number of bits implemented in the I/O port.</p>',ret:'an integer corresponding to the number of bits implemented in the I/O port',ext:'On failure, throws an exception or returns <tt>Y_PORTSIZE_INVALID</tt>.'};
doc['DigitalIO']['get_portState']={syn:'Returns the digital IO port state: bit 0 represents input 0, and so on.',lib:'digitalio&rarr;get_portState()',pro:'int get_portState()',cmt:'<p>Returns the digital IO port state: bit 0 represents input 0, and so on.</p>',ret:'an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on',ext:'On failure, throws an exception or returns <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['DigitalIO']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'digitalio&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DigitalIO']['isOnline']={syn:'Checks if the digital IO port is currently reachable, without raising any error.',lib:'digitalio&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the digital IO port is currently reachable, without raising any error. If there is a cached value for the digital IO port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the digital IO port.</p>',ret:'<tt>true</tt> if the digital IO port can be reached, and <tt>false</tt> otherwise'};
doc['DigitalIO']['load']={syn:'Preloads the digital IO port cache with a specified validity duration.',lib:'digitalio&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the digital IO port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'digitalio&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DigitalIO']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'digitalio&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['nextDigitalIO']={syn:'Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>.',lib:'digitalio&rarr;nextDigitalIO()',pro:'YDigitalIO * nextDigitalIO()',cmt:'<p>Continues the enumeration of digital IO ports started using <tt>yFirstDigitalIO()</tt>.</p>',ret:'a pointer to a <tt>YDigitalIO</tt> object, corresponding to a digital IO port currently online, or a <tt>null</tt> pointer if there are no more digital IO ports to enumerate.'};
doc['DigitalIO']['pulse']={syn:'Triggers a pulse on a single bit for a specified duration.',lib:'digitalio&rarr;pulse()',pro:'int pulse(int <span id=pn>bitno</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Triggers a pulse on a single bit for a specified duration. The specified bit will be turned to 1, and then back to 0 after the given duration.</p>',par:{bitno:'the bit number; lowest bit has index 0',ms_duration:'desired pulse duration in milliseconds. Be aware that the device time resolution is not guaranteed up to the millisecond.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'digitalio&rarr;registerValueCallback()',pro:'int registerValueCallback(YDigitalIOValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DigitalIO']['set_bitDirection']={syn:'Changes the direction of a single bit from the I/O port.',lib:'digitalio&rarr;set_bitDirection()',pro:'int set_bitDirection(int <span id=pn>bitno</span>, int <span id=pn>bitdirection</span>)',cmt:'<p>Changes the direction of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitdirection:'direction to set, 0 makes the bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitOpenDrain']={syn:'Changes the electrical interface of a single bit from the I/O port.',lib:'digitalio&rarr;set_bitOpenDrain()',pro:'int set_bitOpenDrain(int <span id=pn>bitno</span>, int <span id=pn>opendrain</span>)',cmt:'<p>Changes the electrical interface of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',opendrain:'0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitPolarity']={syn:'Changes the polarity of a single bit from the I/O port.',lib:'digitalio&rarr;set_bitPolarity()',pro:'int set_bitPolarity(int <span id=pn>bitno</span>, int <span id=pn>bitpolarity</span>)',cmt:'<p>Changes the polarity of a single bit from the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0.',bitpolarity:'polarity to set, 0 makes the I/O work in regular mode, 1 makes the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_bitState']={syn:'Sets a single bit of the I/O port.',lib:'digitalio&rarr;set_bitState()',pro:'int set_bitState(int <span id=pn>bitno</span>, int <span id=pn>bitstate</span>)',cmt:'<p>Sets a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0',bitstate:'the state of the bit (1 or 0)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_logicalName']={syn:'Changes the logical name of the digital IO port.',lib:'digitalio&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the digital IO port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the digital IO port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_outputVoltage']={syn:'Changes the voltage source used to drive output bits.',lib:'digitalio&rarr;set_outputVoltage()',pro:'int set_outputVoltage(Y_OUTPUTVOLTAGE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the voltage source used to drive output bits. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'a value among <tt>Y_OUTPUTVOLTAGE_USB_5V</tt>, <tt>Y_OUTPUTVOLTAGE_USB_3V</tt> and <tt>Y_OUTPUTVOLTAGE_EXT_V</tt> corresponding to the voltage source used to drive output bits'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portDirection']={syn:'Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output.',lib:'digitalio&rarr;set_portDirection()',pro:'int set_portDirection(int <span id=pn>newval</span>)',cmt:'<p>Changes the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the IO direction of all bits of the port: 0 makes a bit an input, 1 makes it an output'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portOpenDrain']={syn:'Changes the electrical interface for each bit of the port.',lib:'digitalio&rarr;set_portOpenDrain()',pro:'int set_portOpenDrain(int <span id=pn>newval</span>)',cmt:'<p>Changes the electrical interface for each bit of the port. 0 makes a bit a regular input/output, 1 makes it an open-drain (open-collector) input/output. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting is kept after a reboot.</p>',par:{newval:'an integer corresponding to the electrical interface for each bit of the port'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portPolarity']={syn:'Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode.',lib:'digitalio&rarr;set_portPolarity()',pro:'int set_portPolarity(int <span id=pn>newval</span>)',cmt:'<p>Changes the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode. Remember to call the <tt>saveToFlash()</tt> method to make sure the setting will be kept after a reboot.</p>',par:{newval:'an integer corresponding to the polarity of all the bits of the port: For each bit set to 0, the matching I/O works the regular, intuitive way; for each bit set to 1, the I/O works in reverse mode'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_portState']={syn:'Changes the digital IO port state: bit 0 represents input 0, and so on.',lib:'digitalio&rarr;set_portState()',pro:'int set_portState(int <span id=pn>newval</span>)',cmt:'<p>Changes the digital IO port state: bit 0 represents input 0, and so on. This function has no effect on bits configured as input in <tt>portDirection</tt>.</p>',par:{newval:'an integer corresponding to the digital IO port state: bit 0 represents input 0, and so on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'digitalio&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DigitalIO']['toggle_bitState']={syn:'Reverts a single bit of the I/O port.',lib:'digitalio&rarr;toggle_bitState()',pro:'int toggle_bitState(int <span id=pn>bitno</span>)',cmt:'<p>Reverts a single bit of the I/O port.</p>',par:{bitno:'the bit number; lowest bit has index 0'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DigitalIO']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'digitalio&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DigitalIO)
//--- (generated code: OsControl)
doc['OsControl']={'':{syn:'OS control',inc:'#include &quot;yocto_oscontrol.h&quot;',cmt:'<p>The OScontrol object allows some control over the operating system running a VirtualHub. OsControl is available on the VirtualHub software only. This feature must be activated at the VirtualHub start up with -o option.</p>'}};
doc['OsControl']['FindOsControl']={syn:'Retrieves OS control for a given identifier.',lib:'YOsControl::FindOsControl()',pro:'YOsControl* FindOsControl(string <span id=pn>func</span>)',cmt:'<p>Retrieves OS control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the OS control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YOsControl.isOnline()</tt> to test if the OS control is indeed online at a given time. In case of ambiguity when looking for OS control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the OS control'},ret:'a <tt>YOsControl</tt> object allowing you to drive the OS control.'};
doc['OsControl']['FirstOsControl']={syn:'Starts the enumeration of OS control currently accessible.',lib:'YOsControl::FirstOsControl()',pro:'YOsControl* FirstOsControl()',cmt:'<p>Starts the enumeration of OS control currently accessible. Use the method <tt>YOsControl.nextOsControl()</tt> to iterate on next OS control.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to the first OS control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['OsControl']['clearCache']={syn:'Invalidates the cache.',lib:'oscontrol&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the OS control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['OsControl']['describe']={syn:'Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'oscontrol&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the OS control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the OS control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['OsControl']['get_advertisedValue']={syn:'Returns the current value of the OS control (no more than 6 characters).',lib:'oscontrol&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the OS control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the OS control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['OsControl']['get_errorMessage']={syn:'Returns the error message of the latest error with the OS control.',lib:'oscontrol&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the OS control object'};
doc['OsControl']['get_errorType']={syn:'Returns the numerical error code of the latest error with the OS control.',lib:'oscontrol&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the OS control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the OS control object'};
doc['OsControl']['get_friendlyName']={syn:'Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'oscontrol&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the OS control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the OS control if they are defined, otherwise the serial number of the module and the hardware identifier of the OS control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the OS control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['OsControl']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'oscontrol&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['OsControl']['get_functionId']={syn:'Returns the hardware identifier of the OS control, without reference to the module.',lib:'oscontrol&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the OS control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the OS control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['OsControl']['get_hardwareId']={syn:'Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'oscontrol&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the OS control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the OS control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the OS control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['OsControl']['get_logicalName']={syn:'Returns the logical name of the OS control.',lib:'oscontrol&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the OS control.</p>',ret:'a string corresponding to the logical name of the OS control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['OsControl']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'oscontrol&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['OsControl']['get_shutdownCountdown']={syn:'Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.',lib:'oscontrol&rarr;get_shutdownCountdown()',pro:'int get_shutdownCountdown()',cmt:'<p>Returns the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled.</p>',ret:'an integer corresponding to the remaining number of seconds before the OS shutdown, or zero when no shutdown has been scheduled',ext:'On failure, throws an exception or returns <tt>Y_SHUTDOWNCOUNTDOWN_INVALID</tt>.'};
doc['OsControl']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'oscontrol&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['OsControl']['isOnline']={syn:'Checks if the OS control is currently reachable, without raising any error.',lib:'oscontrol&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the OS control is currently reachable, without raising any error. If there is a cached value for the OS control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the OS control.</p>',ret:'<tt>true</tt> if the OS control can be reached, and <tt>false</tt> otherwise'};
doc['OsControl']['load']={syn:'Preloads the OS control cache with a specified validity duration.',lib:'oscontrol&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the OS control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'oscontrol&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['OsControl']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'oscontrol&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['nextOsControl']={syn:'Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.',lib:'oscontrol&rarr;nextOsControl()',pro:'YOsControl * nextOsControl()',cmt:'<p>Continues the enumeration of OS control started using <tt>yFirstOsControl()</tt>.</p>',ret:'a pointer to a <tt>YOsControl</tt> object, corresponding to OS control currently online, or a <tt>null</tt> pointer if there are no more OS control to enumerate.'};
doc['OsControl']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'oscontrol&rarr;registerValueCallback()',pro:'int registerValueCallback(YOsControlValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['OsControl']['set_logicalName']={syn:'Changes the logical name of the OS control.',lib:'oscontrol&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the OS control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the OS control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'oscontrol&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['OsControl']['shutdown']={syn:'Schedules an OS shutdown after a given number of seconds.',lib:'oscontrol&rarr;shutdown()',pro:'int shutdown(int <span id=pn>secBeforeShutDown</span>)',cmt:'<p>Schedules an OS shutdown after a given number of seconds.</p>',par:{secBeforeShutDown:'number of seconds before shutdown'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['OsControl']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'oscontrol&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: OsControl)
//--- (generated code: DataSet)
doc['DataSet']={'':{syn:'Recorded data sequence',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>YDataSet objects make it possible to retrieve a set of recorded measures for a given sensor and a specified time interval. They can be used to load data points with a progress report. When the YDataSet object is instantiated by the <tt>get_recordedData()</tt> function, no data is yet loaded from the module. It is only when the <tt>loadMore()</tt> method is called over and over than data will be effectively loaded from the dataLogger.</p><p> A preview of available measures is available using the function <tt>get_preview()</tt> as soon as <tt>loadMore()</tt> has been called once. Measures themselves are available using function <tt>get_measures()</tt> when loaded by subsequent calls to <tt>loadMore()</tt>.</p><p> This class can only be used on devices that use a recent firmware, as YDataSet objects are not supported by firmwares older than version 13000.</p>'}};
doc['DataSet']['get_endTimeUTC']={syn:'Returns the end time of the dataset, relative to the Jan 1, 1970.',lib:'dataset&rarr;get_endTimeUTC()',pro:'s64 get_endTimeUTC()',cmt:'<p>Returns the end time of the dataset, relative to the Jan 1, 1970. When the YDataSet is created, the end time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the end time is updated to reflect the timestamp of the last measure actually found in the dataLogger within the specified range.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the end of this data set (i.e. Unix time representation of the absolute time).'};
doc['DataSet']['get_functionId']={syn:'Returns the hardware identifier of the function that performed the measure, without reference to the module.',lib:'dataset&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the function that performed the measure, without reference to the module. For example <tt>temperature1</tt>.</p>',ret:'a string that identifies the function (ex: <tt>temperature1</tt>)'};
doc['DataSet']['get_hardwareId']={syn:'Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'dataset&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the function who performed the measures, in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the function (for example <tt>THRMCPL1-123456.temperature1</tt>)</p>',ret:'a string that uniquely identifies the function (ex: <tt>THRMCPL1-123456.temperature1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataSet']['get_measures']={syn:'Returns all measured values currently available for this DataSet, as a list of YMeasure objects.',lib:'dataset&rarr;get_measures()',pro:'vector&lt;YMeasure&gt; get_measures()',cmt:'<p>Returns all measured values currently available for this DataSet, as a list of YMeasure objects. Each item includes: - the start of the measure time interval - the end of the measure time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> Before calling this method, you should call <tt>loadMore()</tt> to load data from the device. You may have to call loadMore() several time until all rows are loaded, but you can start looking at available data rows before the load is complete.</p><p> The oldest measures are always loaded first, and the most recent measures will be loaded last. As a result, timestamps are normally sorted in ascending order within the measure table, unless there was an unexpected adjustment of the datalogger UTC clock.</p>',ret:'a table of records, where each record depicts the measured value for a given time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_measuresAt']={syn:'Returns the detailed set of measures for the time interval corresponding to a given condensed measures previously returned by <tt>get_preview()</tt>.',lib:'dataset&rarr;get_measuresAt()',pro:'vector&lt;YMeasure&gt; get_measuresAt(YMeasure <span id=pn>measure</span>)',cmt:'<p>Returns the detailed set of measures for the time interval corresponding to a given condensed measures previously returned by <tt>get_preview()</tt>. The result is provided as a list of YMeasure objects.</p>',par:{measure:'condensed measure from the list previously returned by <tt>get_preview()</tt>.'},ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_preview']={syn:'Returns a condensed version of the measures that can retrieved in this YDataSet, as a list of YMeasure objects.',lib:'dataset&rarr;get_preview()',pro:'vector&lt;YMeasure&gt; get_preview()',cmt:'<p>Returns a condensed version of the measures that can retrieved in this YDataSet, as a list of YMeasure objects. Each item includes: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This preview is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'a table of records, where each record depicts the measured values during a time interval',ext:'On failure, throws an exception or returns an empty array.'};
doc['DataSet']['get_progress']={syn:'Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100.',lib:'dataset&rarr;get_progress()',pro:'int get_progress()',cmt:'<p>Returns the progress of the downloads of the measures from the data logger, on a scale from 0 to 100. When the object is instantiated by <tt>get_dataSet</tt>, the progress is zero. Each time <tt>loadMore()</tt> is invoked, the progress is updated, to reach the value 100 only once all measures have been loaded.</p>',ret:'an integer in the range 0 to 100 (percentage of completion).'};
doc['DataSet']['get_startTimeUTC']={syn:'Returns the start time of the dataset, relative to the Jan 1, 1970.',lib:'dataset&rarr;get_startTimeUTC()',pro:'s64 get_startTimeUTC()',cmt:'<p>Returns the start time of the dataset, relative to the Jan 1, 1970. When the YDataSet is created, the start time is the value passed in parameter to the <tt>get_dataSet()</tt> function. After the very first call to <tt>loadMore()</tt>, the start time is updated to reflect the timestamp of the first measure actually found in the dataLogger within the specified range.</p>',ret:'an unsigned number corresponding to the number of seconds between the Jan 1, 1970 and the beginning of this data set (i.e. Unix time representation of the absolute time).'};
doc['DataSet']['get_summary']={syn:'Returns an YMeasure object which summarizes the whole DataSet.',lib:'dataset&rarr;get_summary()',pro:'YMeasure get_summary()',cmt:'<p>Returns an YMeasure object which summarizes the whole DataSet. In includes the following information: - the start of a time interval - the end of a time interval - the minimal value observed during the time interval - the average value observed during the time interval - the maximal value observed during the time interval</p><p> This summary is available as soon as <tt>loadMore()</tt> has been called for the first time.</p>',ret:'an YMeasure object'};
doc['DataSet']['get_unit']={syn:'Returns the measuring unit for the measured value.',lib:'dataset&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measured value.</p>',ret:'a string that represents a physical unit.',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['DataSet']['loadMore']={syn:'Loads the the next block of measures from the dataLogger, and updates the progress indicator.',lib:'dataset&rarr;loadMore()',pro:'int loadMore()',cmt:'<p>Loads the the next block of measures from the dataLogger, and updates the progress indicator.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DataSet)
//--- (generated code: Measure)
doc['Measure']={'':{syn:'Measured value',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>YMeasure objects are used within the API to represent a value measured at a specified time. These objects are used in particular in conjunction with the YDataSet class.</p>'}};
doc['Measure']['get_averageValue']={syn:'Returns the average value observed during the time interval covered by this measure.',lib:'measure&rarr;get_averageValue()',pro:'double get_averageValue()',cmt:'<p>Returns the average value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the average value observed.'};
doc['Measure']['get_endTimeUTC']={syn:'Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'measure&rarr;get_endTimeUTC()',pro:'double get_endTimeUTC()',cmt:'<p>Returns the end time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher than 1 sample per second, the timestamp may have a fractional part.</p>',ret:'an floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the end of this measure.'};
doc['Measure']['get_maxValue']={syn:'Returns the largest value observed during the time interval covered by this measure.',lib:'measure&rarr;get_maxValue()',pro:'double get_maxValue()',cmt:'<p>Returns the largest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the largest value observed.'};
doc['Measure']['get_minValue']={syn:'Returns the smallest value observed during the time interval covered by this measure.',lib:'measure&rarr;get_minValue()',pro:'double get_minValue()',cmt:'<p>Returns the smallest value observed during the time interval covered by this measure.</p>',ret:'a floating-point number corresponding to the smallest value observed.'};
doc['Measure']['get_startTimeUTC']={syn:'Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp).',lib:'measure&rarr;get_startTimeUTC()',pro:'double get_startTimeUTC()',cmt:'<p>Returns the start time of the measure, relative to the Jan 1, 1970 UTC (Unix timestamp). When the recording rate is higher then 1 sample per second, the timestamp may have a fractional part.</p>',ret:'an floating point number corresponding to the number of seconds between the Jan 1, 1970 UTC and the beginning of this measure.'};
//--- (end of generated code: Measure)
//--- (generated code: Sensor)
doc['Sensor']={'':{syn:'Sensor function interface',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Sensor']['FindSensor']={syn:'Retrieves a sensor for a given identifier.',lib:'YSensor::FindSensor()',pro:'YSensor* FindSensor(string <span id=pn>func</span>)',cmt:'<p>Retrieves a sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSensor.isOnline()</tt> to test if the sensor is indeed online at a given time. In case of ambiguity when looking for a sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the sensor'},ret:'a <tt>YSensor</tt> object allowing you to drive the sensor.'};
doc['Sensor']['FirstSensor']={syn:'Starts the enumeration of sensors currently accessible.',lib:'YSensor::FirstSensor()',pro:'YSensor* FirstSensor()',cmt:'<p>Starts the enumeration of sensors currently accessible. Use the method <tt>YSensor.nextSensor()</tt> to iterate on next sensors.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to the first sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Sensor']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'sensor&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['clearCache']={syn:'Invalidates the cache.',lib:'sensor&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Sensor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'sensor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Sensor']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'sensor&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Sensor']['get_advertisedValue']={syn:'Returns the current value of the sensor (no more than 6 characters).',lib:'sensor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'sensor&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Sensor']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'sensor&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Sensor']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'sensor&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Sensor']['get_errorMessage']={syn:'Returns the error message of the latest error with the sensor.',lib:'sensor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the sensor object'};
doc['Sensor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the sensor.',lib:'sensor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the sensor object'};
doc['Sensor']['get_friendlyName']={syn:'Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'sensor&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Sensor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'sensor&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Sensor']['get_functionId']={syn:'Returns the hardware identifier of the sensor, without reference to the module.',lib:'sensor&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Sensor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'sensor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Sensor']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'sensor&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'sensor&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_logicalName']={syn:'Returns the logical name of the sensor.',lib:'sensor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the sensor.</p>',ret:'a string corresponding to the logical name of the sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Sensor']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'sensor&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Sensor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'sensor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Sensor']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'sensor&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Sensor']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'sensor&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Sensor']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'sensor&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Sensor']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'sensor&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Sensor']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'sensor&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Sensor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'sensor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Sensor']['isOnline']={syn:'Checks if the sensor is currently reachable, without raising any error.',lib:'sensor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the sensor is currently reachable, without raising any error. If there is a cached value for the sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the sensor.</p>',ret:'<tt>true</tt> if the sensor can be reached, and <tt>false</tt> otherwise'};
doc['Sensor']['isSensorReady']={syn:'Checks if the sensor is currently able to provide an up-to-date measure.',lib:'sensor&rarr;isSensorReady()',pro:'bool isSensorReady()',cmt:'<p>Checks if the sensor is currently able to provide an up-to-date measure. Returns false if the device is unreachable, or if the sensor does not have a current measure to transmit. No exception is raised if there is an error while trying to contact the device hosting $THEFUNCTION$.</p>',ret:'<tt>true</tt> if the sensor can provide an up-to-date measure, and <tt>false</tt> otherwise'};
doc['Sensor']['load']={syn:'Preloads the sensor cache with a specified validity duration.',lib:'sensor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'sensor&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Sensor']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'sensor&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'sensor&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['nextSensor']={syn:'Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>.',lib:'sensor&rarr;nextSensor()',pro:'YSensor * nextSensor()',cmt:'<p>Continues the enumeration of sensors started using <tt>yFirstSensor()</tt>.</p>',ret:'a pointer to a <tt>YSensor</tt> object, corresponding to a sensor currently online, or a <tt>null</tt> pointer if there are no more sensors to enumerate.'};
doc['Sensor']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'sensor&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YSensorTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Sensor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'sensor&rarr;registerValueCallback()',pro:'int registerValueCallback(YSensorValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Sensor']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'sensor&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'sensor&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'sensor&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_logicalName']={syn:'Changes the logical name of the sensor.',lib:'sensor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'sensor&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'sensor&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'sensor&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Sensor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'sensor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Sensor']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'sensor&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Sensor']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'sensor&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Sensor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'sensor&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Sensor)
//--- (generated code: Accelerometer)
doc['Accelerometer']={'':{syn:'Accelerometer function interface',inc:'#include &quot;yocto_accelerometer.h&quot;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Accelerometer']['FindAccelerometer']={syn:'Retrieves an accelerometer for a given identifier.',lib:'YAccelerometer::FindAccelerometer()',pro:'YAccelerometer* FindAccelerometer(string <span id=pn>func</span>)',cmt:'<p>Retrieves an accelerometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the accelerometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAccelerometer.isOnline()</tt> to test if the accelerometer is indeed online at a given time. In case of ambiguity when looking for an accelerometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the accelerometer'},ret:'a <tt>YAccelerometer</tt> object allowing you to drive the accelerometer.'};
doc['Accelerometer']['FirstAccelerometer']={syn:'Starts the enumeration of accelerometers currently accessible.',lib:'YAccelerometer::FirstAccelerometer()',pro:'YAccelerometer* FirstAccelerometer()',cmt:'<p>Starts the enumeration of accelerometers currently accessible. Use the method <tt>YAccelerometer.nextAccelerometer()</tt> to iterate on next accelerometers.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to the first accelerometer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Accelerometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'accelerometer&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['clearCache']={syn:'Invalidates the cache.',lib:'accelerometer&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the accelerometer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Accelerometer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'accelerometer&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the accelerometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the accelerometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Accelerometer']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'accelerometer&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Accelerometer']['get_advertisedValue']={syn:'Returns the current value of the accelerometer (no more than 6 characters).',lib:'accelerometer&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the accelerometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the accelerometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'accelerometer&rarr;get_bandwidth()',pro:'int get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Accelerometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.',lib:'accelerometer&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_currentValue']={syn:'Returns the current value of the acceleration, in g, as a floating point number.',lib:'accelerometer&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the acceleration, in g, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the acceleration, in g, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'accelerometer&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Accelerometer']['get_errorMessage']={syn:'Returns the error message of the latest error with the accelerometer.',lib:'accelerometer&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the accelerometer object'};
doc['Accelerometer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the accelerometer.',lib:'accelerometer&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the accelerometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the accelerometer object'};
doc['Accelerometer']['get_friendlyName']={syn:'Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'accelerometer&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the accelerometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the accelerometer if they are defined, otherwise the serial number of the module and the hardware identifier of the accelerometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the accelerometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Accelerometer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'accelerometer&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Accelerometer']['get_functionId']={syn:'Returns the hardware identifier of the accelerometer, without reference to the module.',lib:'accelerometer&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the accelerometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the accelerometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Accelerometer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'accelerometer&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the accelerometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the accelerometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the accelerometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Accelerometer']['get_highestValue']={syn:'Returns the maximal value observed for the acceleration since the device was started.',lib:'accelerometer&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'accelerometer&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_logicalName']={syn:'Returns the logical name of the accelerometer.',lib:'accelerometer&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the accelerometer.</p>',ret:'a string corresponding to the logical name of the accelerometer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Accelerometer']['get_lowestValue']={syn:'Returns the minimal value observed for the acceleration since the device was started.',lib:'accelerometer&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the acceleration since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the acceleration since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'accelerometer&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Accelerometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'accelerometer&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Accelerometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'accelerometer&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Accelerometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'accelerometer&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Accelerometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'accelerometer&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Accelerometer']['get_unit']={syn:'Returns the measuring unit for the acceleration.',lib:'accelerometer&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the acceleration.</p>',ret:'a string corresponding to the measuring unit for the acceleration',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Accelerometer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'accelerometer&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Accelerometer']['get_xValue']={syn:'Returns the X component of the acceleration, as a floating point number.',lib:'accelerometer&rarr;get_xValue()',pro:'double get_xValue()',cmt:'<p>Returns the X component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_yValue']={syn:'Returns the Y component of the acceleration, as a floating point number.',lib:'accelerometer&rarr;get_yValue()',pro:'double get_yValue()',cmt:'<p>Returns the Y component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Accelerometer']['get_zValue']={syn:'Returns the Z component of the acceleration, as a floating point number.',lib:'accelerometer&rarr;get_zValue()',pro:'double get_zValue()',cmt:'<p>Returns the Z component of the acceleration, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the acceleration, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Accelerometer']['isOnline']={syn:'Checks if the accelerometer is currently reachable, without raising any error.',lib:'accelerometer&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the accelerometer is currently reachable, without raising any error. If there is a cached value for the accelerometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the accelerometer.</p>',ret:'<tt>true</tt> if the accelerometer can be reached, and <tt>false</tt> otherwise'};
doc['Accelerometer']['load']={syn:'Preloads the accelerometer cache with a specified validity duration.',lib:'accelerometer&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the accelerometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'accelerometer&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Accelerometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'accelerometer&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'accelerometer&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['nextAccelerometer']={syn:'Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>.',lib:'accelerometer&rarr;nextAccelerometer()',pro:'YAccelerometer * nextAccelerometer()',cmt:'<p>Continues the enumeration of accelerometers started using <tt>yFirstAccelerometer()</tt>.</p>',ret:'a pointer to a <tt>YAccelerometer</tt> object, corresponding to an accelerometer currently online, or a <tt>null</tt> pointer if there are no more accelerometers to enumerate.'};
doc['Accelerometer']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'accelerometer&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YAccelerometerTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Accelerometer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'accelerometer&rarr;registerValueCallback()',pro:'int registerValueCallback(YAccelerometerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Accelerometer']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'accelerometer&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'accelerometer&rarr;set_bandwidth()',pro:'int set_bandwidth(int <span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'accelerometer&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'accelerometer&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_logicalName']={syn:'Changes the logical name of the accelerometer.',lib:'accelerometer&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the accelerometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the accelerometer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'accelerometer&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'accelerometer&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'accelerometer&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Accelerometer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'accelerometer&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Accelerometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'accelerometer&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Accelerometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'accelerometer&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Accelerometer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'accelerometer&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Accelerometer)
//--- (generated code: Magnetometer)
doc['Magnetometer']={'':{syn:'Magnetometer function interface',inc:'#include &quot;yocto_magnetometer.h&quot;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Magnetometer']['FindMagnetometer']={syn:'Retrieves a magnetometer for a given identifier.',lib:'YMagnetometer::FindMagnetometer()',pro:'YMagnetometer* FindMagnetometer(string <span id=pn>func</span>)',cmt:'<p>Retrieves a magnetometer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the magnetometer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMagnetometer.isOnline()</tt> to test if the magnetometer is indeed online at a given time. In case of ambiguity when looking for a magnetometer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the magnetometer'},ret:'a <tt>YMagnetometer</tt> object allowing you to drive the magnetometer.'};
doc['Magnetometer']['FirstMagnetometer']={syn:'Starts the enumeration of magnetometers currently accessible.',lib:'YMagnetometer::FirstMagnetometer()',pro:'YMagnetometer* FirstMagnetometer()',cmt:'<p>Starts the enumeration of magnetometers currently accessible. Use the method <tt>YMagnetometer.nextMagnetometer()</tt> to iterate on next magnetometers.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to the first magnetometer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Magnetometer']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'magnetometer&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['clearCache']={syn:'Invalidates the cache.',lib:'magnetometer&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the magnetometer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Magnetometer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'magnetometer&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the magnetometer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the magnetometer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Magnetometer']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'magnetometer&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Magnetometer']['get_advertisedValue']={syn:'Returns the current value of the magnetometer (no more than 6 characters).',lib:'magnetometer&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the magnetometer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the magnetometer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'magnetometer&rarr;get_bandwidth()',pro:'int get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Magnetometer']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.',lib:'magnetometer&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_currentValue']={syn:'Returns the current value of the magnetic field, in mT, as a floating point number.',lib:'magnetometer&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the magnetic field, in mT, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the magnetic field, in mT, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'magnetometer&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Magnetometer']['get_errorMessage']={syn:'Returns the error message of the latest error with the magnetometer.',lib:'magnetometer&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the magnetometer object'};
doc['Magnetometer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the magnetometer.',lib:'magnetometer&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the magnetometer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the magnetometer object'};
doc['Magnetometer']['get_friendlyName']={syn:'Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'magnetometer&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the magnetometer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the magnetometer if they are defined, otherwise the serial number of the module and the hardware identifier of the magnetometer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the magnetometer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Magnetometer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'magnetometer&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Magnetometer']['get_functionId']={syn:'Returns the hardware identifier of the magnetometer, without reference to the module.',lib:'magnetometer&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the magnetometer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the magnetometer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Magnetometer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'magnetometer&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the magnetometer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the magnetometer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the magnetometer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Magnetometer']['get_highestValue']={syn:'Returns the maximal value observed for the magnetic field since the device was started.',lib:'magnetometer&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'magnetometer&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_logicalName']={syn:'Returns the logical name of the magnetometer.',lib:'magnetometer&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the magnetometer.</p>',ret:'a string corresponding to the logical name of the magnetometer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Magnetometer']['get_lowestValue']={syn:'Returns the minimal value observed for the magnetic field since the device was started.',lib:'magnetometer&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the magnetic field since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the magnetic field since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'magnetometer&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Magnetometer']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'magnetometer&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Magnetometer']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'magnetometer&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Magnetometer']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'magnetometer&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Magnetometer']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'magnetometer&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Magnetometer']['get_unit']={syn:'Returns the measuring unit for the magnetic field.',lib:'magnetometer&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the magnetic field.</p>',ret:'a string corresponding to the measuring unit for the magnetic field',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Magnetometer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'magnetometer&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Magnetometer']['get_xValue']={syn:'Returns the X component of the magnetic field, as a floating point number.',lib:'magnetometer&rarr;get_xValue()',pro:'double get_xValue()',cmt:'<p>Returns the X component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the X component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_yValue']={syn:'Returns the Y component of the magnetic field, as a floating point number.',lib:'magnetometer&rarr;get_yValue()',pro:'double get_yValue()',cmt:'<p>Returns the Y component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Y component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Magnetometer']['get_zValue']={syn:'Returns the Z component of the magnetic field, as a floating point number.',lib:'magnetometer&rarr;get_zValue()',pro:'double get_zValue()',cmt:'<p>Returns the Z component of the magnetic field, as a floating point number.</p>',ret:'a floating point number corresponding to the Z component of the magnetic field, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Magnetometer']['isOnline']={syn:'Checks if the magnetometer is currently reachable, without raising any error.',lib:'magnetometer&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the magnetometer is currently reachable, without raising any error. If there is a cached value for the magnetometer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the magnetometer.</p>',ret:'<tt>true</tt> if the magnetometer can be reached, and <tt>false</tt> otherwise'};
doc['Magnetometer']['load']={syn:'Preloads the magnetometer cache with a specified validity duration.',lib:'magnetometer&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the magnetometer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'magnetometer&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Magnetometer']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'magnetometer&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'magnetometer&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['nextMagnetometer']={syn:'Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>.',lib:'magnetometer&rarr;nextMagnetometer()',pro:'YMagnetometer * nextMagnetometer()',cmt:'<p>Continues the enumeration of magnetometers started using <tt>yFirstMagnetometer()</tt>.</p>',ret:'a pointer to a <tt>YMagnetometer</tt> object, corresponding to a magnetometer currently online, or a <tt>null</tt> pointer if there are no more magnetometers to enumerate.'};
doc['Magnetometer']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'magnetometer&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YMagnetometerTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Magnetometer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'magnetometer&rarr;registerValueCallback()',pro:'int registerValueCallback(YMagnetometerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Magnetometer']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'magnetometer&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'magnetometer&rarr;set_bandwidth()',pro:'int set_bandwidth(int <span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'magnetometer&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'magnetometer&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_logicalName']={syn:'Changes the logical name of the magnetometer.',lib:'magnetometer&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the magnetometer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the magnetometer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'magnetometer&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'magnetometer&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'magnetometer&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Magnetometer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'magnetometer&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Magnetometer']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'magnetometer&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Magnetometer']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'magnetometer&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Magnetometer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'magnetometer&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Magnetometer)
//--- (generated code: RefFrame)
doc['RefFrame']={'':{syn:'Reference frame configuration',inc:'#include &quot;yocto_refframe.h&quot;',cmt:'<p>This class is used to setup the base orientation of the Yocto-3D, so that the orientation functions, relative to the earth surface plane, use the proper reference frame. The class also implements a tridimensional sensor calibration process, which can compensate for local variations of standard gravity and improve the precision of the tilt sensors.</p>'}};
doc['RefFrame']['FindRefFrame']={syn:'Retrieves a reference frame for a given identifier.',lib:'YRefFrame::FindRefFrame()',pro:'YRefFrame* FindRefFrame(string <span id=pn>func</span>)',cmt:'<p>Retrieves a reference frame for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the reference frame is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRefFrame.isOnline()</tt> to test if the reference frame is indeed online at a given time. In case of ambiguity when looking for a reference frame by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the reference frame'},ret:'a <tt>YRefFrame</tt> object allowing you to drive the reference frame.'};
doc['RefFrame']['FirstRefFrame']={syn:'Starts the enumeration of reference frames currently accessible.',lib:'YRefFrame::FirstRefFrame()',pro:'YRefFrame* FirstRefFrame()',cmt:'<p>Starts the enumeration of reference frames currently accessible. Use the method <tt>YRefFrame.nextRefFrame()</tt> to iterate on next reference frames.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to the first reference frame currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RefFrame']['cancel3DCalibration']={syn:'Aborts the sensors tridimensional calibration process et restores normal settings.',lib:'refframe&rarr;cancel3DCalibration()',pro:'int cancel3DCalibration()',cmt:'<p>Aborts the sensors tridimensional calibration process et restores normal settings.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['clearCache']={syn:'Invalidates the cache.',lib:'refframe&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the reference frame attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['RefFrame']['describe']={syn:'Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'refframe&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the reference frame in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the reference frame (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RefFrame']['get_3DCalibrationHint']={syn:'Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe&rarr;get_3DCalibrationHint()',pro:'string get_3DCalibrationHint()',cmt:'<p>Returns instructions to proceed to the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationLogMsg']={syn:'Returns the latest log message from the calibration process.',lib:'refframe&rarr;get_3DCalibrationLogMsg()',pro:'string get_3DCalibrationLogMsg()',cmt:'<p>Returns the latest log message from the calibration process. When no new message is available, returns an empty string.</p>',ret:'a character string.'};
doc['RefFrame']['get_3DCalibrationProgress']={syn:'Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe&rarr;get_3DCalibrationProgress()',pro:'int get_3DCalibrationProgress()',cmt:'<p>Returns the global process indicator for the tridimensional calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_3DCalibrationStage']={syn:'Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe&rarr;get_3DCalibrationStage()',pro:'int get_3DCalibrationStage()',cmt:'<p>Returns index of the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer, growing each time a calibration stage is completed.'};
doc['RefFrame']['get_3DCalibrationStageProgress']={syn:'Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.',lib:'refframe&rarr;get_3DCalibrationStageProgress()',pro:'int get_3DCalibrationStageProgress()',cmt:'<p>Returns the process indicator for the current stage of the calibration initiated with method <tt>start3DCalibration</tt>.</p>',ret:'an integer between 0 (not started) and 100 (stage completed).'};
doc['RefFrame']['get_advertisedValue']={syn:'Returns the current value of the reference frame (no more than 6 characters).',lib:'refframe&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the reference frame (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the reference frame (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RefFrame']['get_bearing']={syn:'Returns the reference bearing used by the compass.',lib:'refframe&rarr;get_bearing()',pro:'double get_bearing()',cmt:'<p>Returns the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p>',ret:'a floating point number corresponding to the reference bearing used by the compass',ext:'On failure, throws an exception or returns <tt>Y_BEARING_INVALID</tt>.'};
doc['RefFrame']['get_calibrationState']={syn:'Returns the 3D sensor calibration state (Yocto-3D-V2 only).',lib:'refframe&rarr;get_calibrationState()',pro:'int get_calibrationState()',cmt:'<p>Returns the 3D sensor calibration state (Yocto-3D-V2 only). This function returns an integer representing the calibration state of the 3 inertial sensors of the BNO055 chip, found in the Yocto-3D-V2. Hundredths show the calibration state of the accelerometer, tenths show the calibration state of the magnetometer while units show the calibration state of the gyroscope. For each sensor, the value 0 means no calibration and the value 3 means full calibration.</p>',ret:'an integer representing the calibration state of Yocto-3D-V2: 333 when fully calibrated, 0 when not calibrated at all.',ext:'On failure, throws an exception or returns a negative error code. For the Yocto-3D (V1), this function always return -3 (unsupported function).'};
doc['RefFrame']['get_errorMessage']={syn:'Returns the error message of the latest error with the reference frame.',lib:'refframe&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the reference frame object'};
doc['RefFrame']['get_errorType']={syn:'Returns the numerical error code of the latest error with the reference frame.',lib:'refframe&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the reference frame. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the reference frame object'};
doc['RefFrame']['get_friendlyName']={syn:'Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'refframe&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the reference frame in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the reference frame if they are defined, otherwise the serial number of the module and the hardware identifier of the reference frame (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the reference frame using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RefFrame']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'refframe&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RefFrame']['get_functionId']={syn:'Returns the hardware identifier of the reference frame, without reference to the module.',lib:'refframe&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the reference frame, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the reference frame (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RefFrame']['get_hardwareId']={syn:'Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'refframe&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the reference frame in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the reference frame (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the reference frame (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RefFrame']['get_logicalName']={syn:'Returns the logical name of the reference frame.',lib:'refframe&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the reference frame.</p>',ret:'a string corresponding to the logical name of the reference frame.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RefFrame']['get_measureQuality']={syn:'Returns estimated quality of the orientation (Yocto-3D-V2 only).',lib:'refframe&rarr;get_measureQuality()',pro:'int get_measureQuality()',cmt:'<p>Returns estimated quality of the orientation (Yocto-3D-V2 only). This function returns an integer between 0 and 3 representing the degree of confidence of the position estimate. When the value is 3, the estimation is reliable. Below 3, one should expect sudden corrections, in particular for heading (<tt>compass</tt> function). The most frequent causes for values below 3 are magnetic interferences, and accelerations or rotations beyond the sensor range.</p>',ret:'an integer between 0 and 3 (3 when the measure is reliable)',ext:'On failure, throws an exception or returns a negative error code. For the Yocto-3D (V1), this function always return -3 (unsupported function).'};
doc['RefFrame']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'refframe&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RefFrame']['get_mountOrientation']={syn:'Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'refframe&rarr;get_mountOrientation()',pro:'Y_MOUNTORIENTATION get_mountOrientation()',cmt:'<p>Returns the installation orientation of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.',ext:'On failure, throws an exception or returns Y_MOUNTORIENTATION_INVALID.'};
doc['RefFrame']['get_mountPosition']={syn:'Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.',lib:'refframe&rarr;get_mountPosition()',pro:'Y_MOUNTPOSITION get_mountPosition()',cmt:'<p>Returns the installation position of the device, as configured in order to define the reference frame for the compass and the pitch/roll tilt sensors.</p>',ret:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',ext:'On failure, throws an exception or returns Y_MOUNTPOSITION_INVALID.'};
doc['RefFrame']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'refframe&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RefFrame']['isOnline']={syn:'Checks if the reference frame is currently reachable, without raising any error.',lib:'refframe&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the reference frame is currently reachable, without raising any error. If there is a cached value for the reference frame in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the reference frame.</p>',ret:'<tt>true</tt> if the reference frame can be reached, and <tt>false</tt> otherwise'};
doc['RefFrame']['load']={syn:'Preloads the reference frame cache with a specified validity duration.',lib:'refframe&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the reference frame cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'refframe&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['RefFrame']['more3DCalibration']={syn:'Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>.',lib:'refframe&rarr;more3DCalibration()',pro:'int more3DCalibration()',cmt:'<p>Continues the sensors tridimensional calibration process previously initiated using method <tt>start3DCalibration</tt>. This method should be called approximately 5 times per second, while positioning the device according to the instructions provided by method <tt>get_3DCalibrationHint</tt>. Note that the instructions change during the calibration process.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'refframe&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['nextRefFrame']={syn:'Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>.',lib:'refframe&rarr;nextRefFrame()',pro:'YRefFrame * nextRefFrame()',cmt:'<p>Continues the enumeration of reference frames started using <tt>yFirstRefFrame()</tt>.</p>',ret:'a pointer to a <tt>YRefFrame</tt> object, corresponding to a reference frame currently online, or a <tt>null</tt> pointer if there are no more reference frames to enumerate.'};
doc['RefFrame']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'refframe&rarr;registerValueCallback()',pro:'int registerValueCallback(YRefFrameValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RefFrame']['save3DCalibration']={syn:'Applies the sensors tridimensional calibration parameters that have just been computed.',lib:'refframe&rarr;save3DCalibration()',pro:'int save3DCalibration()',cmt:'<p>Applies the sensors tridimensional calibration parameters that have just been computed. Remember to call the <tt>saveToFlash()</tt> method of the module if the changes must be kept when the device is restarted.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['set_bearing']={syn:'Changes the reference bearing used by the compass.',lib:'refframe&rarr;set_bearing()',pro:'int set_bearing(double <span id=pn>newval</span>)',cmt:'<p>Changes the reference bearing used by the compass. The relative bearing indicated by the compass is the difference between the measured magnetic heading and the reference bearing indicated here.</p><p> For instance, if you setup as reference bearing the value of the earth magnetic declination, the compass will provide the orientation relative to the geographic North.</p><p> Similarly, when the sensor is not mounted along the standard directions because it has an additional yaw angle, you can set this angle in the reference bearing so that the compass provides the expected natural direction.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a floating point number corresponding to the reference bearing used by the compass'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_logicalName']={syn:'Changes the logical name of the reference frame.',lib:'refframe&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the reference frame. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the reference frame.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_mountPosition']={syn:'Changes the compass and tilt sensor frame of reference.',lib:'refframe&rarr;set_mountPosition()',pro:'int set_mountPosition(Y_MOUNTPOSITION <span id=pn>position</span>,&nbsp;Y_MOUNTORIENTATION <span id=pn>orientation</span>)',cmt:'<p>Changes the compass and tilt sensor frame of reference. The magnetic compass and the tilt sensors (pitch and roll) naturally work in the plane parallel to the earth surface. In case the device is not installed upright and horizontally, you must select its reference orientation (parallel to the earth surface) so that the measures are made relative to this position.</p>',par:{position:'a value among the <tt>Y_MOUNTPOSITION</tt> enumeration (<tt>Y_MOUNTPOSITION_BOTTOM</tt>, <tt>Y_MOUNTPOSITION_TOP</tt>, <tt>Y_MOUNTPOSITION_FRONT</tt>, <tt>Y_MOUNTPOSITION_RIGHT</tt>, <tt>Y_MOUNTPOSITION_REAR</tt>, <tt>Y_MOUNTPOSITION_LEFT</tt>), corresponding to the installation in a box, on one of the six faces.',orientation:'a value among the enumeration <tt>Y_MOUNTORIENTATION</tt> (<tt>Y_MOUNTORIENTATION_TWELVE</tt>, <tt>Y_MOUNTORIENTATION_THREE</tt>, <tt>Y_MOUNTORIENTATION_SIX</tt>, <tt>Y_MOUNTORIENTATION_NINE</tt>) corresponding to the orientation of the \x22X\x22 arrow on the device, as on a clock dial seen from an observer in the center of the box. On the bottom face, the 12H orientation points to the front, while on the top face, the 12H orientation points to the rear.'},ext:'On failure, throws an exception or returns a negative error code.'};
doc['RefFrame']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'refframe&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RefFrame']['start3DCalibration']={syn:'Initiates the sensors tridimensional calibration process.',lib:'refframe&rarr;start3DCalibration()',pro:'int start3DCalibration()',cmt:'<p>Initiates the sensors tridimensional calibration process. This calibration is used at low level for inertial position estimation and to enhance the precision of the tilt sensors.</p><p> After calling this method, the device should be moved according to the instructions provided by method <tt>get_3DCalibrationHint</tt>, and <tt>more3DCalibration</tt> should be invoked about 5 times per second. The calibration procedure is completed when the method <tt>get_3DCalibrationProgress</tt> returns 100. At this point, the computed calibration parameters can be applied using method <tt>save3DCalibration</tt>. The calibration process can be canceled at any time using method <tt>cancel3DCalibration</tt>.</p><p> On failure, throws an exception or returns a negative error code.</p>'};
doc['RefFrame']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'refframe&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RefFrame)
//--- (generated code: Compass)
doc['Compass']={'':{syn:'Compass function interface',inc:'#include &quot;yocto_compass.h&quot;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Compass']['FindCompass']={syn:'Retrieves a compass for a given identifier.',lib:'YCompass::FindCompass()',pro:'YCompass* FindCompass(string <span id=pn>func</span>)',cmt:'<p>Retrieves a compass for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the compass is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCompass.isOnline()</tt> to test if the compass is indeed online at a given time. In case of ambiguity when looking for a compass by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the compass'},ret:'a <tt>YCompass</tt> object allowing you to drive the compass.'};
doc['Compass']['FirstCompass']={syn:'Starts the enumeration of compasses currently accessible.',lib:'YCompass::FirstCompass()',pro:'YCompass* FirstCompass()',cmt:'<p>Starts the enumeration of compasses currently accessible. Use the method <tt>YCompass.nextCompass()</tt> to iterate on next compasses.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to the first compass currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Compass']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'compass&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['clearCache']={syn:'Invalidates the cache.',lib:'compass&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the compass attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Compass']['describe']={syn:'Returns a short text that describes unambiguously the instance of the compass in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'compass&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the compass in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the compass (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Compass']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'compass&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Compass']['get_advertisedValue']={syn:'Returns the current value of the compass (no more than 6 characters).',lib:'compass&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the compass (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the compass (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Compass']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'compass&rarr;get_bandwidth()',pro:'int get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Compass']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'compass&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Compass']['get_currentValue']={syn:'Returns the current value of the relative bearing, in degrees, as a floating point number.',lib:'compass&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the relative bearing, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the relative bearing, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Compass']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'compass&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Compass']['get_errorMessage']={syn:'Returns the error message of the latest error with the compass.',lib:'compass&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the compass. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the compass object'};
doc['Compass']['get_errorType']={syn:'Returns the numerical error code of the latest error with the compass.',lib:'compass&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the compass. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the compass object'};
doc['Compass']['get_friendlyName']={syn:'Returns a global identifier of the compass in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'compass&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the compass in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the compass if they are defined, otherwise the serial number of the module and the hardware identifier of the compass (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the compass using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Compass']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'compass&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Compass']['get_functionId']={syn:'Returns the hardware identifier of the compass, without reference to the module.',lib:'compass&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the compass, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the compass (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Compass']['get_hardwareId']={syn:'Returns the unique hardware identifier of the compass in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'compass&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the compass in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the compass (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the compass (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Compass']['get_highestValue']={syn:'Returns the maximal value observed for the relative bearing since the device was started.',lib:'compass&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Compass']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'compass&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_logicalName']={syn:'Returns the logical name of the compass.',lib:'compass&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the compass.</p>',ret:'a string corresponding to the logical name of the compass.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Compass']['get_lowestValue']={syn:'Returns the minimal value observed for the relative bearing since the device was started.',lib:'compass&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the relative bearing since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the relative bearing since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Compass']['get_magneticHeading']={syn:'Returns the magnetic heading, regardless of the configured bearing.',lib:'compass&rarr;get_magneticHeading()',pro:'double get_magneticHeading()',cmt:'<p>Returns the magnetic heading, regardless of the configured bearing.</p>',ret:'a floating point number corresponding to the magnetic heading, regardless of the configured bearing',ext:'On failure, throws an exception or returns <tt>Y_MAGNETICHEADING_INVALID</tt>.'};
doc['Compass']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'compass&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Compass']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'compass&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Compass']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'compass&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Compass']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'compass&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Compass']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'compass&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Compass']['get_unit']={syn:'Returns the measuring unit for the relative bearing.',lib:'compass&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the relative bearing.</p>',ret:'a string corresponding to the measuring unit for the relative bearing',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Compass']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'compass&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Compass']['isOnline']={syn:'Checks if the compass is currently reachable, without raising any error.',lib:'compass&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the compass is currently reachable, without raising any error. If there is a cached value for the compass in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the compass.</p>',ret:'<tt>true</tt> if the compass can be reached, and <tt>false</tt> otherwise'};
doc['Compass']['load']={syn:'Preloads the compass cache with a specified validity duration.',lib:'compass&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the compass cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'compass&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Compass']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'compass&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'compass&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['nextCompass']={syn:'Continues the enumeration of compasses started using <tt>yFirstCompass()</tt>.',lib:'compass&rarr;nextCompass()',pro:'YCompass * nextCompass()',cmt:'<p>Continues the enumeration of compasses started using <tt>yFirstCompass()</tt>.</p>',ret:'a pointer to a <tt>YCompass</tt> object, corresponding to a compass currently online, or a <tt>null</tt> pointer if there are no more compasses to enumerate.'};
doc['Compass']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'compass&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YCompassTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Compass']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'compass&rarr;registerValueCallback()',pro:'int registerValueCallback(YCompassValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Compass']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'compass&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'compass&rarr;set_bandwidth()',pro:'int set_bandwidth(int <span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'compass&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'compass&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_logicalName']={syn:'Changes the logical name of the compass.',lib:'compass&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the compass. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the compass.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'compass&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'compass&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'compass&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Compass']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'compass&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Compass']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'compass&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Compass']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'compass&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Compass']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'compass&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Compass)
//--- (generated code: Gyro)
doc['Gyro']={'':{syn:'Gyroscope function interface',inc:'#include &quot;yocto_gyro.h&quot;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Gyro']['FindGyro']={syn:'Retrieves a gyroscope for a given identifier.',lib:'YGyro::FindGyro()',pro:'YGyro* FindGyro(string <span id=pn>func</span>)',cmt:'<p>Retrieves a gyroscope for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the gyroscope is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGyro.isOnline()</tt> to test if the gyroscope is indeed online at a given time. In case of ambiguity when looking for a gyroscope by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the gyroscope'},ret:'a <tt>YGyro</tt> object allowing you to drive the gyroscope.'};
doc['Gyro']['FirstGyro']={syn:'Starts the enumeration of gyroscopes currently accessible.',lib:'YGyro::FirstGyro()',pro:'YGyro* FirstGyro()',cmt:'<p>Starts the enumeration of gyroscopes currently accessible. Use the method <tt>YGyro.nextGyro()</tt> to iterate on next gyroscopes.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to the first gyro currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Gyro']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'gyro&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['clearCache']={syn:'Invalidates the cache.',lib:'gyro&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the gyroscope attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Gyro']['describe']={syn:'Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gyro&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the gyroscope in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the gyroscope (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gyro']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'gyro&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Gyro']['get_advertisedValue']={syn:'Returns the current value of the gyroscope (no more than 6 characters).',lib:'gyro&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the gyroscope (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the gyroscope (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gyro']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'gyro&rarr;get_bandwidth()',pro:'int get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Gyro']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.',lib:'gyro&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Gyro']['get_currentValue']={syn:'Returns the current value of the angular velocity, in degrees per second, as a floating point number.',lib:'gyro&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the angular velocity, in degrees per second, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the angular velocity, in degrees per second, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Gyro']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'gyro&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Gyro']['get_errorMessage']={syn:'Returns the error message of the latest error with the gyroscope.',lib:'gyro&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the gyroscope object'};
doc['Gyro']['get_errorType']={syn:'Returns the numerical error code of the latest error with the gyroscope.',lib:'gyro&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the gyroscope. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the gyroscope object'};
doc['Gyro']['get_friendlyName']={syn:'Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'gyro&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the gyroscope in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the gyroscope if they are defined, otherwise the serial number of the module and the hardware identifier of the gyroscope (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the gyroscope using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gyro']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'gyro&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Gyro']['get_functionId']={syn:'Returns the hardware identifier of the gyroscope, without reference to the module.',lib:'gyro&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the gyroscope, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the gyroscope (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gyro']['get_hardwareId']={syn:'Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'gyro&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the gyroscope in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the gyroscope (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the gyroscope (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gyro']['get_heading']={syn:'Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_heading()',pro:'double get_heading()',cmt:'<p>Returns the estimated heading angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the heading can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to heading in degrees, between 0 and 360.'};
doc['Gyro']['get_highestValue']={syn:'Returns the maximal value observed for the angular velocity since the device was started.',lib:'gyro&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'gyro&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_logicalName']={syn:'Returns the logical name of the gyroscope.',lib:'gyro&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the gyroscope.</p>',ret:'a string corresponding to the logical name of the gyroscope.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gyro']['get_lowestValue']={syn:'Returns the minimal value observed for the angular velocity since the device was started.',lib:'gyro&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the angular velocity since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the angular velocity since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Gyro']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'gyro&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Gyro']['get_pitch']={syn:'Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_pitch()',pro:'double get_pitch()',cmt:'<p>Returns the estimated pitch angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the pitch angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to pitch angle in degrees, between -90 and +90.'};
doc['Gyro']['get_quaternionW']={syn:'Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_quaternionW()',pro:'double get_quaternionW()',cmt:'<p>Returns the <tt>w</tt> component (real part) of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.</p>',ret:'a floating-point number corresponding to the <tt>w</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionX']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_quaternionX()',pro:'double get_quaternionX()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with rotations on the roll axis.</p>',ret:'a floating-point number corresponding to the <tt>x</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionY']={syn:'Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_quaternionY()',pro:'double get_quaternionY()',cmt:'<p>Returns the <tt>y</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>y</tt> component is mostly correlated with rotations on the pitch axis.</p>',ret:'a floating-point number corresponding to the <tt>y</tt> component of the quaternion.'};
doc['Gyro']['get_quaternionZ']={syn:'Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_quaternionZ()',pro:'double get_quaternionZ()',cmt:'<p>Returns the <tt>x</tt> component of the quaternion describing the device estimated orientation, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The <tt>x</tt> component is mostly correlated with changes of heading.</p>',ret:'a floating-point number corresponding to the <tt>z</tt> component of the quaternion.'};
doc['Gyro']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'gyro&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Gyro']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'gyro&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Gyro']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'gyro&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Gyro']['get_roll']={syn:'Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements.',lib:'gyro&rarr;get_roll()',pro:'double get_roll()',cmt:'<p>Returns the estimated roll angle, based on the integration of gyroscopic measures combined with acceleration and magnetic field measurements. The axis corresponding to the roll angle can be mapped to any of the device X, Y or Z physical directions using methods of the class <tt>YRefFrame</tt>.</p>',ret:'a floating-point number corresponding to roll angle in degrees, between -180 and +180.'};
doc['Gyro']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'gyro&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Gyro']['get_unit']={syn:'Returns the measuring unit for the angular velocity.',lib:'gyro&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the angular velocity.</p>',ret:'a string corresponding to the measuring unit for the angular velocity',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Gyro']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'gyro&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Gyro']['get_xValue']={syn:'Returns the angular velocity around the X axis of the device, as a floating point number.',lib:'gyro&rarr;get_xValue()',pro:'double get_xValue()',cmt:'<p>Returns the angular velocity around the X axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the X axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_XVALUE_INVALID</tt>.'};
doc['Gyro']['get_yValue']={syn:'Returns the angular velocity around the Y axis of the device, as a floating point number.',lib:'gyro&rarr;get_yValue()',pro:'double get_yValue()',cmt:'<p>Returns the angular velocity around the Y axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Y axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_YVALUE_INVALID</tt>.'};
doc['Gyro']['get_zValue']={syn:'Returns the angular velocity around the Z axis of the device, as a floating point number.',lib:'gyro&rarr;get_zValue()',pro:'double get_zValue()',cmt:'<p>Returns the angular velocity around the Z axis of the device, as a floating point number.</p>',ret:'a floating point number corresponding to the angular velocity around the Z axis of the device, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_ZVALUE_INVALID</tt>.'};
doc['Gyro']['isOnline']={syn:'Checks if the gyroscope is currently reachable, without raising any error.',lib:'gyro&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the gyroscope is currently reachable, without raising any error. If there is a cached value for the gyroscope in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the gyroscope.</p>',ret:'<tt>true</tt> if the gyroscope can be reached, and <tt>false</tt> otherwise'};
doc['Gyro']['load']={syn:'Preloads the gyroscope cache with a specified validity duration.',lib:'gyro&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the gyroscope cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'gyro&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Gyro']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'gyro&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'gyro&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['nextGyro']={syn:'Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>.',lib:'gyro&rarr;nextGyro()',pro:'YGyro * nextGyro()',cmt:'<p>Continues the enumeration of gyroscopes started using <tt>yFirstGyro()</tt>.</p>',ret:'a pointer to a <tt>YGyro</tt> object, corresponding to a gyroscope currently online, or a <tt>null</tt> pointer if there are no more gyroscopes to enumerate.'};
doc['Gyro']['registerAnglesCallback']={syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'gyro&rarr;registerAnglesCallback()',pro:'int registerAnglesCallback(YAnglesCallback <span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take four arguments: the YGyro object of the turning device, and the floating point values of the three angles roll, pitch and heading in degrees (as floating-point numbers).'}};
doc['Gyro']['registerQuaternionCallback']={syn:'Registers a callback function that will be invoked each time that the estimated device orientation has changed.',lib:'gyro&rarr;registerQuaternionCallback()',pro:'int registerQuaternionCallback(YQuatCallback <span id=pn>callback</span>)',cmt:'<p>Registers a callback function that will be invoked each time that the estimated device orientation has changed. The call frequency is typically around 95Hz during a move. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to invoke, or a null pointer. The callback function should take five arguments: the YGyro object of the turning device, and the floating point values of the four components w, x, y and z (as floating-point numbers).'}};
doc['Gyro']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'gyro&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YGyroTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Gyro']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'gyro&rarr;registerValueCallback()',pro:'int registerValueCallback(YGyroValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Gyro']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'gyro&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'gyro&rarr;set_bandwidth()',pro:'int set_bandwidth(int <span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'gyro&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'gyro&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_logicalName']={syn:'Changes the logical name of the gyroscope.',lib:'gyro&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the gyroscope. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the gyroscope.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'gyro&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'gyro&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'gyro&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gyro']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'gyro&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Gyro']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'gyro&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Gyro']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'gyro&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Gyro']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'gyro&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Gyro)
//--- (generated code: Tilt)
doc['Tilt']={'':{syn:'Tilt function interface',inc:'#include &quot;yocto_tilt.h&quot;',cmt:'<p>The YSensor class is the parent class for all Yoctopuce sensors. It can be used to read the current value and unit of any sensor, read the min/max value, configure autonomous recording frequency and access recorded data. It also provide a function to register a callback invoked each time the observed value changes, or at a predefined interval. Using this class rather than a specific subclass makes it possible to create generic applications that work with any Yoctopuce sensor, even those that do not yet exist. Note: The YAnButton class is the only analog input which does not inherit from YSensor.</p>'}};
doc['Tilt']['FindTilt']={syn:'Retrieves a tilt sensor for a given identifier.',lib:'YTilt::FindTilt()',pro:'YTilt* FindTilt(string <span id=pn>func</span>)',cmt:'<p>Retrieves a tilt sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the tilt sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YTilt.isOnline()</tt> to test if the tilt sensor is indeed online at a given time. In case of ambiguity when looking for a tilt sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the tilt sensor'},ret:'a <tt>YTilt</tt> object allowing you to drive the tilt sensor.'};
doc['Tilt']['FirstTilt']={syn:'Starts the enumeration of tilt sensors currently accessible.',lib:'YTilt::FirstTilt()',pro:'YTilt* FirstTilt()',cmt:'<p>Starts the enumeration of tilt sensors currently accessible. Use the method <tt>YTilt.nextTilt()</tt> to iterate on next tilt sensors.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to the first tilt sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Tilt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'tilt&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['clearCache']={syn:'Invalidates the cache.',lib:'tilt&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the tilt sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Tilt']['describe']={syn:'Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'tilt&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the tilt sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the tilt sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Tilt']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'tilt&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Tilt']['get_advertisedValue']={syn:'Returns the current value of the tilt sensor (no more than 6 characters).',lib:'tilt&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the tilt sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the tilt sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Tilt']['get_bandwidth']={syn:'Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'tilt&rarr;get_bandwidth()',pro:'int get_bandwidth()',cmt:'<p>Returns the measure update frequency, measured in Hz (Yocto-3D-V2 only).</p>',ret:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)',ext:'On failure, throws an exception or returns <tt>Y_BANDWIDTH_INVALID</tt>.'};
doc['Tilt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.',lib:'tilt&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Tilt']['get_currentValue']={syn:'Returns the current value of the inclination, in degrees, as a floating point number.',lib:'tilt&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the inclination, in degrees, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the inclination, in degrees, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Tilt']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'tilt&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Tilt']['get_errorMessage']={syn:'Returns the error message of the latest error with the tilt sensor.',lib:'tilt&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the tilt sensor object'};
doc['Tilt']['get_errorType']={syn:'Returns the numerical error code of the latest error with the tilt sensor.',lib:'tilt&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the tilt sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the tilt sensor object'};
doc['Tilt']['get_friendlyName']={syn:'Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'tilt&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the tilt sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the tilt sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the tilt sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the tilt sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Tilt']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'tilt&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Tilt']['get_functionId']={syn:'Returns the hardware identifier of the tilt sensor, without reference to the module.',lib:'tilt&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the tilt sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the tilt sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Tilt']['get_hardwareId']={syn:'Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'tilt&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the tilt sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the tilt sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the tilt sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Tilt']['get_highestValue']={syn:'Returns the maximal value observed for the inclination since the device was started.',lib:'tilt&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'tilt&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_logicalName']={syn:'Returns the logical name of the tilt sensor.',lib:'tilt&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the tilt sensor.</p>',ret:'a string corresponding to the logical name of the tilt sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Tilt']['get_lowestValue']={syn:'Returns the minimal value observed for the inclination since the device was started.',lib:'tilt&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the inclination since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the inclination since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Tilt']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'tilt&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Tilt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'tilt&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Tilt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'tilt&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Tilt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'tilt&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Tilt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'tilt&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Tilt']['get_unit']={syn:'Returns the measuring unit for the inclination.',lib:'tilt&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the inclination.</p>',ret:'a string corresponding to the measuring unit for the inclination',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Tilt']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'tilt&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Tilt']['isOnline']={syn:'Checks if the tilt sensor is currently reachable, without raising any error.',lib:'tilt&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the tilt sensor is currently reachable, without raising any error. If there is a cached value for the tilt sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the tilt sensor.</p>',ret:'<tt>true</tt> if the tilt sensor can be reached, and <tt>false</tt> otherwise'};
doc['Tilt']['load']={syn:'Preloads the tilt sensor cache with a specified validity duration.',lib:'tilt&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the tilt sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'tilt&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Tilt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'tilt&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'tilt&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['nextTilt']={syn:'Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>.',lib:'tilt&rarr;nextTilt()',pro:'YTilt * nextTilt()',cmt:'<p>Continues the enumeration of tilt sensors started using <tt>yFirstTilt()</tt>.</p>',ret:'a pointer to a <tt>YTilt</tt> object, corresponding to a tilt sensor currently online, or a <tt>null</tt> pointer if there are no more tilt sensors to enumerate.'};
doc['Tilt']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'tilt&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YTiltTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Tilt']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'tilt&rarr;registerValueCallback()',pro:'int registerValueCallback(YTiltValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Tilt']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'tilt&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_bandwidth']={syn:'Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only).',lib:'tilt&rarr;set_bandwidth()',pro:'int set_bandwidth(int <span id=pn>newval</span>)',cmt:'<p>Changes the measure update frequency, measured in Hz (Yocto-3D-V2 only). When the frequency is lower, the device performs averaging.</p>',par:{newval:'an integer corresponding to the measure update frequency, measured in Hz (Yocto-3D-V2 only)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'tilt&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'tilt&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_logicalName']={syn:'Changes the logical name of the tilt sensor.',lib:'tilt&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the tilt sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the tilt sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'tilt&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'tilt&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'tilt&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Tilt']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'tilt&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Tilt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'tilt&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tilt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'tilt&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Tilt']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'tilt&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Tilt)
//--- (generated code: Qt)
doc['Qt']={'':{syn:'Quaternion interface',inc:'#include &quot;yocto_gyro.h&quot;',cmt:'<p>The Yoctopuce API YQt class provides direct access to the Yocto3D attitude estimation using a quaternion. It is usually not needed to use the YQt class directly, as the YGyro class provides a more convenient higher-level interface.</p>'}};
doc['Qt']['FindQt']={syn:'Retrieves a quaternion component for a given identifier.',lib:'YQt::FindQt()',pro:'YQt* FindQt(string <span id=pn>func</span>)',cmt:'<p>Retrieves a quaternion component for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quaternion component is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQt.isOnline()</tt> to test if the quaternion component is indeed online at a given time. In case of ambiguity when looking for a quaternion component by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the quaternion component'},ret:'a <tt>YQt</tt> object allowing you to drive the quaternion component.'};
doc['Qt']['FirstQt']={syn:'Starts the enumeration of quaternion components currently accessible.',lib:'YQt::FirstQt()',pro:'YQt* FirstQt()',cmt:'<p>Starts the enumeration of quaternion components currently accessible. Use the method <tt>YQt.nextQt()</tt> to iterate on next quaternion components.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to the first quaternion component currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Qt']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'qt&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['clearCache']={syn:'Invalidates the cache.',lib:'qt&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the quaternion component attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Qt']['describe']={syn:'Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'qt&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quaternion component in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quaternion component (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Qt']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'qt&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Qt']['get_advertisedValue']={syn:'Returns the current value of the quaternion component (no more than 6 characters).',lib:'qt&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the quaternion component (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quaternion component (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Qt']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.',lib:'qt&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Qt']['get_currentValue']={syn:'Returns the current value of the value, in units, as a floating point number.',lib:'qt&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the value, in units, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the value, in units, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Qt']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'qt&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Qt']['get_errorMessage']={syn:'Returns the error message of the latest error with the quaternion component.',lib:'qt&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quaternion component object'};
doc['Qt']['get_errorType']={syn:'Returns the numerical error code of the latest error with the quaternion component.',lib:'qt&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quaternion component. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quaternion component object'};
doc['Qt']['get_friendlyName']={syn:'Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'qt&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the quaternion component in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quaternion component if they are defined, otherwise the serial number of the module and the hardware identifier of the quaternion component (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quaternion component using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Qt']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'qt&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Qt']['get_functionId']={syn:'Returns the hardware identifier of the quaternion component, without reference to the module.',lib:'qt&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the quaternion component, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quaternion component (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Qt']['get_hardwareId']={syn:'Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'qt&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quaternion component in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quaternion component (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quaternion component (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Qt']['get_highestValue']={syn:'Returns the maximal value observed for the value since the device was started.',lib:'qt&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Qt']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'qt&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_logicalName']={syn:'Returns the logical name of the quaternion component.',lib:'qt&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the quaternion component.</p>',ret:'a string corresponding to the logical name of the quaternion component.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Qt']['get_lowestValue']={syn:'Returns the minimal value observed for the value since the device was started.',lib:'qt&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the value since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the value since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Qt']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'qt&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Qt']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'qt&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Qt']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'qt&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Qt']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'qt&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Qt']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'qt&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Qt']['get_unit']={syn:'Returns the measuring unit for the value.',lib:'qt&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the value.</p>',ret:'a string corresponding to the measuring unit for the value',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Qt']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'qt&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Qt']['isOnline']={syn:'Checks if the quaternion component is currently reachable, without raising any error.',lib:'qt&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the quaternion component is currently reachable, without raising any error. If there is a cached value for the quaternion component in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quaternion component.</p>',ret:'<tt>true</tt> if the quaternion component can be reached, and <tt>false</tt> otherwise'};
doc['Qt']['load']={syn:'Preloads the quaternion component cache with a specified validity duration.',lib:'qt&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the quaternion component cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'qt&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Qt']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'qt&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'qt&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['nextQt']={syn:'Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>.',lib:'qt&rarr;nextQt()',pro:'YQt * nextQt()',cmt:'<p>Continues the enumeration of quaternion components started using <tt>yFirstQt()</tt>.</p>',ret:'a pointer to a <tt>YQt</tt> object, corresponding to a quaternion component currently online, or a <tt>null</tt> pointer if there are no more quaternion components to enumerate.'};
doc['Qt']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'qt&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YQtTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Qt']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'qt&rarr;registerValueCallback()',pro:'int registerValueCallback(YQtValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Qt']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'qt&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'qt&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'qt&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_logicalName']={syn:'Changes the logical name of the quaternion component.',lib:'qt&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quaternion component. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quaternion component.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'qt&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'qt&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'qt&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Qt']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'qt&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Qt']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'qt&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Qt']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'qt&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Qt']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'qt&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Qt)
//--- (generated code: PwmOutput)
doc['PwmOutput']={'':{syn:'PwmOutput function interface',inc:'#include &quot;yocto_pwmoutput.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to configure, start, and stop the PWM.</p>'}};
doc['PwmOutput']['FindPwmOutput']={syn:'Retrieves a PWM for a given identifier.',lib:'YPwmOutput::FindPwmOutput()',pro:'YPwmOutput* FindPwmOutput(string <span id=pn>func</span>)',cmt:'<p>Retrieves a PWM for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmOutput.isOnline()</tt> to test if the PWM is indeed online at a given time. In case of ambiguity when looking for a PWM by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM'},ret:'a <tt>YPwmOutput</tt> object allowing you to drive the PWM.'};
doc['PwmOutput']['FirstPwmOutput']={syn:'Starts the enumeration of PWMs currently accessible.',lib:'YPwmOutput::FirstPwmOutput()',pro:'YPwmOutput* FirstPwmOutput()',cmt:'<p>Starts the enumeration of PWMs currently accessible. Use the method <tt>YPwmOutput.nextPwmOutput()</tt> to iterate on next PWMs.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to the first PWM currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmOutput']['clearCache']={syn:'Invalidates the cache.',lib:'pwmoutput&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PwmOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the PWM in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmoutput&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmOutput']['dutyCycleMove']={syn:'Performs a smooth change of the pulse duration toward a given value.',lib:'pwmoutput&rarr;dutyCycleMove()',pro:'int dutyCycleMove(double <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth change of the pulse duration toward a given value.</p>',par:{target:'new duty cycle at the end of the transition (floating-point number, between 0 and 1)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['get_advertisedValue']={syn:'Returns the current value of the PWM (no more than 6 characters).',lib:'pwmoutput&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the PWM (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'pwmoutput&rarr;get_dutyCycle()',pro:'double get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmOutput']['get_dutyCycleAtPowerOn']={syn:'Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.',lib:'pwmoutput&rarr;get_dutyCycleAtPowerOn()',pro:'double get_dutyCycleAtPowerOn()',cmt:'<p>Returns the PWMs duty cycle at device power on as a floating point number between 0 and 100.</p>',ret:'a floating point number corresponding to the PWMs duty cycle at device power on as a floating point number between 0 and 100',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLEATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_enabled']={syn:'Returns the state of the PWMs.',lib:'pwmoutput&rarr;get_enabled()',pro:'Y_ENABLED_enum get_enabled()',cmt:'<p>Returns the state of the PWMs.</p>',ret:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>, according to the state of the PWMs',ext:'On failure, throws an exception or returns <tt>Y_ENABLED_INVALID</tt>.'};
doc['PwmOutput']['get_enabledAtPowerOn']={syn:'Returns the state of the PWM at device power on.',lib:'pwmoutput&rarr;get_enabledAtPowerOn()',pro:'Y_ENABLEDATPOWERON_enum get_enabledAtPowerOn()',cmt:'<p>Returns the state of the PWM at device power on.</p>',ret:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATPOWERON_INVALID</tt>.'};
doc['PwmOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the PWM.',lib:'pwmoutput&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM object'};
doc['PwmOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the PWM.',lib:'pwmoutput&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM object'};
doc['PwmOutput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'pwmoutput&rarr;get_frequency()',pro:'double get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmOutput']['get_friendlyName']={syn:'Returns a global identifier of the PWM in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwmoutput&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwmoutput&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmOutput']['get_functionId']={syn:'Returns the hardware identifier of the PWM, without reference to the module.',lib:'pwmoutput&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the PWM in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmoutput&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmOutput']['get_logicalName']={syn:'Returns the logical name of the PWM.',lib:'pwmoutput&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the PWM.</p>',ret:'a string corresponding to the logical name of the PWM.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwmoutput&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmOutput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'pwmoutput&rarr;get_period()',pro:'double get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmOutput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'pwmoutput&rarr;get_pulseDuration()',pro:'double get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwmoutput&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmOutput']['isOnline']={syn:'Checks if the PWM is currently reachable, without raising any error.',lib:'pwmoutput&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the PWM is currently reachable, without raising any error. If there is a cached value for the PWM in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM.</p>',ret:'<tt>true</tt> if the PWM can be reached, and <tt>false</tt> otherwise'};
doc['PwmOutput']['load']={syn:'Preloads the PWM cache with a specified validity duration.',lib:'pwmoutput&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pwmoutput&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PwmOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pwmoutput&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['nextPwmOutput']={syn:'Continues the enumeration of PWMs started using <tt>yFirstPwmOutput()</tt>.',lib:'pwmoutput&rarr;nextPwmOutput()',pro:'YPwmOutput * nextPwmOutput()',cmt:'<p>Continues the enumeration of PWMs started using <tt>yFirstPwmOutput()</tt>.</p>',ret:'a pointer to a <tt>YPwmOutput</tt> object, corresponding to a PWM currently online, or a <tt>null</tt> pointer if there are no more PWMs to enumerate.'};
doc['PwmOutput']['pulseDurationMove']={syn:'Performs a smooth transistion of the pulse duration toward a given value.',lib:'pwmoutput&rarr;pulseDurationMove()',pro:'int pulseDurationMove(double <span id=pn>ms_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transistion of the pulse duration toward a given value. Any period, frequency, duty cycle or pulse width change will cancel any ongoing transition process.</p>',par:{ms_target:'new pulse duration at the end of the transition (floating-point number, representing the pulse duration in milliseconds)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwmoutput&rarr;registerValueCallback()',pro:'int registerValueCallback(YPwmOutputValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmOutput']['set_dutyCycle']={syn:'Changes the PWM duty cycle, in per cents.',lib:'pwmoutput&rarr;set_dutyCycle()',pro:'int set_dutyCycle(double <span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle, in per cents.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_dutyCycleAtPowerOn']={syn:'Changes the PWM duty cycle at device power on.',lib:'pwmoutput&rarr;set_dutyCycleAtPowerOn()',pro:'int set_dutyCycleAtPowerOn(double <span id=pn>newval</span>)',cmt:'<p>Changes the PWM duty cycle at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'a floating point number corresponding to the PWM duty cycle at device power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_enabled']={syn:'Stops or starts the PWM.',lib:'pwmoutput&rarr;set_enabled()',pro:'int set_enabled(Y_ENABLED_enum <span id=pn>newval</span>)',cmt:'<p>Stops or starts the PWM.</p>',par:{newval:'either <tt>Y_ENABLED_FALSE</tt> or <tt>Y_ENABLED_TRUE</tt>'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_enabledAtPowerOn']={syn:'Changes the state of the PWM at device power on.',lib:'pwmoutput&rarr;set_enabledAtPowerOn()',pro:'int set_enabledAtPowerOn(Y_ENABLEDATPOWERON_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the PWM at device power on. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call will have no effect.</p>',par:{newval:'either <tt>Y_ENABLEDATPOWERON_FALSE</tt> or <tt>Y_ENABLEDATPOWERON_TRUE</tt>, according to the state of the PWM at device power on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_frequency']={syn:'Changes the PWM frequency.',lib:'pwmoutput&rarr;set_frequency()',pro:'int set_frequency(double <span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency. The duty cycle is kept unchanged thanks to an automatic pulse width change.</p>',par:{newval:'a floating point number corresponding to the PWM frequency'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_logicalName']={syn:'Changes the logical name of the PWM.',lib:'pwmoutput&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_period']={syn:'Changes the PWM period in milliseconds.',lib:'pwmoutput&rarr;set_period()',pro:'int set_period(double <span id=pn>newval</span>)',cmt:'<p>Changes the PWM period in milliseconds.</p>',par:{newval:'a floating point number corresponding to the PWM period in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_pulseDuration']={syn:'Changes the PWM pulse length, in milliseconds.',lib:'pwmoutput&rarr;set_pulseDuration()',pro:'int set_pulseDuration(double <span id=pn>newval</span>)',cmt:'<p>Changes the PWM pulse length, in milliseconds. A pulse length cannot be longer than period, otherwise it is truncated.</p>',par:{newval:'a floating point number corresponding to the PWM pulse length, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwmoutput&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pwmoutput&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PwmOutput)
//--- (generated code: PwmPowerSource)
doc['PwmPowerSource']={'':{syn:'PwmPowerSource function interface',inc:'#include &quot;yocto_pwmpowersource.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to configure the voltage source used by all PWM on the same device.</p>'}};
doc['PwmPowerSource']['FindPwmPowerSource']={syn:'Retrieves a voltage source for a given identifier.',lib:'YPwmPowerSource::FindPwmPowerSource()',pro:'YPwmPowerSource* FindPwmPowerSource(string <span id=pn>func</span>)',cmt:'<p>Retrieves a voltage source for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage source is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmPowerSource.isOnline()</tt> to test if the voltage source is indeed online at a given time. In case of ambiguity when looking for a voltage source by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage source'},ret:'a <tt>YPwmPowerSource</tt> object allowing you to drive the voltage source.'};
doc['PwmPowerSource']['FirstPwmPowerSource']={syn:'Starts the enumeration of Voltage sources currently accessible.',lib:'YPwmPowerSource::FirstPwmPowerSource()',pro:'YPwmPowerSource* FirstPwmPowerSource()',cmt:'<p>Starts the enumeration of Voltage sources currently accessible. Use the method <tt>YPwmPowerSource.nextPwmPowerSource()</tt> to iterate on next Voltage sources.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to the first source currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmPowerSource']['clearCache']={syn:'Invalidates the cache.',lib:'pwmpowersource&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage source attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PwmPowerSource']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwmpowersource&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage source in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage source (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmPowerSource']['get_advertisedValue']={syn:'Returns the current value of the voltage source (no more than 6 characters).',lib:'pwmpowersource&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the voltage source (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage source (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmPowerSource']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage source.',lib:'pwmpowersource&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage source object'};
doc['PwmPowerSource']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage source.',lib:'pwmpowersource&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage source. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage source object'};
doc['PwmPowerSource']['get_friendlyName']={syn:'Returns a global identifier of the voltage source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwmpowersource&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage source in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage source if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage source (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage source using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwmpowersource&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmPowerSource']['get_functionId']={syn:'Returns the hardware identifier of the voltage source, without reference to the module.',lib:'pwmpowersource&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage source, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage source (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmPowerSource']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage source in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwmpowersource&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage source in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage source (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage source (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmPowerSource']['get_logicalName']={syn:'Returns the logical name of the voltage source.',lib:'pwmpowersource&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the voltage source.</p>',ret:'a string corresponding to the logical name of the voltage source.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmPowerSource']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwmpowersource&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmPowerSource']['get_powerMode']={syn:'Returns the selected power source for the PWM on the same device.',lib:'pwmpowersource&rarr;get_powerMode()',pro:'Y_POWERMODE_enum get_powerMode()',cmt:'<p>Returns the selected power source for the PWM on the same device.</p>',ret:'a value among <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> and <tt>Y_POWERMODE_OPNDRN</tt> corresponding to the selected power source for the PWM on the same device',ext:'On failure, throws an exception or returns <tt>Y_POWERMODE_INVALID</tt>.'};
doc['PwmPowerSource']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwmpowersource&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmPowerSource']['isOnline']={syn:'Checks if the voltage source is currently reachable, without raising any error.',lib:'pwmpowersource&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the voltage source is currently reachable, without raising any error. If there is a cached value for the voltage source in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage source.</p>',ret:'<tt>true</tt> if the voltage source can be reached, and <tt>false</tt> otherwise'};
doc['PwmPowerSource']['load']={syn:'Preloads the voltage source cache with a specified validity duration.',lib:'pwmpowersource&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage source cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pwmpowersource&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PwmPowerSource']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pwmpowersource&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['nextPwmPowerSource']={syn:'Continues the enumeration of Voltage sources started using <tt>yFirstPwmPowerSource()</tt>.',lib:'pwmpowersource&rarr;nextPwmPowerSource()',pro:'YPwmPowerSource * nextPwmPowerSource()',cmt:'<p>Continues the enumeration of Voltage sources started using <tt>yFirstPwmPowerSource()</tt>.</p>',ret:'a pointer to a <tt>YPwmPowerSource</tt> object, corresponding to a voltage source currently online, or a <tt>null</tt> pointer if there are no more Voltage sources to enumerate.'};
doc['PwmPowerSource']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwmpowersource&rarr;registerValueCallback()',pro:'int registerValueCallback(YPwmPowerSourceValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmPowerSource']['set_logicalName']={syn:'Changes the logical name of the voltage source.',lib:'pwmpowersource&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage source. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage source.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['set_powerMode']={syn:'Changes the PWM power source.',lib:'pwmpowersource&rarr;set_powerMode()',pro:'int set_powerMode(Y_POWERMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the PWM power source. PWM can use isolated 5V from USB, isolated 3V from USB or voltage from an external power source. The PWM can also work in open drain mode. In that mode, the PWM actively pulls the line down. Warning: this setting is common to all PWM on the same device. If you change that parameter, all PWM located on the same device are affected. If you want the change to be kept after a device reboot, make sure to call the matching module <tt>saveToFlash()</tt>.</p>',par:{newval:'a value among <tt>Y_POWERMODE_USB_5V</tt>, <tt>Y_POWERMODE_USB_3V</tt>, <tt>Y_POWERMODE_EXT_V</tt> and <tt>Y_POWERMODE_OPNDRN</tt> corresponding to the PWM power source'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmPowerSource']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwmpowersource&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmPowerSource']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pwmpowersource&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PwmPowerSource)
//--- (generated code: Altitude)
doc['Altitude']={'':{syn:'Altitude function interface',inc:'#include &quot;yocto_altitude.h&quot;',cmt:'<p>The Yoctopuce class YAltitude allows you to read and configure Yoctopuce altitude sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the barometric pressure adjusted to sea level (QNH) for barometric sensors.</p>'}};
doc['Altitude']['FindAltitude']={syn:'Retrieves an altimeter for a given identifier.',lib:'YAltitude::FindAltitude()',pro:'YAltitude* FindAltitude(string <span id=pn>func</span>)',cmt:'<p>Retrieves an altimeter for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the altimeter is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAltitude.isOnline()</tt> to test if the altimeter is indeed online at a given time. In case of ambiguity when looking for an altimeter by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the altimeter'},ret:'a <tt>YAltitude</tt> object allowing you to drive the altimeter.'};
doc['Altitude']['FirstAltitude']={syn:'Starts the enumeration of altimeters currently accessible.',lib:'YAltitude::FirstAltitude()',pro:'YAltitude* FirstAltitude()',cmt:'<p>Starts the enumeration of altimeters currently accessible. Use the method <tt>YAltitude.nextAltitude()</tt> to iterate on next altimeters.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to the first altimeter currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Altitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'altitude&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['clearCache']={syn:'Invalidates the cache.',lib:'altitude&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the altimeter attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Altitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'altitude&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the altimeter in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the altimeter (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Altitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'altitude&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Altitude']['get_advertisedValue']={syn:'Returns the current value of the altimeter (no more than 6 characters).',lib:'altitude&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the altimeter (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the altimeter (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.',lib:'altitude&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Altitude']['get_currentValue']={syn:'Returns the current value of the altitude, in meters, as a floating point number.',lib:'altitude&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the altitude, in meters, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the altitude, in meters, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Altitude']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'altitude&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Altitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the altimeter.',lib:'altitude&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the altimeter object'};
doc['Altitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the altimeter.',lib:'altitude&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the altimeter. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the altimeter object'};
doc['Altitude']['get_friendlyName']={syn:'Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'altitude&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the altimeter in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the altimeter if they are defined, otherwise the serial number of the module and the hardware identifier of the altimeter (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the altimeter using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Altitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'altitude&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Altitude']['get_functionId']={syn:'Returns the hardware identifier of the altimeter, without reference to the module.',lib:'altitude&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the altimeter, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the altimeter (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Altitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'altitude&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the altimeter in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the altimeter (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the altimeter (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Altitude']['get_highestValue']={syn:'Returns the maximal value observed for the altitude since the device was started.',lib:'altitude&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'altitude&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_logicalName']={syn:'Returns the logical name of the altimeter.',lib:'altitude&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the altimeter.</p>',ret:'a string corresponding to the logical name of the altimeter.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Altitude']['get_lowestValue']={syn:'Returns the minimal value observed for the altitude since the device was started.',lib:'altitude&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the altitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the altitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Altitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'altitude&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Altitude']['get_qnh']={syn:'Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'altitude&rarr;get_qnh()',pro:'double get_qnh()',cmt:'<p>Returns the barometric pressure adjusted to sea level used to compute the altitude (QNH).</p>',ret:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)',ext:'On failure, throws an exception or returns <tt>Y_QNH_INVALID</tt>.'};
doc['Altitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'altitude&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Altitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'altitude&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Altitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'altitude&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Altitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'altitude&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Altitude']['get_technology']={syn:'Returns the technology used by the sesnor to compute altitude.',lib:'altitude&rarr;get_technology()',pro:'string get_technology()',cmt:'<p>Returns the technology used by the sesnor to compute altitude. Possibles values are \x22barometric\x22 and \x22gps\x22</p>',ret:'a string corresponding to the technology used by the sesnor to compute altitude',ext:'On failure, throws an exception or returns <tt>Y_TECHNOLOGY_INVALID</tt>.'};
doc['Altitude']['get_unit']={syn:'Returns the measuring unit for the altitude.',lib:'altitude&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the altitude.</p>',ret:'a string corresponding to the measuring unit for the altitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Altitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'altitude&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Altitude']['isOnline']={syn:'Checks if the altimeter is currently reachable, without raising any error.',lib:'altitude&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the altimeter is currently reachable, without raising any error. If there is a cached value for the altimeter in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the altimeter.</p>',ret:'<tt>true</tt> if the altimeter can be reached, and <tt>false</tt> otherwise'};
doc['Altitude']['load']={syn:'Preloads the altimeter cache with a specified validity duration.',lib:'altitude&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the altimeter cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'altitude&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Altitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'altitude&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'altitude&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['nextAltitude']={syn:'Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>.',lib:'altitude&rarr;nextAltitude()',pro:'YAltitude * nextAltitude()',cmt:'<p>Continues the enumeration of altimeters started using <tt>yFirstAltitude()</tt>.</p>',ret:'a pointer to a <tt>YAltitude</tt> object, corresponding to an altimeter currently online, or a <tt>null</tt> pointer if there are no more altimeters to enumerate.'};
doc['Altitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'altitude&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YAltitudeTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Altitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'altitude&rarr;registerValueCallback()',pro:'int registerValueCallback(YAltitudeValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Altitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'altitude&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_currentValue']={syn:'Changes the current estimated altitude.',lib:'altitude&rarr;set_currentValue()',pro:'int set_currentValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the current estimated altitude. This allows to compensate for ambient pressure variations and to work in relative mode.</p>',par:{newval:'a floating point number corresponding to the current estimated altitude'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'altitude&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'altitude&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_logicalName']={syn:'Changes the logical name of the altimeter.',lib:'altitude&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the altimeter. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the altimeter.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'altitude&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_qnh']={syn:'Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH).',lib:'altitude&rarr;set_qnh()',pro:'int set_qnh(double <span id=pn>newval</span>)',cmt:'<p>Changes the barometric pressure adjusted to sea level used to compute the altitude (QNH). This enables you to compensate for atmospheric pressure changes due to weather conditions.</p>',par:{newval:'a floating point number corresponding to the barometric pressure adjusted to sea level used to compute the altitude (QNH)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'altitude&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'altitude&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Altitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'altitude&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Altitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'altitude&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Altitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'altitude&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Altitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'altitude&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Altitude)
//--- (generated code: Motor)
doc['Motor']={'':{syn:'Motor function interface',inc:'#include &quot;yocto_motor.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to drive the power sent to the motor to make it turn both ways, but also to drive accelerations and decelerations. The motor will then accelerate automatically: you will not have to monitor it. The API also allows to slow down the motor by shortening its terminals: the motor will then act as an electromagnetic brake.</p>'}};
doc['Motor']['FindMotor']={syn:'Retrieves a motor for a given identifier.',lib:'YMotor::FindMotor()',pro:'YMotor* FindMotor(string <span id=pn>func</span>)',cmt:'<p>Retrieves a motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMotor.isOnline()</tt> to test if the motor is indeed online at a given time. In case of ambiguity when looking for a motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the motor'},ret:'a <tt>YMotor</tt> object allowing you to drive the motor.'};
doc['Motor']['FirstMotor']={syn:'Starts the enumeration of motors currently accessible.',lib:'YMotor::FirstMotor()',pro:'YMotor* FirstMotor()',cmt:'<p>Starts the enumeration of motors currently accessible. Use the method <tt>YMotor.nextMotor()</tt> to iterate on next motors.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to the first motor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Motor']['brakingForceMove']={syn:'Changes progressively the braking force applied to the motor for a specific duration.',lib:'motor&rarr;brakingForceMove()',pro:'int brakingForceMove(double <span id=pn>targetPower</span>, int <span id=pn>delay</span>)',cmt:'<p>Changes progressively the braking force applied to the motor for a specific duration.</p>',par:{targetPower:'desired braking force, in percents',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['clearCache']={syn:'Invalidates the cache.',lib:'motor&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Motor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'motor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Motor']['drivingForceMove']={syn:'Changes progressively the power sent to the moteur for a specific duration.',lib:'motor&rarr;drivingForceMove()',pro:'int drivingForceMove(double <span id=pn>targetPower</span>, int <span id=pn>delay</span>)',cmt:'<p>Changes progressively the power sent to the moteur for a specific duration.</p>',par:{targetPower:'desired motor power, in percents (between -100% and +100%)',delay:'duration (in ms) of the transition'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['get_advertisedValue']={syn:'Returns the current value of the motor (no more than 6 characters).',lib:'motor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Motor']['get_brakingForce']={syn:'Returns the braking force applied to the motor, as a percentage.',lib:'motor&rarr;get_brakingForce()',pro:'double get_brakingForce()',cmt:'<p>Returns the braking force applied to the motor, as a percentage. The value 0 corresponds to no braking (free wheel).</p>',ret:'a floating point number corresponding to the braking force applied to the motor, as a percentage',ext:'On failure, throws an exception or returns <tt>Y_BRAKINGFORCE_INVALID</tt>.'};
doc['Motor']['get_cutOffVoltage']={syn:'Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'motor&rarr;get_cutOffVoltage()',pro:'double get_cutOffVoltage()',cmt:'<p>Returns the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevents damage to a battery that can occur when drawing current from an \x22empty\x22 battery.</p>',ret:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw',ext:'On failure, throws an exception or returns <tt>Y_CUTOFFVOLTAGE_INVALID</tt>.'};
doc['Motor']['get_drivingForce']={syn:'Returns the power sent to the motor, as a percentage between -100% and +100%.',lib:'motor&rarr;get_drivingForce()',pro:'double get_drivingForce()',cmt:'<p>Returns the power sent to the motor, as a percentage between -100% and +100%.</p>',ret:'a floating point number corresponding to the power sent to the motor, as a percentage between -100% and +100%',ext:'On failure, throws an exception or returns <tt>Y_DRIVINGFORCE_INVALID</tt>.'};
doc['Motor']['get_errorMessage']={syn:'Returns the error message of the latest error with the motor.',lib:'motor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the motor object'};
doc['Motor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the motor.',lib:'motor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the motor object'};
doc['Motor']['get_failSafeTimeout']={syn:'Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'motor&rarr;get_failSafeTimeout()',pro:'int get_failSafeTimeout()',cmt:'<p>Returns the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',ret:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process',ext:'On failure, throws an exception or returns <tt>Y_FAILSAFETIMEOUT_INVALID</tt>.'};
doc['Motor']['get_frequency']={syn:'Returns the PWM frequency used to control the motor.',lib:'motor&rarr;get_frequency()',pro:'double get_frequency()',cmt:'<p>Returns the PWM frequency used to control the motor.</p>',ret:'a floating point number corresponding to the PWM frequency used to control the motor',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Motor']['get_friendlyName']={syn:'Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'motor&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the motor if they are defined, otherwise the serial number of the module and the hardware identifier of the motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Motor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'motor&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Motor']['get_functionId']={syn:'Returns the hardware identifier of the motor, without reference to the module.',lib:'motor&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Motor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'motor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Motor']['get_logicalName']={syn:'Returns the logical name of the motor.',lib:'motor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the motor.</p>',ret:'a string corresponding to the logical name of the motor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Motor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'motor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Motor']['get_motorStatus']={syn:'Return the controller state.',lib:'motor&rarr;get_motorStatus()',pro:'Y_MOTORSTATUS_enum get_motorStatus()',cmt:'<p>Return the controller state. Possible states are: IDLE when the motor is stopped/in free wheel, ready to start; FORWD when the controller is driving the motor forward; BACKWD when the controller is driving the motor backward; BRAKE when the controller is braking; LOVOLT when the controller has detected a low voltage condition; HICURR when the controller has detected an overcurrent condition; HIHEAT when the controller has detected an overheat condition; FAILSF when the controller switched on the failsafe security.</p><p> When an error condition occurred (LOVOLT, HICURR, HIHEAT, FAILSF), the controller status must be explicitly reset using the <tt>resetStatus</tt> function.</p>',ret:'a value among <tt>Y_MOTORSTATUS_IDLE</tt>, <tt>Y_MOTORSTATUS_BRAKE</tt>, <tt>Y_MOTORSTATUS_FORWD</tt>, <tt>Y_MOTORSTATUS_BACKWD</tt>, <tt>Y_MOTORSTATUS_LOVOLT</tt>, <tt>Y_MOTORSTATUS_HICURR</tt>, <tt>Y_MOTORSTATUS_HIHEAT</tt> and <tt>Y_MOTORSTATUS_FAILSF</tt>',ext:'On failure, throws an exception or returns <tt>Y_MOTORSTATUS_INVALID</tt>.'};
doc['Motor']['get_overCurrentLimit']={syn:'Returns the current threshold (in mA) above which the controller automatically switches to error state.',lib:'motor&rarr;get_overCurrentLimit()',pro:'int get_overCurrentLimit()',cmt:'<p>Returns the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit.</p>',ret:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENTLIMIT_INVALID</tt>.'};
doc['Motor']['get_starterTime']={syn:'Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'motor&rarr;get_starterTime()',pro:'int get_starterTime()',cmt:'<p>Returns the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',ret:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up',ext:'On failure, throws an exception or returns <tt>Y_STARTERTIME_INVALID</tt>.'};
doc['Motor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'motor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Motor']['isOnline']={syn:'Checks if the motor is currently reachable, without raising any error.',lib:'motor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the motor is currently reachable, without raising any error. If there is a cached value for the motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the motor.</p>',ret:'<tt>true</tt> if the motor can be reached, and <tt>false</tt> otherwise'};
doc['Motor']['keepALive']={syn:'Rearms the controller failsafe timer.',lib:'motor&rarr;keepALive()',pro:'int keepALive()',cmt:'<p>Rearms the controller failsafe timer. When the motor is running and the failsafe feature is active, this function should be called periodically to prove that the control process is running properly. Otherwise, the motor is automatically stopped after the specified timeout. Calling a motor <i>set</i> function implicitely rearms the failsafe timer.</p>'};
doc['Motor']['load']={syn:'Preloads the motor cache with a specified validity duration.',lib:'motor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'motor&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Motor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'motor&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['nextMotor']={syn:'Continues the enumeration of motors started using <tt>yFirstMotor()</tt>.',lib:'motor&rarr;nextMotor()',pro:'YMotor * nextMotor()',cmt:'<p>Continues the enumeration of motors started using <tt>yFirstMotor()</tt>.</p>',ret:'a pointer to a <tt>YMotor</tt> object, corresponding to a motor currently online, or a <tt>null</tt> pointer if there are no more motors to enumerate.'};
doc['Motor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'motor&rarr;registerValueCallback()',pro:'int registerValueCallback(YMotorValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Motor']['resetStatus']={syn:'Reset the controller state to IDLE.',lib:'motor&rarr;resetStatus()',pro:'int resetStatus()',cmt:'<p>Reset the controller state to IDLE. This function must be invoked explicitely after any error condition is signaled.</p>'};
doc['Motor']['set_brakingForce']={syn:'Changes immediately the braking force applied to the motor (in percents).',lib:'motor&rarr;set_brakingForce()',pro:'int set_brakingForce(double <span id=pn>newval</span>)',cmt:'<p>Changes immediately the braking force applied to the motor (in percents). The value 0 corresponds to no braking (free wheel). When the braking force is changed, the driving power is set to zero. The value is a percentage.</p>',par:{newval:'a floating point number corresponding to immediately the braking force applied to the motor (in percents)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_cutOffVoltage']={syn:'Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw.',lib:'motor&rarr;set_cutOffVoltage()',pro:'int set_cutOffVoltage(double <span id=pn>newval</span>)',cmt:'<p>Changes the threshold voltage under which the controller automatically switches to error state and prevents further current draw. This setting prevent damage to a battery that can occur when drawing current from an \x22empty\x22 battery. Note that whatever the cutoff threshold, the controller switches to undervoltage error state if the power supply goes under 3V, even for a very brief time.</p>',par:{newval:'a floating point number corresponding to the threshold voltage under which the controller automatically switches to error state and prevents further current draw'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_drivingForce']={syn:'Changes immediately the power sent to the motor.',lib:'motor&rarr;set_drivingForce()',pro:'int set_drivingForce(double <span id=pn>newval</span>)',cmt:'<p>Changes immediately the power sent to the motor. The value is a percentage between -100% to 100%. If you want go easy on your mechanics and avoid excessive current consumption, try to avoid brutal power changes. For example, immediate transition from forward full power to reverse full power is a very bad idea. Each time the driving power is modified, the braking power is set to zero.</p>',par:{newval:'a floating point number corresponding to immediately the power sent to the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_failSafeTimeout']={syn:'Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process.',lib:'motor&rarr;set_failSafeTimeout()',pro:'int set_failSafeTimeout(int <span id=pn>newval</span>)',cmt:'<p>Changes the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process. When this delay has elapsed, the controller automatically stops the motor and switches to FAILSAFE error. Failsafe security is disabled when the value is zero.</p>',par:{newval:'an integer corresponding to the delay in milliseconds allowed for the controller to run autonomously without receiving any instruction from the control process'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_frequency']={syn:'Changes the PWM frequency used to control the motor.',lib:'motor&rarr;set_frequency()',pro:'int set_frequency(double <span id=pn>newval</span>)',cmt:'<p>Changes the PWM frequency used to control the motor. Low frequency is usually more efficient and may help the motor to start, but an audible noise might be generated. A higher frequency reduces the noise, but more energy is converted into heat.</p>',par:{newval:'a floating point number corresponding to the PWM frequency used to control the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_logicalName']={syn:'Changes the logical name of the motor.',lib:'motor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the motor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_overCurrentLimit']={syn:'Changes the current threshold (in mA) above which the controller automatically switches to error state.',lib:'motor&rarr;set_overCurrentLimit()',pro:'int set_overCurrentLimit(int <span id=pn>newval</span>)',cmt:'<p>Changes the current threshold (in mA) above which the controller automatically switches to error state. A zero value means that there is no limit. Note that whatever the current limit is, the controller switches to OVERCURRENT status if the current goes above 32A, even for a very brief time.</p>',par:{newval:'an integer corresponding to the current threshold (in mA) above which the controller automatically switches to error state'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_starterTime']={syn:'Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.',lib:'motor&rarr;set_starterTime()',pro:'int set_starterTime(int <span id=pn>newval</span>)',cmt:'<p>Changes the duration (in ms) during which the motor is driven at low frequency to help it start up.</p>',par:{newval:'an integer corresponding to the duration (in ms) during which the motor is driven at low frequency to help it start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Motor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'motor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Motor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'motor&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Motor)
//--- (generated code: SerialPort)
doc['SerialPort']={'':{syn:'SerialPort function interface',inc:'#include &quot;yocto_serialport.h&quot;',cmt:'<p>The SerialPort function interface allows you to fully drive a Yoctopuce serial port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce serial ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SerialPort']['FindSerialPort']={syn:'Retrieves a serial port for a given identifier.',lib:'YSerialPort::FindSerialPort()',pro:'YSerialPort* FindSerialPort(string <span id=pn>func</span>)',cmt:'<p>Retrieves a serial port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the serial port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSerialPort.isOnline()</tt> to test if the serial port is indeed online at a given time. In case of ambiguity when looking for a serial port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the serial port'},ret:'a <tt>YSerialPort</tt> object allowing you to drive the serial port.'};
doc['SerialPort']['FirstSerialPort']={syn:'Starts the enumeration of serial ports currently accessible.',lib:'YSerialPort::FirstSerialPort()',pro:'YSerialPort* FirstSerialPort()',cmt:'<p>Starts the enumeration of serial ports currently accessible. Use the method <tt>YSerialPort.nextSerialPort()</tt> to iterate on next serial ports.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to the first serial port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SerialPort']['clearCache']={syn:'Invalidates the cache.',lib:'serialport&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the serial port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['SerialPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'serialport&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the serial port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the serial port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SerialPort']['get_CTS']={syn:'Reads the level of the CTS line.',lib:'serialport&rarr;get_CTS()',pro:'int get_CTS()',cmt:'<p>Reads the level of the CTS line. The CTS line is usually driven by the RTS signal of the connected serial device.</p>',ret:'1 if the CTS line is high, 0 if the CTS line is low.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['get_advertisedValue']={syn:'Returns the current value of the serial port (no more than 6 characters).',lib:'serialport&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the serial port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the serial port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SerialPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'serialport&rarr;get_currentJob()',pro:'string get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SerialPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'serialport&rarr;get_errCount()',pro:'int get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the serial port.',lib:'serialport&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the serial port object'};
doc['SerialPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the serial port.',lib:'serialport&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the serial port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the serial port object'};
doc['SerialPort']['get_friendlyName']={syn:'Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'serialport&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the serial port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the serial port if they are defined, otherwise the serial number of the module and the hardware identifier of the serial port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the serial port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SerialPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'serialport&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SerialPort']['get_functionId']={syn:'Returns the hardware identifier of the serial port, without reference to the module.',lib:'serialport&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the serial port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the serial port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SerialPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'serialport&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the serial port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the serial port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the serial port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SerialPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line, Frame and Modbus protocols).',lib:'serialport&rarr;get_lastMsg()',pro:'string get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line, Frame and Modbus protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line, Frame and Modbus protocols)',ext:'On failure, throws an exception or returns <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SerialPort']['get_logicalName']={syn:'Returns the logical name of the serial port.',lib:'serialport&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the serial port.</p>',ret:'a string corresponding to the logical name of the serial port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SerialPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'serialport&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SerialPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'serialport&rarr;get_protocol()',pro:'string get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SerialPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'serialport&rarr;get_rxCount()',pro:'int get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'serialport&rarr;get_rxMsgCount()',pro:'int get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_serialMode']={syn:'Returns the serial port communication parameters, as a string such as \x229600,8N1\x22.',lib:'serialport&rarr;get_serialMode()',pro:'string get_serialMode()',cmt:'<p>Returns the serial port communication parameters, as a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix is included if flow control is active: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',ret:'a string corresponding to the serial port communication parameters, as a string such as \x229600,8N1\x22',ext:'On failure, throws an exception or returns <tt>Y_SERIALMODE_INVALID</tt>.'};
doc['SerialPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'serialport&rarr;get_startupJob()',pro:'string get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SerialPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'serialport&rarr;get_txCount()',pro:'int get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'serialport&rarr;get_txMsgCount()',pro:'int get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SerialPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'serialport&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SerialPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'serialport&rarr;get_voltageLevel()',pro:'Y_VOLTAGELEVEL_enum get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SerialPort']['isOnline']={syn:'Checks if the serial port is currently reachable, without raising any error.',lib:'serialport&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the serial port is currently reachable, without raising any error. If there is a cached value for the serial port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the serial port.</p>',ret:'<tt>true</tt> if the serial port can be reached, and <tt>false</tt> otherwise'};
doc['SerialPort']['load']={syn:'Preloads the serial port cache with a specified validity duration.',lib:'serialport&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the serial port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'serialport&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['SerialPort']['modbusReadBits']={syn:'Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device.',lib:'serialport&rarr;modbusReadBits()',pro:'vector&lt;int&gt; modbusReadBits(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, int <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous internal bits (or coil status) from a MODBUS serial device. This method uses the MODBUS function code 0x01 (Read Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/coil to read (zero-based)',nBits:'the number of bits/coils to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadInputBits']={syn:'Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device.',lib:'serialport&rarr;modbusReadInputBits()',pro:'vector&lt;int&gt; modbusReadInputBits(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, int <span id=pn>nBits</span>)',cmt:'<p>Reads one or more contiguous input bits (or discrete inputs) from a MODBUS serial device. This method uses the MODBUS function code 0x02 (Read Discrete Inputs).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first bit/input to read (zero-based)',nBits:'the number of bits/inputs to read'},ret:'a vector of integers, each corresponding to one bit.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadInputRegisters']={syn:'Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device.',lib:'serialport&rarr;modbusReadInputRegisters()',pro:'vector&lt;int&gt; modbusReadInputRegisters(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, int <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous input registers (read-only registers) from a MODBUS serial device. This method uses the MODBUS function code 0x04 (Read Input Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first input register to read (zero-based)',nWords:'the number of input registers to read'},ret:'a vector of integers, each corresponding to one 16-bit input value.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusReadRegisters']={syn:'Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device.',lib:'serialport&rarr;modbusReadRegisters()',pro:'vector&lt;int&gt; modbusReadRegisters(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, int <span id=pn>nWords</span>)',cmt:'<p>Reads one or more contiguous internal registers (holding registers) from a MODBUS serial device. This method uses the MODBUS function code 0x03 (Read Holding Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduAddr:'the relative address of the first holding register to read (zero-based)',nWords:'the number of holding registers to read'},ret:'a vector of integers, each corresponding to one 16-bit register value.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusWriteAndReadRegisters']={syn:'Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers.',lib:'serialport&rarr;modbusWriteAndReadRegisters()',pro:'vector&lt;int&gt; modbusWriteAndReadRegisters(int <span id=pn>slaveNo</span>,&nbsp;int <span id=pn>pduWriteAddr</span>,&nbsp;vector&lt;int&gt; <span id=pn>values</span>,&nbsp;int <span id=pn>pduReadAddr</span>,&nbsp;int <span id=pn>nReadWords</span>)',cmt:'<p>Sets several contiguous internal registers (holding registers) on a MODBUS serial device, then performs a contiguous read of a set of (possibly different) internal registers. This method uses the MODBUS function code 0x17 (Read/Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduWriteAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set',pduReadAddr:'the relative address of the first internal register to read (zero-based)',nReadWords:'the number of 16 bit values to read'},ret:'a vector of integers, each corresponding to one 16-bit register value read.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['modbusWriteBit']={syn:'Sets a single internal bit (or coil) on a MODBUS serial device.',lib:'serialport&rarr;modbusWriteBit()',pro:'int modbusWriteBit(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, int <span id=pn>value</span>)',cmt:'<p>Sets a single internal bit (or coil) on a MODBUS serial device. This method uses the MODBUS function code 0x05 (Write Single Coil).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the bit/coil to set (zero-based)',value:'the value to set (0 for OFF state, non-zero for ON state)'},ret:'the number of bits/coils affected on the device (1)',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteBits']={syn:'Sets several contiguous internal bits (or coils) on a MODBUS serial device.',lib:'serialport&rarr;modbusWriteBits()',pro:'int modbusWriteBits(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, vector&lt;int&gt; <span id=pn>bits</span>)',cmt:'<p>Sets several contiguous internal bits (or coils) on a MODBUS serial device. This method uses the MODBUS function code 0x0f (Write Multiple Coils).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first bit/coil to set (zero-based)',bits:'the vector of bits to be set (one integer per bit)'},ret:'the number of bits/coils affected on the device',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteRegister']={syn:'Sets a single internal register (or holding register) on a MODBUS serial device.',lib:'serialport&rarr;modbusWriteRegister()',pro:'int modbusWriteRegister(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, int <span id=pn>value</span>)',cmt:'<p>Sets a single internal register (or holding register) on a MODBUS serial device. This method uses the MODBUS function code 0x06 (Write Single Register).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the register to set (zero-based)',value:'the 16 bit value to set'},ret:'the number of registers affected on the device (1)',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['modbusWriteRegisters']={syn:'Sets several contiguous internal registers (or holding registers) on a MODBUS serial device.',lib:'serialport&rarr;modbusWriteRegisters()',pro:'int modbusWriteRegisters(int <span id=pn>slaveNo</span>, int <span id=pn>pduAddr</span>, vector&lt;int&gt; <span id=pn>values</span>)',cmt:'<p>Sets several contiguous internal registers (or holding registers) on a MODBUS serial device. This method uses the MODBUS function code 0x10 (Write Multiple Registers).</p>',par:{slaveNo:'the address of the slave MODBUS device to drive',pduAddr:'the relative address of the first internal register to set (zero-based)',values:'the vector of 16 bit values to set'},ret:'the number of registers affected on the device',ext:'On failure, throws an exception or returns zero.'};
doc['SerialPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'serialport&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['nextSerialPort']={syn:'Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>.',lib:'serialport&rarr;nextSerialPort()',pro:'YSerialPort * nextSerialPort()',cmt:'<p>Continues the enumeration of serial ports started using <tt>yFirstSerialPort()</tt>.</p>',ret:'a pointer to a <tt>YSerialPort</tt> object, corresponding to a serial port currently online, or a <tt>null</tt> pointer if there are no more serial ports to enumerate.'};
doc['SerialPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'serialport&rarr;queryLine()',pro:'string queryLine(string <span id=pn>query</span>, int <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['queryMODBUS']={syn:'Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any.',lib:'serialport&rarr;queryMODBUS()',pro:'vector&lt;int&gt; queryMODBUS(int <span id=pn>slaveNo</span>, vector&lt;int&gt; <span id=pn>pduBytes</span>)',cmt:'<p>Sends a message to a specified MODBUS slave connected to the serial port, and reads the reply, if any. The message is the PDU, provided as a vector of bytes.</p>',par:{slaveNo:'the address of the slave MODBUS device to query',pduBytes:'the message to send (PDU), as a vector of bytes. The first byte of the PDU is the MODBUS function code.'},ret:'the received reply, as a vector of bytes.',ext:'On failure, throws an exception or returns an empty array (or a MODBUS error reply).'};
doc['SerialPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'serialport&rarr;readArray()',pro:'vector&lt;int&gt; readArray(int <span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'serialport&rarr;readBin()',pro:'string readBin(int <span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'serialport&rarr;readByte()',pro:'int readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'serialport&rarr;readHex()',pro:'string readHex(int <span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'serialport&rarr;readLine()',pro:'string readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'serialport&rarr;readMessages()',pro:'vector&lt;string&gt; readMessages(string <span id=pn>pattern</span>, int <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'serialport&rarr;readStr()',pro:'string readStr(int <span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'serialport&rarr;read_avail()',pro:'int read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'};
doc['SerialPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'serialport&rarr;read_seek()',pro:'int read_seek(int <span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SerialPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the API object.',lib:'serialport&rarr;read_tell()',pro:'int read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'};
doc['SerialPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'serialport&rarr;registerValueCallback()',pro:'int registerValueCallback(YSerialPortValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SerialPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'serialport&rarr;reset()',pro:'int reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'serialport&rarr;selectJob()',pro:'int selectJob(string <span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_RTS']={syn:'Manually sets the state of the RTS line.',lib:'serialport&rarr;set_RTS()',pro:'int set_RTS(int <span id=pn>val</span>)',cmt:'<p>Manually sets the state of the RTS line. This function has no effect when hardware handshake is enabled, as the RTS line is driven automatically.</p>',par:{val:'1 to turn RTS on, 0 to turn RTS off'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'serialport&rarr;set_currentJob()',pro:'int set_currentJob(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_logicalName']={syn:'Changes the logical name of the serial port.',lib:'serialport&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the serial port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the serial port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'serialport&rarr;set_protocol()',pro:'int set_protocol(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Modbus-ASCII\x22 for MODBUS messages in ASCII mode, \x22Modbus-RTU\x22 for MODBUS messages in RTU mode, \x22Wiegand-ASCII\x22 for Wiegand messages in ASCII mode, \x22Wiegand-26\x22,\x22Wiegand-34\x22, etc for Wiegand messages in byte mode, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_serialMode']={syn:'Changes the serial port communication parameters, with a string such as \x229600,8N1\x22.',lib:'serialport&rarr;set_serialMode()',pro:'int set_serialMode(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the serial port communication parameters, with a string such as \x229600,8N1\x22. The string includes the baud rate, the number of data bits, the parity, and the number of stop bits. An optional suffix can be added to enable flow control: \x22CtsRts\x22 for hardware handshake, \x22XOnXOff\x22 for logical flow control and \x22Simplex\x22 for acquiring a shared bus using the RTS line (as used by some RS485 adapters for instance).</p>',par:{newval:'a string corresponding to the serial port communication parameters, with a string such as \x229600,8N1\x22'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'serialport&rarr;set_startupJob()',pro:'int set_startupJob(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'serialport&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SerialPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'serialport&rarr;set_voltageLevel()',pro:'int set_voltageLevel(Y_VOLTAGELEVEL_enum <span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['snoopMessages']={syn:'Retrieves messages (both direction) in the serial port buffer, starting at current position.',lib:'serialport&rarr;snoopMessages()',pro:'vector&lt;YSnoopingRecord&gt; snoopMessages(int <span id=pn>maxWait</span>)',cmt:'<p>Retrieves messages (both direction) in the serial port buffer, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> If no message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of YSnoopingRecord objects containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SerialPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'serialport&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'serialport&rarr;uploadJob()',pro:'int uploadJob(string <span id=pn>jobfile</span>, string <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'serialport&rarr;writeArray()',pro:'int writeArray(vector&lt;int&gt; <span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'serialport&rarr;writeBin()',pro:'int writeBin(string <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'serialport&rarr;writeByte()',pro:'int writeByte(int <span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'serialport&rarr;writeHex()',pro:'int writeHex(string <span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'serialport&rarr;writeLine()',pro:'int writeLine(string <span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeMODBUS']={syn:'Sends a MODBUS message (provided as a hexadecimal string) to the serial port.',lib:'serialport&rarr;writeMODBUS()',pro:'int writeMODBUS(string <span id=pn>hexString</span>)',cmt:'<p>Sends a MODBUS message (provided as a hexadecimal string) to the serial port. The message must start with the slave address. The MODBUS CRC/LRC is automatically added by the function. This function does not wait for a reply.</p>',par:{hexString:'a hexadecimal message string, including device address but no CRC/LRC'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SerialPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'serialport&rarr;writeStr()',pro:'int writeStr(string <span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SerialPort)
//--- (generated code: PwmInput)
doc['PwmInput']={'':{syn:'PwmInput function interface',inc:'#include &quot;yocto_pwminput.h&quot;',cmt:'<p>The Yoctopuce class YPwmInput allows you to read and configure Yoctopuce PWM sensors. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to configure the signal parameter used to transmit information: the duty cycle, the frequency or the pulse width.</p>'}};
doc['PwmInput']['FindPwmInput']={syn:'Retrieves a PWM input for a given identifier.',lib:'YPwmInput::FindPwmInput()',pro:'YPwmInput* FindPwmInput(string <span id=pn>func</span>)',cmt:'<p>Retrieves a PWM input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the PWM input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPwmInput.isOnline()</tt> to test if the PWM input is indeed online at a given time. In case of ambiguity when looking for a PWM input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the PWM input'},ret:'a <tt>YPwmInput</tt> object allowing you to drive the PWM input.'};
doc['PwmInput']['FirstPwmInput']={syn:'Starts the enumeration of PWM inputs currently accessible.',lib:'YPwmInput::FirstPwmInput()',pro:'YPwmInput* FirstPwmInput()',cmt:'<p>Starts the enumeration of PWM inputs currently accessible. Use the method <tt>YPwmInput.nextPwmInput()</tt> to iterate on next PWM inputs.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to the first PWM input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PwmInput']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'pwminput&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['clearCache']={syn:'Invalidates the cache.',lib:'pwminput&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the PWM input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PwmInput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pwminput&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the PWM input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the PWM input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PwmInput']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'pwminput&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['PwmInput']['get_advertisedValue']={syn:'Returns the current value of the PWM input (no more than 6 characters).',lib:'pwminput&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the PWM input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the PWM input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.',lib:'pwminput&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in HZ, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['PwmInput']['get_currentValue']={syn:'Returns the current value of the PwmInput feature as a floating point number.',lib:'pwminput&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the PwmInput feature as a floating point number. Depending on the pwmReportMode setting, this can be the frequency, in Hz, the duty cycle in %, the pulse length in ms, etc.</p>',ret:'a floating point number corresponding to the current value of the PwmInput feature as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'pwminput&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['PwmInput']['get_debouncePeriod']={syn:'Returns the shortest expected pulse duration, in ms.',lib:'pwminput&rarr;get_debouncePeriod()',pro:'int get_debouncePeriod()',cmt:'<p>Returns the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',ret:'an integer corresponding to the shortest expected pulse duration, in ms',ext:'On failure, throws an exception or returns <tt>Y_DEBOUNCEPERIOD_INVALID</tt>.'};
doc['PwmInput']['get_dutyCycle']={syn:'Returns the PWM duty cycle, in per cents.',lib:'pwminput&rarr;get_dutyCycle()',pro:'double get_dutyCycle()',cmt:'<p>Returns the PWM duty cycle, in per cents.</p>',ret:'a floating point number corresponding to the PWM duty cycle, in per cents',ext:'On failure, throws an exception or returns <tt>Y_DUTYCYCLE_INVALID</tt>.'};
doc['PwmInput']['get_errorMessage']={syn:'Returns the error message of the latest error with the PWM input.',lib:'pwminput&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the PWM input object'};
doc['PwmInput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the PWM input.',lib:'pwminput&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the PWM input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the PWM input object'};
doc['PwmInput']['get_frequency']={syn:'Returns the PWM frequency in Hz.',lib:'pwminput&rarr;get_frequency()',pro:'double get_frequency()',cmt:'<p>Returns the PWM frequency in Hz.</p>',ret:'a floating point number corresponding to the PWM frequency in Hz',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_friendlyName']={syn:'Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'pwminput&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the PWM input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the PWM input if they are defined, otherwise the serial number of the module and the hardware identifier of the PWM input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the PWM input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PwmInput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'pwminput&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PwmInput']['get_functionId']={syn:'Returns the hardware identifier of the PWM input, without reference to the module.',lib:'pwminput&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the PWM input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the PWM input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PwmInput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'pwminput&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the PWM input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the PWM input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the PWM input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PwmInput']['get_highestValue']={syn:'Returns the maximal value observed for the PWM since the device was started.',lib:'pwminput&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'pwminput&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_logicalName']={syn:'Returns the logical name of the PWM input.',lib:'pwminput&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the PWM input.</p>',ret:'a string corresponding to the logical name of the PWM input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PwmInput']['get_lowestValue']={syn:'Returns the minimal value observed for the PWM since the device was started.',lib:'pwminput&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the PWM since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the PWM since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['PwmInput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'pwminput&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PwmInput']['get_period']={syn:'Returns the PWM period in milliseconds.',lib:'pwminput&rarr;get_period()',pro:'double get_period()',cmt:'<p>Returns the PWM period in milliseconds.</p>',ret:'a floating point number corresponding to the PWM period in milliseconds',ext:'On failure, throws an exception or returns <tt>Y_PERIOD_INVALID</tt>.'};
doc['PwmInput']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'pwminput&rarr;get_pulseCounter()',pro:'s64 get_pulseCounter()',cmt:'<p>Returns the pulse counter value. Actually that counter is incremented twice per period. That counter is limited to 1 billion.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['PwmInput']['get_pulseDuration']={syn:'Returns the PWM pulse length in milliseconds, as a floating point number.',lib:'pwminput&rarr;get_pulseDuration()',pro:'double get_pulseDuration()',cmt:'<p>Returns the PWM pulse length in milliseconds, as a floating point number.</p>',ret:'a floating point number corresponding to the PWM pulse length in milliseconds, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_PULSEDURATION_INVALID</tt>.'};
doc['PwmInput']['get_pulseTimer']={syn:'Returns the timer of the pulses counter (ms).',lib:'pwminput&rarr;get_pulseTimer()',pro:'s64 get_pulseTimer()',cmt:'<p>Returns the timer of the pulses counter (ms).</p>',ret:'an integer corresponding to the timer of the pulses counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['PwmInput']['get_pwmReportMode']={syn:'Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks.',lib:'pwminput&rarr;get_pwmReportMode()',pro:'Y_PWMREPORTMODE_enum get_pwmReportMode()',cmt:'<p>Returns the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks. Attention</p>',ret:'a value among <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_CPS</tt>, <tt>Y_PWMREPORTMODE_PWM_CPM</tt> and <tt>Y_PWMREPORTMODE_PWM_STATE</tt> corresponding to the parameter (frequency/duty cycle, pulse width, edges count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>Y_PWMREPORTMODE_INVALID</tt>.'};
doc['PwmInput']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'pwminput&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['PwmInput']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'pwminput&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['PwmInput']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'pwminput&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['PwmInput']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'pwminput&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['PwmInput']['get_unit']={syn:'Returns the measuring unit for the values returned by get_currentValue and callbacks.',lib:'pwminput&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the values returned by get_currentValue and callbacks. This unit changes according to the pwmReportMode settings.</p>',ret:'a string corresponding to the measuring unit for the values returned by get_currentValue and callbacks',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['PwmInput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'pwminput&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PwmInput']['isOnline']={syn:'Checks if the PWM input is currently reachable, without raising any error.',lib:'pwminput&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the PWM input is currently reachable, without raising any error. If there is a cached value for the PWM input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the PWM input.</p>',ret:'<tt>true</tt> if the PWM input can be reached, and <tt>false</tt> otherwise'};
doc['PwmInput']['load']={syn:'Preloads the PWM input cache with a specified validity duration.',lib:'pwminput&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the PWM input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'pwminput&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PwmInput']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'pwminput&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'pwminput&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['nextPwmInput']={syn:'Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>.',lib:'pwminput&rarr;nextPwmInput()',pro:'YPwmInput * nextPwmInput()',cmt:'<p>Continues the enumeration of PWM inputs started using <tt>yFirstPwmInput()</tt>.</p>',ret:'a pointer to a <tt>YPwmInput</tt> object, corresponding to a PWM input currently online, or a <tt>null</tt> pointer if there are no more PWM inputs to enumerate.'};
doc['PwmInput']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'pwminput&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YPwmInputTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['PwmInput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'pwminput&rarr;registerValueCallback()',pro:'int registerValueCallback(YPwmInputValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PwmInput']['resetCounter']={syn:'Returns the pulse counter value as well as its timer.',lib:'pwminput&rarr;resetCounter()',pro:'int resetCounter()',cmt:'<p>Returns the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'pwminput&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_debouncePeriod']={syn:'Changes the shortest expected pulse duration, in ms.',lib:'pwminput&rarr;set_debouncePeriod()',pro:'int set_debouncePeriod(int <span id=pn>newval</span>)',cmt:'<p>Changes the shortest expected pulse duration, in ms. Any shorter pulse will be automatically ignored (debounce).</p>',par:{newval:'an integer corresponding to the shortest expected pulse duration, in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'pwminput&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'pwminput&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_logicalName']={syn:'Changes the logical name of the PWM input.',lib:'pwminput&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the PWM input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the PWM input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'pwminput&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_pwmReportMode']={syn:'Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks.',lib:'pwminput&rarr;set_pwmReportMode()',pro:'int set_pwmReportMode(Y_PWMREPORTMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>Y_PWMREPORTMODE_PWM_DUTYCYCLE</tt>, <tt>Y_PWMREPORTMODE_PWM_FREQUENCY</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSEDURATION</tt>, <tt>Y_PWMREPORTMODE_PWM_EDGECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_PULSECOUNT</tt>, <tt>Y_PWMREPORTMODE_PWM_CPS</tt>, <tt>Y_PWMREPORTMODE_PWM_CPM</tt> and <tt>Y_PWMREPORTMODE_PWM_STATE</tt> corresponding to the parameter type (frequency/duty cycle, pulse width, or edge count) returned by the get_currentValue function and callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'pwminput&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'pwminput&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PwmInput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'pwminput&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PwmInput']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'pwminput&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['PwmInput']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'pwminput&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['PwmInput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'pwminput&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PwmInput)
//--- (generated code: SegmentedDisplay)
doc['SegmentedDisplay']={'':{syn:'SegmentedDisplay function interface',inc:'#include &quot;yocto_segmenteddisplay.h&quot;',cmt:'<p>The SegmentedDisplay class allows you to drive segmented displays.</p>'}};
doc['SegmentedDisplay']['FindSegmentedDisplay']={syn:'Retrieves a segmented display for a given identifier.',lib:'YSegmentedDisplay::FindSegmentedDisplay()',pro:'YSegmentedDisplay* FindSegmentedDisplay(string <span id=pn>func</span>)',cmt:'<p>Retrieves a segmented display for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the segmented displays is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSegmentedDisplay.isOnline()</tt> to test if the segmented displays is indeed online at a given time. In case of ambiguity when looking for a segmented display by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the segmented displays'},ret:'a <tt>YSegmentedDisplay</tt> object allowing you to drive the segmented displays.'};
doc['SegmentedDisplay']['FirstSegmentedDisplay']={syn:'Starts the enumeration of segmented displays currently accessible.',lib:'YSegmentedDisplay::FirstSegmentedDisplay()',pro:'YSegmentedDisplay* FirstSegmentedDisplay()',cmt:'<p>Starts the enumeration of segmented displays currently accessible. Use the method <tt>YSegmentedDisplay.nextSegmentedDisplay()</tt> to iterate on next segmented displays.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to the first segmented displays currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SegmentedDisplay']['clearCache']={syn:'Invalidates the cache.',lib:'segmenteddisplay&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the segmented displays attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['SegmentedDisplay']['describe']={syn:'Returns a short text that describes unambiguously the instance of the segmented displays in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'segmenteddisplay&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the segmented displays in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the segmented displays (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SegmentedDisplay']['get_advertisedValue']={syn:'Returns the current value of the segmented displays (no more than 6 characters).',lib:'segmenteddisplay&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the segmented displays (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the segmented displays (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SegmentedDisplay']['get_displayedText']={syn:'Returns the text currently displayed on the screen.',lib:'segmenteddisplay&rarr;get_displayedText()',pro:'string get_displayedText()',cmt:'<p>Returns the text currently displayed on the screen.</p>',ret:'a string corresponding to the text currently displayed on the screen',ext:'On failure, throws an exception or returns <tt>Y_DISPLAYEDTEXT_INVALID</tt>.'};
doc['SegmentedDisplay']['get_errorMessage']={syn:'Returns the error message of the latest error with the segmented displays.',lib:'segmenteddisplay&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the segmented displays. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the segmented displays object'};
doc['SegmentedDisplay']['get_errorType']={syn:'Returns the numerical error code of the latest error with the segmented displays.',lib:'segmenteddisplay&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the segmented displays. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the segmented displays object'};
doc['SegmentedDisplay']['get_friendlyName']={syn:'Returns a global identifier of the segmented displays in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'segmenteddisplay&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the segmented displays in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the segmented displays if they are defined, otherwise the serial number of the module and the hardware identifier of the segmented displays (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the segmented displays using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'segmenteddisplay&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SegmentedDisplay']['get_functionId']={syn:'Returns the hardware identifier of the segmented displays, without reference to the module.',lib:'segmenteddisplay&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the segmented displays, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the segmented displays (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_hardwareId']={syn:'Returns the unique hardware identifier of the segmented displays in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'segmenteddisplay&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the segmented displays in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the segmented displays (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the segmented displays (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SegmentedDisplay']['get_logicalName']={syn:'Returns the logical name of the segmented displays.',lib:'segmenteddisplay&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the segmented displays.</p>',ret:'a string corresponding to the logical name of the segmented displays.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SegmentedDisplay']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'segmenteddisplay&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SegmentedDisplay']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'segmenteddisplay&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SegmentedDisplay']['isOnline']={syn:'Checks if the segmented displays is currently reachable, without raising any error.',lib:'segmenteddisplay&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the segmented displays is currently reachable, without raising any error. If there is a cached value for the segmented displays in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the segmented displays.</p>',ret:'<tt>true</tt> if the segmented displays can be reached, and <tt>false</tt> otherwise'};
doc['SegmentedDisplay']['load']={syn:'Preloads the segmented displays cache with a specified validity duration.',lib:'segmenteddisplay&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the segmented displays cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'segmenteddisplay&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['SegmentedDisplay']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'segmenteddisplay&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['nextSegmentedDisplay']={syn:'Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>.',lib:'segmenteddisplay&rarr;nextSegmentedDisplay()',pro:'YSegmentedDisplay * nextSegmentedDisplay()',cmt:'<p>Continues the enumeration of segmented displays started using <tt>yFirstSegmentedDisplay()</tt>.</p>',ret:'a pointer to a <tt>YSegmentedDisplay</tt> object, corresponding to a segmented display currently online, or a <tt>null</tt> pointer if there are no more segmented displays to enumerate.'};
doc['SegmentedDisplay']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'segmenteddisplay&rarr;registerValueCallback()',pro:'int registerValueCallback(YSegmentedDisplayValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SegmentedDisplay']['set_displayedText']={syn:'Changes the text currently displayed on the screen.',lib:'segmenteddisplay&rarr;set_displayedText()',pro:'int set_displayedText(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the text currently displayed on the screen.</p>',par:{newval:'a string corresponding to the text currently displayed on the screen'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['set_logicalName']={syn:'Changes the logical name of the segmented displays.',lib:'segmenteddisplay&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the segmented displays. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the segmented displays.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SegmentedDisplay']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'segmenteddisplay&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SegmentedDisplay']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'segmenteddisplay&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SegmentedDisplay)
//--- (generated code: Buzzer)
doc['Buzzer']={'':{syn:'Buzzer function interface',inc:'#include &quot;yocto_buzzer.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to choose the frequency and volume at which the buzzer must sound. You can also pre-program a play sequence.</p>'}};
doc['Buzzer']['FindBuzzer']={syn:'Retrieves a buzzer for a given identifier.',lib:'YBuzzer::FindBuzzer()',pro:'YBuzzer* FindBuzzer(string <span id=pn>func</span>)',cmt:'<p>Retrieves a buzzer for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the buzzer is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YBuzzer.isOnline()</tt> to test if the buzzer is indeed online at a given time. In case of ambiguity when looking for a buzzer by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the buzzer'},ret:'a <tt>YBuzzer</tt> object allowing you to drive the buzzer.'};
doc['Buzzer']['FirstBuzzer']={syn:'Starts the enumeration of buzzers currently accessible.',lib:'YBuzzer::FirstBuzzer()',pro:'YBuzzer* FirstBuzzer()',cmt:'<p>Starts the enumeration of buzzers currently accessible. Use the method <tt>YBuzzer.nextBuzzer()</tt> to iterate on next buzzers.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to the first buzzer currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Buzzer']['addFreqMoveToPlaySeq']={syn:'Adds a new frequency transition to the playing sequence.',lib:'buzzer&rarr;addFreqMoveToPlaySeq()',pro:'int addFreqMoveToPlaySeq(int <span id=pn>freq</span>, int <span id=pn>msDelay</span>)',cmt:'<p>Adds a new frequency transition to the playing sequence.</p>',par:{freq:'desired frequency when the transition is completed, in Hz',msDelay:'duration of the frequency transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addNotesToPlaySeq']={syn:'Adds notes to the playing sequence.',lib:'buzzer&rarr;addNotesToPlaySeq()',pro:'int addNotesToPlaySeq(string <span id=pn>notes</span>)',cmt:'<p>Adds notes to the playing sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addPulseToPlaySeq']={syn:'Adds a pulse to the playing sequence.',lib:'buzzer&rarr;addPulseToPlaySeq()',pro:'int addPulseToPlaySeq(int <span id=pn>freq</span>, int <span id=pn>msDuration</span>)',cmt:'<p>Adds a pulse to the playing sequence.</p>',par:{freq:'pulse frequency, in Hz',msDuration:'pulse duration, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['addVolMoveToPlaySeq']={syn:'Adds a new volume transition to the playing sequence.',lib:'buzzer&rarr;addVolMoveToPlaySeq()',pro:'int addVolMoveToPlaySeq(int <span id=pn>volume</span>, int <span id=pn>msDuration</span>)',cmt:'<p>Adds a new volume transition to the playing sequence. Frequency stays untouched: if frequency is at zero, the transition has no effect.</p>',par:{volume:'desired volume when the transition is completed, as a percentage.',msDuration:'duration of the volume transition, in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['clearCache']={syn:'Invalidates the cache.',lib:'buzzer&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the buzzer attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Buzzer']['describe']={syn:'Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'buzzer&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the buzzer in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the buzzer (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Buzzer']['freqMove']={syn:'Makes the buzzer frequency change over a period of time.',lib:'buzzer&rarr;freqMove()',pro:'int freqMove(int <span id=pn>frequency</span>, int <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer frequency change over a period of time.</p>',par:{frequency:'frequency to reach, in hertz. A frequency under 25Hz stops the buzzer.',duration:'pulse duration in millseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['get_advertisedValue']={syn:'Returns the current value of the buzzer (no more than 6 characters).',lib:'buzzer&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the buzzer (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the buzzer (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Buzzer']['get_errorMessage']={syn:'Returns the error message of the latest error with the buzzer.',lib:'buzzer&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the buzzer object'};
doc['Buzzer']['get_errorType']={syn:'Returns the numerical error code of the latest error with the buzzer.',lib:'buzzer&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the buzzer. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the buzzer object'};
doc['Buzzer']['get_frequency']={syn:'Returns the frequency of the signal sent to the buzzer/speaker.',lib:'buzzer&rarr;get_frequency()',pro:'double get_frequency()',cmt:'<p>Returns the frequency of the signal sent to the buzzer/speaker.</p>',ret:'a floating point number corresponding to the frequency of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>Y_FREQUENCY_INVALID</tt>.'};
doc['Buzzer']['get_friendlyName']={syn:'Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'buzzer&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the buzzer in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the buzzer if they are defined, otherwise the serial number of the module and the hardware identifier of the buzzer (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the buzzer using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Buzzer']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'buzzer&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Buzzer']['get_functionId']={syn:'Returns the hardware identifier of the buzzer, without reference to the module.',lib:'buzzer&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the buzzer, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the buzzer (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Buzzer']['get_hardwareId']={syn:'Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'buzzer&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the buzzer in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the buzzer (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the buzzer (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Buzzer']['get_logicalName']={syn:'Returns the logical name of the buzzer.',lib:'buzzer&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the buzzer.</p>',ret:'a string corresponding to the logical name of the buzzer.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Buzzer']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'buzzer&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Buzzer']['get_playSeqMaxSize']={syn:'Returns the maximum length of the playing sequence.',lib:'buzzer&rarr;get_playSeqMaxSize()',pro:'int get_playSeqMaxSize()',cmt:'<p>Returns the maximum length of the playing sequence.</p>',ret:'an integer corresponding to the maximum length of the playing sequence',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQMAXSIZE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSignature']={syn:'Returns the playing sequence signature.',lib:'buzzer&rarr;get_playSeqSignature()',pro:'int get_playSeqSignature()',cmt:'<p>Returns the playing sequence signature. As playing sequences cannot be read from the device, this can be used to detect if a specific playing sequence is already programmed.</p>',ret:'an integer corresponding to the playing sequence signature',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQSIGNATURE_INVALID</tt>.'};
doc['Buzzer']['get_playSeqSize']={syn:'Returns the current length of the playing sequence.',lib:'buzzer&rarr;get_playSeqSize()',pro:'int get_playSeqSize()',cmt:'<p>Returns the current length of the playing sequence.</p>',ret:'an integer corresponding to the current length of the playing sequence',ext:'On failure, throws an exception or returns <tt>Y_PLAYSEQSIZE_INVALID</tt>.'};
doc['Buzzer']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'buzzer&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Buzzer']['get_volume']={syn:'Returns the volume of the signal sent to the buzzer/speaker.',lib:'buzzer&rarr;get_volume()',pro:'int get_volume()',cmt:'<p>Returns the volume of the signal sent to the buzzer/speaker.</p>',ret:'an integer corresponding to the volume of the signal sent to the buzzer/speaker',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['Buzzer']['isOnline']={syn:'Checks if the buzzer is currently reachable, without raising any error.',lib:'buzzer&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the buzzer is currently reachable, without raising any error. If there is a cached value for the buzzer in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the buzzer.</p>',ret:'<tt>true</tt> if the buzzer can be reached, and <tt>false</tt> otherwise'};
doc['Buzzer']['load']={syn:'Preloads the buzzer cache with a specified validity duration.',lib:'buzzer&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the buzzer cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'buzzer&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Buzzer']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'buzzer&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['nextBuzzer']={syn:'Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>.',lib:'buzzer&rarr;nextBuzzer()',pro:'YBuzzer * nextBuzzer()',cmt:'<p>Continues the enumeration of buzzers started using <tt>yFirstBuzzer()</tt>.</p>',ret:'a pointer to a <tt>YBuzzer</tt> object, corresponding to a buzzer currently online, or a <tt>null</tt> pointer if there are no more buzzers to enumerate.'};
doc['Buzzer']['oncePlaySeq']={syn:'Starts the preprogrammed playing sequence and run it once only.',lib:'buzzer&rarr;oncePlaySeq()',pro:'int oncePlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence and run it once only.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['playNotes']={syn:'Immediately play a note sequence.',lib:'buzzer&rarr;playNotes()',pro:'int playNotes(string <span id=pn>notes</span>)',cmt:'<p>Immediately play a note sequence. Notes are provided as text words, separated by spaces. The pitch is specified using the usual letter from A to G. The duration is specified as the divisor of a whole note: 4 for a fourth, 8 for an eight note, etc. Some modifiers are supported: <tt>#</tt> and <tt>b</tt> to alter a note pitch, <tt>\x27</tt> and <tt>,</tt> to move to the upper/lower octave, <tt>.</tt> to enlarge the note duration.</p>',par:{notes:'notes to be played, as a text string.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['pulse']={syn:'Activates the buzzer for a short duration.',lib:'buzzer&rarr;pulse()',pro:'int pulse(int <span id=pn>frequency</span>, int <span id=pn>duration</span>)',cmt:'<p>Activates the buzzer for a short duration.</p>',par:{frequency:'pulse frequency, in hertz',duration:'pulse duration in millseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'buzzer&rarr;registerValueCallback()',pro:'int registerValueCallback(YBuzzerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Buzzer']['resetPlaySeq']={syn:'Resets the preprogrammed playing sequence and sets the frequency to zero.',lib:'buzzer&rarr;resetPlaySeq()',pro:'int resetPlaySeq()',cmt:'<p>Resets the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_frequency']={syn:'Changes the frequency of the signal sent to the buzzer.',lib:'buzzer&rarr;set_frequency()',pro:'int set_frequency(double <span id=pn>newval</span>)',cmt:'<p>Changes the frequency of the signal sent to the buzzer. A zero value stops the buzzer.</p>',par:{newval:'a floating point number corresponding to the frequency of the signal sent to the buzzer'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_logicalName']={syn:'Changes the logical name of the buzzer.',lib:'buzzer&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the buzzer. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the buzzer.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'buzzer&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Buzzer']['set_volume']={syn:'Changes the volume of the signal sent to the buzzer/speaker.',lib:'buzzer&rarr;set_volume()',pro:'int set_volume(int <span id=pn>newval</span>)',cmt:'<p>Changes the volume of the signal sent to the buzzer/speaker.</p>',par:{newval:'an integer corresponding to the volume of the signal sent to the buzzer/speaker'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['startPlaySeq']={syn:'Starts the preprogrammed playing sequence.',lib:'buzzer&rarr;startPlaySeq()',pro:'int startPlaySeq()',cmt:'<p>Starts the preprogrammed playing sequence. The sequence runs in loop until it is stopped by stopPlaySeq or an explicit change. To play the sequence only once, use <tt>oncePlaySeq()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['stopPlaySeq']={syn:'Stops the preprogrammed playing sequence and sets the frequency to zero.',lib:'buzzer&rarr;stopPlaySeq()',pro:'int stopPlaySeq()',cmt:'<p>Stops the preprogrammed playing sequence and sets the frequency to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'buzzer&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Buzzer']['volumeMove']={syn:'Makes the buzzer volume change over a period of time, frequency stays untouched.',lib:'buzzer&rarr;volumeMove()',pro:'int volumeMove(int <span id=pn>volume</span>, int <span id=pn>duration</span>)',cmt:'<p>Makes the buzzer volume change over a period of time, frequency stays untouched.</p>',par:{volume:'volume to reach in %',duration:'change duration in millseconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Buzzer)
//--- (generated code: FirmwareUpdate)
doc['FirmwareUpdate']={'':{syn:'Control interface for the firmware update process',inc:'#include &quot;yocto_api.h&quot;',cmt:'<p>The YFirmwareUpdate class let you control the firmware update of a Yoctopuce module. This class should not be instantiate directly, instead the method <tt>updateFirmware</tt> should be called to get an instance of YFirmwareUpdate.</p>'}};
doc['FirmwareUpdate']['CheckFirmware']={syn:'Test if the byn file is valid for this module.',lib:'YFirmwareUpdate::CheckFirmware()',pro:'string CheckFirmware(string <span id=pn>serial</span>, string <span id=pn>path</span>, int <span id=pn>minrelease</span>)',cmt:'<p>Test if the byn file is valid for this module. It is possible to pass a directory instead of a file. In that case, this method returns the path of the most recent appropriate byn file. This method will ignore any firmware older than minrelease.</p>',par:{serial:'the serial number of the module to update',path:'the path of a byn file or a directory that contains byn files',minrelease:'a positive integer'},ret:': the path of the byn file to use, or an empty string if no byn files matches the requirement',ext:'On failure, returns a string that starts with \x22error:\x22.'};
doc['FirmwareUpdate']['GetAllBootLoaders']={syn:'Returns a list of all the modules in \x22firmware update\x22 mode.',lib:'YFirmwareUpdate::GetAllBootLoaders()',pro:'vector&lt;string&gt; GetAllBootLoaders()',cmt:'<p>Returns a list of all the modules in \x22firmware update\x22 mode. Only devices connected over USB are listed. For devices connected to a YoctoHub, you must connect yourself to the YoctoHub web interface.</p>',ret:'an array of strings containing the serial numbers of devices in \x22firmware update\x22 mode.'};
doc['FirmwareUpdate']['get_progress']={syn:'Returns the progress of the firmware update, on a scale from 0 to 100.',lib:'firmwareupdate&rarr;get_progress()',pro:'int get_progress()',cmt:'<p>Returns the progress of the firmware update, on a scale from 0 to 100. When the object is instantiated, the progress is zero. The value is updated during the firmware update process until the value of 100 is reached. The 100 value means that the firmware update was completed successfully. If an error occurs during the firmware update, a negative value is returned, and the error message can be retrieved with <tt>get_progressMessage</tt>.</p>',ret:'an integer in the range 0 to 100 (percentage of completion) or a negative error code in case of failure.'};
doc['FirmwareUpdate']['get_progressMessage']={syn:'Returns the last progress message of the firmware update process.',lib:'firmwareupdate&rarr;get_progressMessage()',pro:'string get_progressMessage()',cmt:'<p>Returns the last progress message of the firmware update process. If an error occurs during the firmware update process, the error message is returned</p>',ret:'a string with the latest progress message, or the error message.'};
doc['FirmwareUpdate']['startUpdate']={syn:'Starts the firmware update process.',lib:'firmwareupdate&rarr;startUpdate()',pro:'int startUpdate()',cmt:'<p>Starts the firmware update process. This method starts the firmware update process in background. This method returns immediately. You can monitor the progress of the firmware update with the <tt>get_progress()</tt> and <tt>get_progressMessage()</tt> methods.</p>',ret:'an integer in the range 0 to 100 (percentage of completion), or a negative error code in case of failure.',ext:'On failure returns a negative error code.'};
//--- (end of generated code: FirmwareUpdate)
//--- (generated code: Gps)
doc['Gps']={'':{syn:'GPS function interface',inc:'#include &quot;yocto_gps.h&quot;',cmt:'<p>The Gps function allows you to extract positionning data from the GPS device. This class can provides complete positionning information: However, if you whish to define callbacks on position changes, you should use the YLatitude et YLongitude classes.</p>'}};
doc['Gps']['FindGps']={syn:'Retrieves a GPS for a given identifier.',lib:'YGps::FindGps()',pro:'YGps* FindGps(string <span id=pn>func</span>)',cmt:'<p>Retrieves a GPS for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the GPS is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGps.isOnline()</tt> to test if the GPS is indeed online at a given time. In case of ambiguity when looking for a GPS by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the GPS'},ret:'a <tt>YGps</tt> object allowing you to drive the GPS.'};
doc['Gps']['FirstGps']={syn:'Starts the enumeration of GPS currently accessible.',lib:'YGps::FirstGps()',pro:'YGps* FirstGps()',cmt:'<p>Starts the enumeration of GPS currently accessible. Use the method <tt>YGps.nextGps()</tt> to iterate on next GPS.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to the first GPS currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Gps']['clearCache']={syn:'Invalidates the cache.',lib:'gps&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the GPS attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Gps']['describe']={syn:'Returns a short text that describes unambiguously the instance of the GPS in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'gps&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the GPS in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the GPS (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Gps']['get_advertisedValue']={syn:'Returns the current value of the GPS (no more than 6 characters).',lib:'gps&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the GPS (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the GPS (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Gps']['get_altitude']={syn:'Returns the current altitude.',lib:'gps&rarr;get_altitude()',pro:'double get_altitude()',cmt:'<p>Returns the current altitude. Beware: GPS technology is very inaccurate regarding altitude.</p>',ret:'a floating point number corresponding to the current altitude',ext:'On failure, throws an exception or returns <tt>Y_ALTITUDE_INVALID</tt>.'};
doc['Gps']['get_coordSystem']={syn:'Returns the representation system used for positioning data.',lib:'gps&rarr;get_coordSystem()',pro:'Y_COORDSYSTEM_enum get_coordSystem()',cmt:'<p>Returns the representation system used for positioning data.</p>',ret:'a value among <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> and <tt>Y_COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data',ext:'On failure, throws an exception or returns <tt>Y_COORDSYSTEM_INVALID</tt>.'};
doc['Gps']['get_dateTime']={syn:'Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.',lib:'gps&rarr;get_dateTime()',pro:'string get_dateTime()',cmt:'<p>Returns the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22.</p>',ret:'a string corresponding to the current time in the form \x22YYYY/MM/DD hh:mm:ss\x22',ext:'On failure, throws an exception or returns <tt>Y_DATETIME_INVALID</tt>.'};
doc['Gps']['get_dilution']={syn:'Returns the current horizontal dilution of precision, the smaller that number is, the better .',lib:'gps&rarr;get_dilution()',pro:'double get_dilution()',cmt:'<p>Returns the current horizontal dilution of precision, the smaller that number is, the better .</p>',ret:'a floating point number corresponding to the current horizontal dilution of precision, the smaller that number is, the better',ext:'On failure, throws an exception or returns <tt>Y_DILUTION_INVALID</tt>.'};
doc['Gps']['get_direction']={syn:'Returns the current move bearing in degrees, zero is the true (geographic) north.',lib:'gps&rarr;get_direction()',pro:'double get_direction()',cmt:'<p>Returns the current move bearing in degrees, zero is the true (geographic) north.</p>',ret:'a floating point number corresponding to the current move bearing in degrees, zero is the true (geographic) north',ext:'On failure, throws an exception or returns <tt>Y_DIRECTION_INVALID</tt>.'};
doc['Gps']['get_errorMessage']={syn:'Returns the error message of the latest error with the GPS.',lib:'gps&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the GPS. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the GPS object'};
doc['Gps']['get_errorType']={syn:'Returns the numerical error code of the latest error with the GPS.',lib:'gps&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the GPS. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the GPS object'};
doc['Gps']['get_friendlyName']={syn:'Returns a global identifier of the GPS in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'gps&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the GPS in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the GPS if they are defined, otherwise the serial number of the module and the hardware identifier of the GPS (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the GPS using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Gps']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'gps&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Gps']['get_functionId']={syn:'Returns the hardware identifier of the GPS, without reference to the module.',lib:'gps&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the GPS, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the GPS (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Gps']['get_groundSpeed']={syn:'Returns the current ground speed in Km/h.',lib:'gps&rarr;get_groundSpeed()',pro:'double get_groundSpeed()',cmt:'<p>Returns the current ground speed in Km/h.</p>',ret:'a floating point number corresponding to the current ground speed in Km/h',ext:'On failure, throws an exception or returns <tt>Y_GROUNDSPEED_INVALID</tt>.'};
doc['Gps']['get_hardwareId']={syn:'Returns the unique hardware identifier of the GPS in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'gps&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the GPS in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the GPS (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the GPS (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Gps']['get_isFixed']={syn:'Returns TRUE if the receiver has found enough satellites to work.',lib:'gps&rarr;get_isFixed()',pro:'Y_ISFIXED_enum get_isFixed()',cmt:'<p>Returns TRUE if the receiver has found enough satellites to work.</p>',ret:'either <tt>Y_ISFIXED_FALSE</tt> or <tt>Y_ISFIXED_TRUE</tt>, according to TRUE if the receiver has found enough satellites to work',ext:'On failure, throws an exception or returns <tt>Y_ISFIXED_INVALID</tt>.'};
doc['Gps']['get_latitude']={syn:'Returns the current latitude.',lib:'gps&rarr;get_latitude()',pro:'string get_latitude()',cmt:'<p>Returns the current latitude.</p>',ret:'a string corresponding to the current latitude',ext:'On failure, throws an exception or returns <tt>Y_LATITUDE_INVALID</tt>.'};
doc['Gps']['get_logicalName']={syn:'Returns the logical name of the GPS.',lib:'gps&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the GPS.</p>',ret:'a string corresponding to the logical name of the GPS.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Gps']['get_longitude']={syn:'Returns the current longitude.',lib:'gps&rarr;get_longitude()',pro:'string get_longitude()',cmt:'<p>Returns the current longitude.</p>',ret:'a string corresponding to the current longitude',ext:'On failure, throws an exception or returns <tt>Y_LONGITUDE_INVALID</tt>.'};
doc['Gps']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'gps&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Gps']['get_satCount']={syn:'Returns the count of visible satellites.',lib:'gps&rarr;get_satCount()',pro:'s64 get_satCount()',cmt:'<p>Returns the count of visible satellites.</p>',ret:'an integer corresponding to the count of visible satellites',ext:'On failure, throws an exception or returns <tt>Y_SATCOUNT_INVALID</tt>.'};
doc['Gps']['get_unixTime']={syn:'Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).',lib:'gps&rarr;get_unixTime()',pro:'s64 get_unixTime()',cmt:'<p>Returns the current time in Unix format (number of seconds elapsed since Jan 1st, 1970).</p>',ret:'an integer corresponding to the current time in Unix format (number of seconds elapsed since Jan 1st, 1970)',ext:'On failure, throws an exception or returns <tt>Y_UNIXTIME_INVALID</tt>.'};
doc['Gps']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'gps&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Gps']['get_utcOffset']={syn:'Returns the number of seconds between current time and UTC time (time zone).',lib:'gps&rarr;get_utcOffset()',pro:'int get_utcOffset()',cmt:'<p>Returns the number of seconds between current time and UTC time (time zone).</p>',ret:'an integer corresponding to the number of seconds between current time and UTC time (time zone)',ext:'On failure, throws an exception or returns <tt>Y_UTCOFFSET_INVALID</tt>.'};
doc['Gps']['isOnline']={syn:'Checks if the GPS is currently reachable, without raising any error.',lib:'gps&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the GPS is currently reachable, without raising any error. If there is a cached value for the GPS in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the GPS.</p>',ret:'<tt>true</tt> if the GPS can be reached, and <tt>false</tt> otherwise'};
doc['Gps']['load']={syn:'Preloads the GPS cache with a specified validity duration.',lib:'gps&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the GPS cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'gps&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Gps']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'gps&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['nextGps']={syn:'Continues the enumeration of GPS started using <tt>yFirstGps()</tt>.',lib:'gps&rarr;nextGps()',pro:'YGps * nextGps()',cmt:'<p>Continues the enumeration of GPS started using <tt>yFirstGps()</tt>.</p>',ret:'a pointer to a <tt>YGps</tt> object, corresponding to a GPS currently online, or a <tt>null</tt> pointer if there are no more GPS to enumerate.'};
doc['Gps']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'gps&rarr;registerValueCallback()',pro:'int registerValueCallback(YGpsValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Gps']['set_coordSystem']={syn:'Changes the representation system used for positioning data.',lib:'gps&rarr;set_coordSystem()',pro:'int set_coordSystem(Y_COORDSYSTEM_enum <span id=pn>newval</span>)',cmt:'<p>Changes the representation system used for positioning data.</p>',par:{newval:'a value among <tt>Y_COORDSYSTEM_GPS_DMS</tt>, <tt>Y_COORDSYSTEM_GPS_DM</tt> and <tt>Y_COORDSYSTEM_GPS_D</tt> corresponding to the representation system used for positioning data'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['set_logicalName']={syn:'Changes the logical name of the GPS.',lib:'gps&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the GPS. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the GPS.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'gps&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Gps']['set_utcOffset']={syn:'Changes the number of seconds between current time and UTC time (time zone).',lib:'gps&rarr;set_utcOffset()',pro:'int set_utcOffset(int <span id=pn>newval</span>)',cmt:'<p>Changes the number of seconds between current time and UTC time (time zone). The timezone is automatically rounded to the nearest multiple of 15 minutes. If current UTC time is known, the current time is automatically be updated according to the selected time zone.</p>',par:{newval:'an integer corresponding to the number of seconds between current time and UTC time (time zone)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Gps']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'gps&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Gps)
//--- (generated code: Latitude)
doc['Latitude']={'':{syn:'Latitude function interface',inc:'#include &quot;yocto_latitude.h&quot;',cmt:'<p>The Yoctopuce class YLatitude allows you to read the latitude from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['Latitude']['FindLatitude']={syn:'Retrieves a latitude sensor for a given identifier.',lib:'YLatitude::FindLatitude()',pro:'YLatitude* FindLatitude(string <span id=pn>func</span>)',cmt:'<p>Retrieves a latitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the latitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLatitude.isOnline()</tt> to test if the latitude sensor is indeed online at a given time. In case of ambiguity when looking for a latitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the latitude sensor'},ret:'a <tt>YLatitude</tt> object allowing you to drive the latitude sensor.'};
doc['Latitude']['FirstLatitude']={syn:'Starts the enumeration of latitude sensors currently accessible.',lib:'YLatitude::FirstLatitude()',pro:'YLatitude* FirstLatitude()',cmt:'<p>Starts the enumeration of latitude sensors currently accessible. Use the method <tt>YLatitude.nextLatitude()</tt> to iterate on next latitude sensors.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to the first latitude sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Latitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'latitude&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['clearCache']={syn:'Invalidates the cache.',lib:'latitude&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the latitude sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Latitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'latitude&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the latitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the latitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Latitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'latitude&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Latitude']['get_advertisedValue']={syn:'Returns the current value of the latitude sensor (no more than 6 characters).',lib:'latitude&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the latitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the latitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'latitude&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Latitude']['get_currentValue']={syn:'Returns the current value of the latitude, in deg/1000, as a floating point number.',lib:'latitude&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the latitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the latitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Latitude']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'latitude&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Latitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the latitude sensor.',lib:'latitude&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the latitude sensor object'};
doc['Latitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the latitude sensor.',lib:'latitude&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the latitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the latitude sensor object'};
doc['Latitude']['get_friendlyName']={syn:'Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'latitude&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the latitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the latitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the latitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the latitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Latitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'latitude&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Latitude']['get_functionId']={syn:'Returns the hardware identifier of the latitude sensor, without reference to the module.',lib:'latitude&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the latitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the latitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Latitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'latitude&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the latitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the latitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the latitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Latitude']['get_highestValue']={syn:'Returns the maximal value observed for the latitude since the device was started.',lib:'latitude&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'latitude&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_logicalName']={syn:'Returns the logical name of the latitude sensor.',lib:'latitude&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the latitude sensor.</p>',ret:'a string corresponding to the logical name of the latitude sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Latitude']['get_lowestValue']={syn:'Returns the minimal value observed for the latitude since the device was started.',lib:'latitude&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the latitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the latitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Latitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'latitude&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Latitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'latitude&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Latitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'latitude&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Latitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'latitude&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Latitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'latitude&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Latitude']['get_unit']={syn:'Returns the measuring unit for the latitude.',lib:'latitude&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the latitude.</p>',ret:'a string corresponding to the measuring unit for the latitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Latitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'latitude&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Latitude']['isOnline']={syn:'Checks if the latitude sensor is currently reachable, without raising any error.',lib:'latitude&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the latitude sensor is currently reachable, without raising any error. If there is a cached value for the latitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the latitude sensor.</p>',ret:'<tt>true</tt> if the latitude sensor can be reached, and <tt>false</tt> otherwise'};
doc['Latitude']['load']={syn:'Preloads the latitude sensor cache with a specified validity duration.',lib:'latitude&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the latitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'latitude&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Latitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'latitude&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'latitude&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['nextLatitude']={syn:'Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>.',lib:'latitude&rarr;nextLatitude()',pro:'YLatitude * nextLatitude()',cmt:'<p>Continues the enumeration of latitude sensors started using <tt>yFirstLatitude()</tt>.</p>',ret:'a pointer to a <tt>YLatitude</tt> object, corresponding to a latitude sensor currently online, or a <tt>null</tt> pointer if there are no more latitude sensors to enumerate.'};
doc['Latitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'latitude&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YLatitudeTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Latitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'latitude&rarr;registerValueCallback()',pro:'int registerValueCallback(YLatitudeValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Latitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'latitude&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'latitude&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'latitude&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_logicalName']={syn:'Changes the logical name of the latitude sensor.',lib:'latitude&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the latitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the latitude sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'latitude&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'latitude&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'latitude&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Latitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'latitude&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Latitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'latitude&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Latitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'latitude&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Latitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'latitude&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Latitude)
//--- (generated code: Longitude)
doc['Longitude']={'':{syn:'Longitude function interface',inc:'#include &quot;yocto_longitude.h&quot;',cmt:'<p>The Yoctopuce class YLongitude allows you to read the longitude from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['Longitude']['FindLongitude']={syn:'Retrieves a longitude sensor for a given identifier.',lib:'YLongitude::FindLongitude()',pro:'YLongitude* FindLongitude(string <span id=pn>func</span>)',cmt:'<p>Retrieves a longitude sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the longitude sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YLongitude.isOnline()</tt> to test if the longitude sensor is indeed online at a given time. In case of ambiguity when looking for a longitude sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the longitude sensor'},ret:'a <tt>YLongitude</tt> object allowing you to drive the longitude sensor.'};
doc['Longitude']['FirstLongitude']={syn:'Starts the enumeration of longitude sensors currently accessible.',lib:'YLongitude::FirstLongitude()',pro:'YLongitude* FirstLongitude()',cmt:'<p>Starts the enumeration of longitude sensors currently accessible. Use the method <tt>YLongitude.nextLongitude()</tt> to iterate on next longitude sensors.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to the first longitude sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Longitude']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'longitude&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['clearCache']={syn:'Invalidates the cache.',lib:'longitude&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the longitude sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Longitude']['describe']={syn:'Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'longitude&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the longitude sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the longitude sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Longitude']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'longitude&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Longitude']['get_advertisedValue']={syn:'Returns the current value of the longitude sensor (no more than 6 characters).',lib:'longitude&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the longitude sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the longitude sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.',lib:'longitude&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Longitude']['get_currentValue']={syn:'Returns the current value of the longitude, in deg/1000, as a floating point number.',lib:'longitude&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the longitude, in deg/1000, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the longitude, in deg/1000, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Longitude']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'longitude&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Longitude']['get_errorMessage']={syn:'Returns the error message of the latest error with the longitude sensor.',lib:'longitude&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the longitude sensor object'};
doc['Longitude']['get_errorType']={syn:'Returns the numerical error code of the latest error with the longitude sensor.',lib:'longitude&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the longitude sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the longitude sensor object'};
doc['Longitude']['get_friendlyName']={syn:'Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'longitude&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the longitude sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the longitude sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the longitude sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the longitude sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Longitude']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'longitude&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Longitude']['get_functionId']={syn:'Returns the hardware identifier of the longitude sensor, without reference to the module.',lib:'longitude&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the longitude sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the longitude sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Longitude']['get_hardwareId']={syn:'Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'longitude&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the longitude sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the longitude sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the longitude sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Longitude']['get_highestValue']={syn:'Returns the maximal value observed for the longitude since the device was started.',lib:'longitude&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'longitude&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_logicalName']={syn:'Returns the logical name of the longitude sensor.',lib:'longitude&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the longitude sensor.</p>',ret:'a string corresponding to the logical name of the longitude sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Longitude']['get_lowestValue']={syn:'Returns the minimal value observed for the longitude since the device was started.',lib:'longitude&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the longitude since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the longitude since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Longitude']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'longitude&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Longitude']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'longitude&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Longitude']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'longitude&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Longitude']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'longitude&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Longitude']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'longitude&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Longitude']['get_unit']={syn:'Returns the measuring unit for the longitude.',lib:'longitude&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the longitude.</p>',ret:'a string corresponding to the measuring unit for the longitude',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Longitude']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'longitude&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Longitude']['isOnline']={syn:'Checks if the longitude sensor is currently reachable, without raising any error.',lib:'longitude&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the longitude sensor is currently reachable, without raising any error. If there is a cached value for the longitude sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the longitude sensor.</p>',ret:'<tt>true</tt> if the longitude sensor can be reached, and <tt>false</tt> otherwise'};
doc['Longitude']['load']={syn:'Preloads the longitude sensor cache with a specified validity duration.',lib:'longitude&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the longitude sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'longitude&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Longitude']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'longitude&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'longitude&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['nextLongitude']={syn:'Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>.',lib:'longitude&rarr;nextLongitude()',pro:'YLongitude * nextLongitude()',cmt:'<p>Continues the enumeration of longitude sensors started using <tt>yFirstLongitude()</tt>.</p>',ret:'a pointer to a <tt>YLongitude</tt> object, corresponding to a longitude sensor currently online, or a <tt>null</tt> pointer if there are no more longitude sensors to enumerate.'};
doc['Longitude']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'longitude&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YLongitudeTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Longitude']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'longitude&rarr;registerValueCallback()',pro:'int registerValueCallback(YLongitudeValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Longitude']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'longitude&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'longitude&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'longitude&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_logicalName']={syn:'Changes the logical name of the longitude sensor.',lib:'longitude&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the longitude sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the longitude sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'longitude&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'longitude&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'longitude&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Longitude']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'longitude&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Longitude']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'longitude&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Longitude']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'longitude&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Longitude']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'longitude&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Longitude)
//--- (generated code: GroundSpeed)
doc['GroundSpeed']={'':{syn:'GroundSpeed function interface',inc:'#include &quot;yocto_groundspeed.h&quot;',cmt:'<p>The Yoctopuce class YGroundSpeed allows you to read the ground speed from Yoctopuce geolocalization sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger.</p>'}};
doc['GroundSpeed']['FindGroundSpeed']={syn:'Retrieves a ground speed sensor for a given identifier.',lib:'YGroundSpeed::FindGroundSpeed()',pro:'YGroundSpeed* FindGroundSpeed(string <span id=pn>func</span>)',cmt:'<p>Retrieves a ground speed sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the ground speed sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YGroundSpeed.isOnline()</tt> to test if the ground speed sensor is indeed online at a given time. In case of ambiguity when looking for a ground speed sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the ground speed sensor'},ret:'a <tt>YGroundSpeed</tt> object allowing you to drive the ground speed sensor.'};
doc['GroundSpeed']['FirstGroundSpeed']={syn:'Starts the enumeration of ground speed sensors currently accessible.',lib:'YGroundSpeed::FirstGroundSpeed()',pro:'YGroundSpeed* FirstGroundSpeed()',cmt:'<p>Starts the enumeration of ground speed sensors currently accessible. Use the method <tt>YGroundSpeed.nextGroundSpeed()</tt> to iterate on next ground speed sensors.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to the first ground speed sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['GroundSpeed']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'groundspeed&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['clearCache']={syn:'Invalidates the cache.',lib:'groundspeed&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the ground speed sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['GroundSpeed']['describe']={syn:'Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'groundspeed&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the ground speed sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the ground speed sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['GroundSpeed']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'groundspeed&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['GroundSpeed']['get_advertisedValue']={syn:'Returns the current value of the ground speed sensor (no more than 6 characters).',lib:'groundspeed&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the ground speed sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the ground speed sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.',lib:'groundspeed&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_currentValue']={syn:'Returns the current value of the ground speed, in km/h, as a floating point number.',lib:'groundspeed&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the ground speed, in km/h, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the ground speed, in km/h, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'groundspeed&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['GroundSpeed']['get_errorMessage']={syn:'Returns the error message of the latest error with the ground speed sensor.',lib:'groundspeed&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the ground speed sensor object'};
doc['GroundSpeed']['get_errorType']={syn:'Returns the numerical error code of the latest error with the ground speed sensor.',lib:'groundspeed&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the ground speed sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the ground speed sensor object'};
doc['GroundSpeed']['get_friendlyName']={syn:'Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'groundspeed&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the ground speed sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the ground speed sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the ground speed sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the ground speed sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'groundspeed&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['GroundSpeed']['get_functionId']={syn:'Returns the hardware identifier of the ground speed sensor, without reference to the module.',lib:'groundspeed&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the ground speed sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the ground speed sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['GroundSpeed']['get_hardwareId']={syn:'Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'groundspeed&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the ground speed sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the ground speed sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the ground speed sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['GroundSpeed']['get_highestValue']={syn:'Returns the maximal value observed for the ground speed since the device was started.',lib:'groundspeed&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'groundspeed&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_logicalName']={syn:'Returns the logical name of the ground speed sensor.',lib:'groundspeed&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the ground speed sensor.</p>',ret:'a string corresponding to the logical name of the ground speed sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['GroundSpeed']['get_lowestValue']={syn:'Returns the minimal value observed for the ground speed since the device was started.',lib:'groundspeed&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the ground speed since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the ground speed since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['GroundSpeed']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'groundspeed&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['GroundSpeed']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'groundspeed&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['GroundSpeed']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'groundspeed&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['GroundSpeed']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'groundspeed&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['GroundSpeed']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'groundspeed&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['GroundSpeed']['get_unit']={syn:'Returns the measuring unit for the ground speed.',lib:'groundspeed&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the ground speed.</p>',ret:'a string corresponding to the measuring unit for the ground speed',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['GroundSpeed']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'groundspeed&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['GroundSpeed']['isOnline']={syn:'Checks if the ground speed sensor is currently reachable, without raising any error.',lib:'groundspeed&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the ground speed sensor is currently reachable, without raising any error. If there is a cached value for the ground speed sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the ground speed sensor.</p>',ret:'<tt>true</tt> if the ground speed sensor can be reached, and <tt>false</tt> otherwise'};
doc['GroundSpeed']['load']={syn:'Preloads the ground speed sensor cache with a specified validity duration.',lib:'groundspeed&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the ground speed sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'groundspeed&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['GroundSpeed']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'groundspeed&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'groundspeed&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['nextGroundSpeed']={syn:'Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>.',lib:'groundspeed&rarr;nextGroundSpeed()',pro:'YGroundSpeed * nextGroundSpeed()',cmt:'<p>Continues the enumeration of ground speed sensors started using <tt>yFirstGroundSpeed()</tt>.</p>',ret:'a pointer to a <tt>YGroundSpeed</tt> object, corresponding to a ground speed sensor currently online, or a <tt>null</tt> pointer if there are no more ground speed sensors to enumerate.'};
doc['GroundSpeed']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'groundspeed&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YGroundSpeedTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['GroundSpeed']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'groundspeed&rarr;registerValueCallback()',pro:'int registerValueCallback(YGroundSpeedValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['GroundSpeed']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'groundspeed&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'groundspeed&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'groundspeed&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_logicalName']={syn:'Changes the logical name of the ground speed sensor.',lib:'groundspeed&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the ground speed sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the ground speed sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'groundspeed&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'groundspeed&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'groundspeed&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['GroundSpeed']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'groundspeed&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['GroundSpeed']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'groundspeed&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GroundSpeed']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'groundspeed&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['GroundSpeed']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'groundspeed&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: GroundSpeed)
//--- (generated code: PowerOutput)
doc['PowerOutput']={'':{syn:'External power supply control interface',inc:'#include &quot;yocto_poweroutput.h&quot;',cmt:'<p>Yoctopuce application programming interface allows you to control the power ouput featured on some devices such as the Yocto-Serial.</p>'}};
doc['PowerOutput']['FindPowerOutput']={syn:'Retrieves a dual power ouput control for a given identifier.',lib:'YPowerOutput::FindPowerOutput()',pro:'YPowerOutput* FindPowerOutput(string <span id=pn>func</span>)',cmt:'<p>Retrieves a dual power ouput control for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the power ouput control is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerOutput.isOnline()</tt> to test if the power ouput control is indeed online at a given time. In case of ambiguity when looking for a dual power ouput control by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the power ouput control'},ret:'a <tt>YPowerOutput</tt> object allowing you to drive the power ouput control.'};
doc['PowerOutput']['FirstPowerOutput']={syn:'Starts the enumeration of dual power ouput controls currently accessible.',lib:'YPowerOutput::FirstPowerOutput()',pro:'YPowerOutput* FirstPowerOutput()',cmt:'<p>Starts the enumeration of dual power ouput controls currently accessible. Use the method <tt>YPowerOutput.nextPowerOutput()</tt> to iterate on next dual power ouput controls.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to the first dual power ouput control currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PowerOutput']['clearCache']={syn:'Invalidates the cache.',lib:'poweroutput&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the power ouput control attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PowerOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the power ouput control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'poweroutput&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the power ouput control in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the power ouput control (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerOutput']['get_advertisedValue']={syn:'Returns the current value of the power ouput control (no more than 6 characters).',lib:'poweroutput&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the power ouput control (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the power ouput control (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the power ouput control.',lib:'poweroutput&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the power ouput control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the power ouput control object'};
doc['PowerOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the power ouput control.',lib:'poweroutput&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the power ouput control. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the power ouput control object'};
doc['PowerOutput']['get_friendlyName']={syn:'Returns a global identifier of the power ouput control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'poweroutput&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the power ouput control in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the power ouput control if they are defined, otherwise the serial number of the module and the hardware identifier of the power ouput control (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the power ouput control using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'poweroutput&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PowerOutput']['get_functionId']={syn:'Returns the hardware identifier of the power ouput control, without reference to the module.',lib:'poweroutput&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the power ouput control, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the power ouput control (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the power ouput control in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'poweroutput&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the power ouput control in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the power ouput control (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the power ouput control (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerOutput']['get_logicalName']={syn:'Returns the logical name of the power ouput control.',lib:'poweroutput&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the power ouput control.</p>',ret:'a string corresponding to the logical name of the power ouput control.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'poweroutput&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PowerOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'poweroutput&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PowerOutput']['get_voltage']={syn:'Returns the voltage on the power output featured by the module.',lib:'poweroutput&rarr;get_voltage()',pro:'Y_VOLTAGE_enum get_voltage()',cmt:'<p>Returns the voltage on the power output featured by the module.</p>',ret:'a value among <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> and <tt>Y_VOLTAGE_OUT5V</tt> corresponding to the voltage on the power output featured by the module',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['PowerOutput']['isOnline']={syn:'Checks if the power ouput control is currently reachable, without raising any error.',lib:'poweroutput&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the power ouput control is currently reachable, without raising any error. If there is a cached value for the power ouput control in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the power ouput control.</p>',ret:'<tt>true</tt> if the power ouput control can be reached, and <tt>false</tt> otherwise'};
doc['PowerOutput']['load']={syn:'Preloads the power ouput control cache with a specified validity duration.',lib:'poweroutput&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the power ouput control cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'poweroutput&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PowerOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'poweroutput&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['nextPowerOutput']={syn:'Continues the enumeration of dual power ouput controls started using <tt>yFirstPowerOutput()</tt>.',lib:'poweroutput&rarr;nextPowerOutput()',pro:'YPowerOutput * nextPowerOutput()',cmt:'<p>Continues the enumeration of dual power ouput controls started using <tt>yFirstPowerOutput()</tt>.</p>',ret:'a pointer to a <tt>YPowerOutput</tt> object, corresponding to a dual power ouput control currently online, or a <tt>null</tt> pointer if there are no more dual power ouput controls to enumerate.'};
doc['PowerOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'poweroutput&rarr;registerValueCallback()',pro:'int registerValueCallback(YPowerOutputValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PowerOutput']['set_logicalName']={syn:'Changes the logical name of the power ouput control.',lib:'poweroutput&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the power ouput control. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the power ouput control.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'poweroutput&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PowerOutput']['set_voltage']={syn:'Changes the voltage on the power output provided by the module.',lib:'poweroutput&rarr;set_voltage()',pro:'int set_voltage(Y_VOLTAGE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the voltage on the power output provided by the module. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a value among <tt>Y_VOLTAGE_OFF</tt>, <tt>Y_VOLTAGE_OUT3V3</tt> and <tt>Y_VOLTAGE_OUT5V</tt> corresponding to the voltage on the power output provided by the module'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'poweroutput&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PowerOutput)
//--- (generated code: Cellular)
doc['Cellular']={'':{syn:'Cellular function interface',inc:'#include &quot;yocto_cellular.h&quot;',cmt:'<p>YCellular functions provides control over cellular network parameters and status for devices that are GSM-enabled.</p>'}};
doc['Cellular']['FindCellular']={syn:'Retrieves a cellular interface for a given identifier.',lib:'YCellular::FindCellular()',pro:'YCellular* FindCellular(string <span id=pn>func</span>)',cmt:'<p>Retrieves a cellular interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the cellular interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCellular.isOnline()</tt> to test if the cellular interface is indeed online at a given time. In case of ambiguity when looking for a cellular interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the cellular interface'},ret:'a <tt>YCellular</tt> object allowing you to drive the cellular interface.'};
doc['Cellular']['FirstCellular']={syn:'Starts the enumeration of cellular interfaces currently accessible.',lib:'YCellular::FirstCellular()',pro:'YCellular* FirstCellular()',cmt:'<p>Starts the enumeration of cellular interfaces currently accessible. Use the method <tt>YCellular.nextCellular()</tt> to iterate on next cellular interfaces.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to the first cellular interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Cellular']['_AT']={syn:'Sends an AT command to the GSM module and returns the command output.',lib:'cellular&rarr;_AT()',pro:'string _AT(string <span id=pn>cmd</span>)',cmt:'<p>Sends an AT command to the GSM module and returns the command output. The command will only execute when the GSM module is in standard command state, and should leave it in the exact same state. Use this function with great care !</p>',par:{cmd:'the AT command to execute, like for instance: \x22+CCLK?\x22.'},ret:'a string with the result of the commands. Empty lines are automatically removed from the output.'};
doc['Cellular']['clearCache']={syn:'Invalidates the cache.',lib:'cellular&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the cellular interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Cellular']['clearDataCounters']={syn:'Clear the transmitted data counters.',lib:'cellular&rarr;clearDataCounters()',pro:'int clearDataCounters()',cmt:'<p>Clear the transmitted data counters.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['describe']={syn:'Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'cellular&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the cellular interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Cellular']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'cellular&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Cellular']['get_airplaneMode']={syn:'Returns true if the airplane mode is active (radio turned off).',lib:'cellular&rarr;get_airplaneMode()',pro:'Y_AIRPLANEMODE_enum get_airplaneMode()',cmt:'<p>Returns true if the airplane mode is active (radio turned off).</p>',ret:'either <tt>Y_AIRPLANEMODE_OFF</tt> or <tt>Y_AIRPLANEMODE_ON</tt>, according to true if the airplane mode is active (radio turned off)',ext:'On failure, throws an exception or returns <tt>Y_AIRPLANEMODE_INVALID</tt>.'};
doc['Cellular']['get_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'cellular&rarr;get_apn()',pro:'string get_apn()',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',ret:'a string corresponding to the Access Point Name (APN) to be used, if needed',ext:'On failure, throws an exception or returns <tt>Y_APN_INVALID</tt>.'};
doc['Cellular']['get_apnSecret']={syn:'Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise.',lib:'cellular&rarr;get_apnSecret()',pro:'string get_apnSecret()',cmt:'<p>Returns an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise. To configure these parameters, use <tt>set_apnAuth()</tt>.</p>',ret:'a string corresponding to an opaque string if APN authentication parameters have been configured in the device, or an empty string otherwise',ext:'On failure, throws an exception or returns <tt>Y_APNSECRET_INVALID</tt>.'};
doc['Cellular']['get_availableOperators']={syn:'Returns the list detected cell operators in the neighborhood.',lib:'cellular&rarr;get_availableOperators()',pro:'vector&lt;string&gt; get_availableOperators()',cmt:'<p>Returns the list detected cell operators in the neighborhood. This function will typically take between 30 seconds to 1 minute to return. Note that any SIM card can usually only connect to specific operators. All networks returned by this function might therefore not be available for connection.</p>',ret:'a list of string (cell operator names).'};
doc['Cellular']['get_cellIdentifier']={syn:'Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.',lib:'cellular&rarr;get_cellIdentifier()',pro:'string get_cellIdentifier()',cmt:'<p>Returns the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID.</p>',ret:'a string corresponding to the unique identifier of the cellular antenna in use: MCC, MNC, LAC and Cell ID',ext:'On failure, throws an exception or returns <tt>Y_CELLIDENTIFIER_INVALID</tt>.'};
doc['Cellular']['get_cellOperator']={syn:'Returns the name of the cell operator currently in use.',lib:'cellular&rarr;get_cellOperator()',pro:'string get_cellOperator()',cmt:'<p>Returns the name of the cell operator currently in use.</p>',ret:'a string corresponding to the name of the cell operator currently in use',ext:'On failure, throws an exception or returns <tt>Y_CELLOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_cellType']={syn:'Active cellular connection type.',lib:'cellular&rarr;get_cellType()',pro:'Y_CELLTYPE_enum get_cellType()',cmt:'<p>Active cellular connection type.</p>',ret:'a value among <tt>Y_CELLTYPE_GPRS</tt>, <tt>Y_CELLTYPE_EGPRS</tt>, <tt>Y_CELLTYPE_WCDMA</tt>, <tt>Y_CELLTYPE_HSDPA</tt>, <tt>Y_CELLTYPE_NONE</tt> and <tt>Y_CELLTYPE_CDMA</tt>',ext:'On failure, throws an exception or returns <tt>Y_CELLTYPE_INVALID</tt>.'};
doc['Cellular']['get_dataReceived']={syn:'Returns the number of bytes received so far.',lib:'cellular&rarr;get_dataReceived()',pro:'int get_dataReceived()',cmt:'<p>Returns the number of bytes received so far.</p>',ret:'an integer corresponding to the number of bytes received so far',ext:'On failure, throws an exception or returns <tt>Y_DATARECEIVED_INVALID</tt>.'};
doc['Cellular']['get_dataSent']={syn:'Returns the number of bytes sent so far.',lib:'cellular&rarr;get_dataSent()',pro:'int get_dataSent()',cmt:'<p>Returns the number of bytes sent so far.</p>',ret:'an integer corresponding to the number of bytes sent so far',ext:'On failure, throws an exception or returns <tt>Y_DATASENT_INVALID</tt>.'};
doc['Cellular']['get_enableData']={syn:'Returns the condition for enabling IP data services (GPRS).',lib:'cellular&rarr;get_enableData()',pro:'Y_ENABLEDATA_enum get_enableData()',cmt:'<p>Returns the condition for enabling IP data services (GPRS). When data services are disabled, SMS are the only mean of communication.</p>',ret:'a value among <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt>, <tt>Y_ENABLEDATA_NEVER</tt> and <tt>Y_ENABLEDATA_NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)',ext:'On failure, throws an exception or returns <tt>Y_ENABLEDATA_INVALID</tt>.'};
doc['Cellular']['get_errorMessage']={syn:'Returns the error message of the latest error with the cellular interface.',lib:'cellular&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the cellular interface object'};
doc['Cellular']['get_errorType']={syn:'Returns the numerical error code of the latest error with the cellular interface.',lib:'cellular&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the cellular interface object'};
doc['Cellular']['get_friendlyName']={syn:'Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'cellular&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the cellular interface if they are defined, otherwise the serial number of the module and the hardware identifier of the cellular interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the cellular interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Cellular']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'cellular&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Cellular']['get_functionId']={syn:'Returns the hardware identifier of the cellular interface, without reference to the module.',lib:'cellular&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the cellular interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the cellular interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Cellular']['get_hardwareId']={syn:'Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'cellular&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the cellular interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the cellular interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Cellular']['get_imsi']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'cellular&rarr;get_imsi()',pro:'string get_imsi()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_IMSI_INVALID</tt>.'};
doc['Cellular']['get_linkQuality']={syn:'Returns the link quality, expressed in percent.',lib:'cellular&rarr;get_linkQuality()',pro:'int get_linkQuality()',cmt:'<p>Returns the link quality, expressed in percent.</p>',ret:'an integer corresponding to the link quality, expressed in percent',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Cellular']['get_lockedOperator']={syn:'Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.',lib:'cellular&rarr;get_lockedOperator()',pro:'string get_lockedOperator()',cmt:'<p>Returns the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators.</p>',ret:'a string corresponding to the name of the only cell operator to use if automatic choice is disabled, or an empty string if the SIM card will automatically choose among available cell operators',ext:'On failure, throws an exception or returns <tt>Y_LOCKEDOPERATOR_INVALID</tt>.'};
doc['Cellular']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'cellular&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Cellular']['get_message']={syn:'Returns the latest status message from the wireless interface.',lib:'cellular&rarr;get_message()',pro:'string get_message()',cmt:'<p>Returns the latest status message from the wireless interface.</p>',ret:'a string corresponding to the latest status message from the wireless interface',ext:'On failure, throws an exception or returns <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Cellular']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'cellular&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Cellular']['get_pin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'cellular&rarr;get_pin()',pro:'string get_pin()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_PIN_INVALID</tt>.'};
doc['Cellular']['get_pingInterval']={syn:'Returns the automated connectivity check interval, in seconds.',lib:'cellular&rarr;get_pingInterval()',pro:'int get_pingInterval()',cmt:'<p>Returns the automated connectivity check interval, in seconds.</p>',ret:'an integer corresponding to the automated connectivity check interval, in seconds',ext:'On failure, throws an exception or returns <tt>Y_PINGINTERVAL_INVALID</tt>.'};
doc['Cellular']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'cellular&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Cellular']['isOnline']={syn:'Checks if the cellular interface is currently reachable, without raising any error.',lib:'cellular&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the cellular interface is currently reachable, without raising any error. If there is a cached value for the cellular interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the cellular interface.</p>',ret:'<tt>true</tt> if the cellular interface can be reached, and <tt>false</tt> otherwise'};
doc['Cellular']['load']={syn:'Preloads the cellular interface cache with a specified validity duration.',lib:'cellular&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the cellular interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'cellular&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Cellular']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'cellular&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['nextCellular']={syn:'Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>.',lib:'cellular&rarr;nextCellular()',pro:'YCellular * nextCellular()',cmt:'<p>Continues the enumeration of cellular interfaces started using <tt>yFirstCellular()</tt>.</p>',ret:'a pointer to a <tt>YCellular</tt> object, corresponding to a cellular interface currently online, or a <tt>null</tt> pointer if there are no more cellular interfaces to enumerate.'};
doc['Cellular']['quickCellSurvey']={syn:'Returns a list of nearby cellular antennas, as required for quick geolocation of the device.',lib:'cellular&rarr;quickCellSurvey()',pro:'vector&lt;YCellRecord&gt; quickCellSurvey()',cmt:'<p>Returns a list of nearby cellular antennas, as required for quick geolocation of the device. The first cell listed is the serving cell, and the next ones are the neighboor cells reported by the serving cell.</p>',ret:'a list of YCellRecords.'};
doc['Cellular']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'cellular&rarr;registerValueCallback()',pro:'int registerValueCallback(YCellularValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Cellular']['sendPUK']={syn:'Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card.',lib:'cellular&rarr;sendPUK()',pro:'int sendPUK(string <span id=pn>puk</span>, string <span id=pn>newPin</span>)',cmt:'<p>Sends a PUK code to unlock the SIM card after three failed PIN code attempts, and setup a new PIN into the SIM card. Only ten consecutives tentatives are permitted: after that, the SIM card will be blocked permanently without any mean of recovery to use it again. Note that after calling this method, you have usually to invoke method <tt>set_pin()</tt> to tell the YoctoHub which PIN to use in the future.</p>',par:{puk:'the SIM PUK code',newPin:'new PIN code to configure into the SIM card'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_airplaneMode']={syn:'Changes the activation state of airplane mode (radio turned off).',lib:'cellular&rarr;set_airplaneMode()',pro:'int set_airplaneMode(Y_AIRPLANEMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation state of airplane mode (radio turned off).</p>',par:{newval:'either <tt>Y_AIRPLANEMODE_OFF</tt> or <tt>Y_AIRPLANEMODE_ON</tt>, according to the activation state of airplane mode (radio turned off)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_apn']={syn:'Returns the Access Point Name (APN) to be used, if needed.',lib:'cellular&rarr;set_apn()',pro:'int set_apn(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Returns the Access Point Name (APN) to be used, if needed. When left blank, the APN suggested by the cell operator will be used.</p>',par:{newval:'a string'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_apnAuth']={syn:'Configure authentication parameters to connect to the APN.',lib:'cellular&rarr;set_apnAuth()',pro:'int set_apnAuth(string <span id=pn>username</span>, string <span id=pn>password</span>)',cmt:'<p>Configure authentication parameters to connect to the APN. Both PAP and CHAP authentication are supported.</p>',par:{username:'APN username',password:'APN password'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_dataReceived']={syn:'Changes the value of the incoming data counter.',lib:'cellular&rarr;set_dataReceived()',pro:'int set_dataReceived(int <span id=pn>newval</span>)',cmt:'<p>Changes the value of the incoming data counter.</p>',par:{newval:'an integer corresponding to the value of the incoming data counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_dataSent']={syn:'Changes the value of the outgoing data counter.',lib:'cellular&rarr;set_dataSent()',pro:'int set_dataSent(int <span id=pn>newval</span>)',cmt:'<p>Changes the value of the outgoing data counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing data counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_enableData']={syn:'Changes the condition for enabling IP data services (GPRS).',lib:'cellular&rarr;set_enableData()',pro:'int set_enableData(Y_ENABLEDATA_enum <span id=pn>newval</span>)',cmt:'<p>Changes the condition for enabling IP data services (GPRS). The service can be either fully deactivated, or limited to the SIM home network, or enabled for all partner networks (roaming). Caution: enabling data services on roaming networks may cause prohibitive communication costs !</p><p> When data services are disabled, SMS are the only mean of communication.</p>',par:{newval:'a value among <tt>Y_ENABLEDATA_HOMENETWORK</tt>, <tt>Y_ENABLEDATA_ROAMING</tt>, <tt>Y_ENABLEDATA_NEVER</tt> and <tt>Y_ENABLEDATA_NEUTRALITY</tt> corresponding to the condition for enabling IP data services (GPRS)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_lockedOperator']={syn:'Changes the name of the cell operator to be used.',lib:'cellular&rarr;set_lockedOperator()',pro:'int set_lockedOperator(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the name of the cell operator to be used. If the name is an empty string, the choice will be made automatically based on the SIM card. Otherwise, the selected operator is the only one that will be used.</p>',par:{newval:'a string corresponding to the name of the cell operator to be used'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'cellular&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the cellular interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_pin']={syn:'Changes the PIN code used by the module to access the SIM card.',lib:'cellular&rarr;set_pin()',pro:'int set_pin(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the PIN code used by the module to access the SIM card. This function does not change the code on the SIM card itself, but only changes the parameter used by the device to try to get access to it. If the SIM code does not work immediately on first try, it will be automatically forgotten and the message will be set to \x22Enter SIM PIN\x22. The method should then be invoked again with right correct PIN code. After three failed attempts in a row, the message is changed to \x22Enter SIM PUK\x22 and the SIM card PUK code must be provided using method <tt>sendPUK</tt>.</p><p> Remember to call the <tt>saveToFlash()</tt> method of the module to save the new value in the device flash.</p>',par:{newval:'a string corresponding to the PIN code used by the module to access the SIM card'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_pingInterval']={syn:'Changes the automated connectivity check interval, in seconds.',lib:'cellular&rarr;set_pingInterval()',pro:'int set_pingInterval(int <span id=pn>newval</span>)',cmt:'<p>Changes the automated connectivity check interval, in seconds.</p>',par:{newval:'an integer corresponding to the automated connectivity check interval, in seconds'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Cellular']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'cellular&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Cellular']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'cellular&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Cellular)
//--- (generated code: AudioOut)
doc['AudioOut']={'':{syn:'AudioOut function interface',inc:'#include &quot;yocto_audioout.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the outout.</p>'}};
doc['AudioOut']['FindAudioOut']={syn:'Retrieves an audio output for a given identifier.',lib:'YAudioOut::FindAudioOut()',pro:'YAudioOut* FindAudioOut(string <span id=pn>func</span>)',cmt:'<p>Retrieves an audio output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the audio output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAudioOut.isOnline()</tt> to test if the audio output is indeed online at a given time. In case of ambiguity when looking for an audio output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the audio output'},ret:'a <tt>YAudioOut</tt> object allowing you to drive the audio output.'};
doc['AudioOut']['FirstAudioOut']={syn:'Starts the enumeration of audio outputs currently accessible.',lib:'YAudioOut::FirstAudioOut()',pro:'YAudioOut* FirstAudioOut()',cmt:'<p>Starts the enumeration of audio outputs currently accessible. Use the method <tt>YAudioOut.nextAudioOut()</tt> to iterate on next audio outputs.</p>',ret:'a pointer to a <tt>YAudioOut</tt> object, corresponding to the first audio output currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AudioOut']['clearCache']={syn:'Invalidates the cache.',lib:'audioout&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the audio output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['AudioOut']['describe']={syn:'Returns a short text that describes unambiguously the instance of the audio output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'audioout&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the audio output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the audio output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AudioOut']['get_advertisedValue']={syn:'Returns the current value of the audio output (no more than 6 characters).',lib:'audioout&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the audio output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AudioOut']['get_errorMessage']={syn:'Returns the error message of the latest error with the audio output.',lib:'audioout&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the audio output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the audio output object'};
doc['AudioOut']['get_errorType']={syn:'Returns the numerical error code of the latest error with the audio output.',lib:'audioout&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the audio output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the audio output object'};
doc['AudioOut']['get_friendlyName']={syn:'Returns a global identifier of the audio output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'audioout&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the audio output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the audio output if they are defined, otherwise the serial number of the module and the hardware identifier of the audio output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the audio output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AudioOut']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'audioout&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AudioOut']['get_functionId']={syn:'Returns the hardware identifier of the audio output, without reference to the module.',lib:'audioout&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the audio output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the audio output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AudioOut']['get_hardwareId']={syn:'Returns the unique hardware identifier of the audio output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'audioout&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the audio output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the audio output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the audio output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AudioOut']['get_logicalName']={syn:'Returns the logical name of the audio output.',lib:'audioout&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the audio output.</p>',ret:'a string corresponding to the logical name of the audio output.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AudioOut']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'audioout&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AudioOut']['get_mute']={syn:'Returns the state of the mute function.',lib:'audioout&rarr;get_mute()',pro:'Y_MUTE_enum get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>Y_MUTE_INVALID</tt>.'};
doc['AudioOut']['get_noSignalFor']={syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'audioout&rarr;get_noSignalFor()',pro:'int get_noSignalFor()',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:'On failure, throws an exception or returns <tt>Y_NOSIGNALFOR_INVALID</tt>.'};
doc['AudioOut']['get_signal']={syn:'Returns the detected output current level.',lib:'audioout&rarr;get_signal()',pro:'int get_signal()',cmt:'<p>Returns the detected output current level.</p>',ret:'an integer corresponding to the detected output current level',ext:'On failure, throws an exception or returns <tt>Y_SIGNAL_INVALID</tt>.'};
doc['AudioOut']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'audioout&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AudioOut']['get_volume']={syn:'Returns audio output volume, in per cents.',lib:'audioout&rarr;get_volume()',pro:'int get_volume()',cmt:'<p>Returns audio output volume, in per cents.</p>',ret:'an integer corresponding to audio output volume, in per cents',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['AudioOut']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'audioout&rarr;get_volumeRange()',pro:'string get_volumeRange()',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:'On failure, throws an exception or returns <tt>Y_VOLUMERANGE_INVALID</tt>.'};
doc['AudioOut']['isOnline']={syn:'Checks if the audio output is currently reachable, without raising any error.',lib:'audioout&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the audio output is currently reachable, without raising any error. If there is a cached value for the audio output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the audio output.</p>',ret:'<tt>true</tt> if the audio output can be reached, and <tt>false</tt> otherwise'};
doc['AudioOut']['load']={syn:'Preloads the audio output cache with a specified validity duration.',lib:'audioout&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the audio output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'audioout&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['AudioOut']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'audioout&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['nextAudioOut']={syn:'Continues the enumeration of audio outputs started using <tt>yFirstAudioOut()</tt>.',lib:'audioout&rarr;nextAudioOut()',pro:'YAudioOut * nextAudioOut()',cmt:'<p>Continues the enumeration of audio outputs started using <tt>yFirstAudioOut()</tt>.</p>',ret:'a pointer to a <tt>YAudioOut</tt> object, corresponding to an audio output currently online, or a <tt>null</tt> pointer if there are no more audio outputs to enumerate.'};
doc['AudioOut']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'audioout&rarr;registerValueCallback()',pro:'int registerValueCallback(YAudioOutValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AudioOut']['set_logicalName']={syn:'Changes the logical name of the audio output.',lib:'audioout&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the audio output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the audio output.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['set_mute']={syn:'Changes the state of the mute function.',lib:'audioout&rarr;set_mute()',pro:'int set_mute(Y_MUTE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'audioout&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['AudioOut']['set_volume']={syn:'Changes audio output volume, in per cents.',lib:'audioout&rarr;set_volume()',pro:'int set_volume(int <span id=pn>newval</span>)',cmt:'<p>Changes audio output volume, in per cents.</p>',par:{newval:'an integer corresponding to audio output volume, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioOut']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'audioout&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: AudioOut)
//--- (generated code: BluetoothLink)
doc['BluetoothLink']={'':{syn:'BluetoothLink function interface',inc:'#include &quot;yocto_bluetoothlink.h&quot;',cmt:'<p>BluetoothLink function provides control over bluetooth link and status for devices that are bluetooth-enabled.</p>'}};
doc['BluetoothLink']['FindBluetoothLink']={syn:'Retrieves a cellular interface for a given identifier.',lib:'YBluetoothLink::FindBluetoothLink()',pro:'YBluetoothLink* FindBluetoothLink(string <span id=pn>func</span>)',cmt:'<p>Retrieves a cellular interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the cellular interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YBluetoothLink.isOnline()</tt> to test if the cellular interface is indeed online at a given time. In case of ambiguity when looking for a cellular interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the cellular interface'},ret:'a <tt>YBluetoothLink</tt> object allowing you to drive the cellular interface.'};
doc['BluetoothLink']['FirstBluetoothLink']={syn:'Starts the enumeration of cellular interfaces currently accessible.',lib:'YBluetoothLink::FirstBluetoothLink()',pro:'YBluetoothLink* FirstBluetoothLink()',cmt:'<p>Starts the enumeration of cellular interfaces currently accessible. Use the method <tt>YBluetoothLink.nextBluetoothLink()</tt> to iterate on next cellular interfaces.</p>',ret:'a pointer to a <tt>YBluetoothLink</tt> object, corresponding to the first cellular interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['BluetoothLink']['clearCache']={syn:'Invalidates the cache.',lib:'bluetoothlink&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the cellular interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['BluetoothLink']['connect']={syn:'Attempt to connect to the previously selected remote device.',lib:'bluetoothlink&rarr;connect()',pro:'int connect()',cmt:'<p>Attempt to connect to the previously selected remote device.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['describe']={syn:'Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'bluetoothlink&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the cellular interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the cellular interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['BluetoothLink']['disconnect']={syn:'Disconnect from the previously selected remote device.',lib:'bluetoothlink&rarr;disconnect()',pro:'int disconnect()',cmt:'<p>Disconnect from the previously selected remote device.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['get_advertisedValue']={syn:'Returns the current value of the cellular interface (no more than 6 characters).',lib:'bluetoothlink&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the cellular interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the cellular interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['BluetoothLink']['get_errorMessage']={syn:'Returns the error message of the latest error with the cellular interface.',lib:'bluetoothlink&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the cellular interface object'};
doc['BluetoothLink']['get_errorType']={syn:'Returns the numerical error code of the latest error with the cellular interface.',lib:'bluetoothlink&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the cellular interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the cellular interface object'};
doc['BluetoothLink']['get_friendlyName']={syn:'Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'bluetoothlink&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the cellular interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the cellular interface if they are defined, otherwise the serial number of the module and the hardware identifier of the cellular interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the cellular interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['BluetoothLink']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'bluetoothlink&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['BluetoothLink']['get_functionId']={syn:'Returns the hardware identifier of the cellular interface, without reference to the module.',lib:'bluetoothlink&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the cellular interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the cellular interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['BluetoothLink']['get_hardwareId']={syn:'Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'bluetoothlink&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the cellular interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the cellular interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the cellular interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['BluetoothLink']['get_linkQuality']={syn:'Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.',lib:'bluetoothlink&rarr;get_linkQuality()',pro:'int get_linkQuality()',cmt:'<p>Returns the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established.</p>',ret:'an integer corresponding to the bluetooth receiver signal strength, in pourcents, or 0 if no connection is established',ext:'On failure, throws an exception or returns <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['BluetoothLink']['get_linkState']={syn:'Returns the bluetooth link state.',lib:'bluetoothlink&rarr;get_linkState()',pro:'Y_LINKSTATE_enum get_linkState()',cmt:'<p>Returns the bluetooth link state.</p>',ret:'a value among <tt>Y_LINKSTATE_DOWN</tt>, <tt>Y_LINKSTATE_FREE</tt>, <tt>Y_LINKSTATE_SEARCH</tt>, <tt>Y_LINKSTATE_EXISTS</tt>, <tt>Y_LINKSTATE_LINKED</tt> and <tt>Y_LINKSTATE_PLAY</tt> corresponding to the bluetooth link state',ext:'On failure, throws an exception or returns <tt>Y_LINKSTATE_INVALID</tt>.'};
doc['BluetoothLink']['get_logicalName']={syn:'Returns the logical name of the cellular interface.',lib:'bluetoothlink&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the cellular interface.</p>',ret:'a string corresponding to the logical name of the cellular interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['BluetoothLink']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'bluetoothlink&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['BluetoothLink']['get_mute']={syn:'Returns the state of the mute function.',lib:'bluetoothlink&rarr;get_mute()',pro:'Y_MUTE_enum get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>Y_MUTE_INVALID</tt>.'};
doc['BluetoothLink']['get_ownAddress']={syn:'Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.',lib:'bluetoothlink&rarr;get_ownAddress()',pro:'string get_ownAddress()',cmt:'<p>Returns the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network.</p>',ret:'a string corresponding to the MAC-48 address of the bluetooth interface, which is unique on the bluetooth network',ext:'On failure, throws an exception or returns <tt>Y_OWNADDRESS_INVALID</tt>.'};
doc['BluetoothLink']['get_pairingPin']={syn:'Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.',lib:'bluetoothlink&rarr;get_pairingPin()',pro:'string get_pairingPin()',cmt:'<p>Returns an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card.</p>',ret:'a string corresponding to an opaque string if a PIN code has been configured in the device to access the SIM card, or an empty string if none has been configured or if the code provided was rejected by the SIM card',ext:'On failure, throws an exception or returns <tt>Y_PAIRINGPIN_INVALID</tt>.'};
doc['BluetoothLink']['get_preAmplifier']={syn:'Returns the audio pre-amplifier volume, in per cents.',lib:'bluetoothlink&rarr;get_preAmplifier()',pro:'int get_preAmplifier()',cmt:'<p>Returns the audio pre-amplifier volume, in per cents.</p>',ret:'an integer corresponding to the audio pre-amplifier volume, in per cents',ext:'On failure, throws an exception or returns <tt>Y_PREAMPLIFIER_INVALID</tt>.'};
doc['BluetoothLink']['get_remoteAddress']={syn:'Returns the MAC-48 address of the remote device to connect to.',lib:'bluetoothlink&rarr;get_remoteAddress()',pro:'string get_remoteAddress()',cmt:'<p>Returns the MAC-48 address of the remote device to connect to.</p>',ret:'a string corresponding to the MAC-48 address of the remote device to connect to',ext:'On failure, throws an exception or returns <tt>Y_REMOTEADDRESS_INVALID</tt>.'};
doc['BluetoothLink']['get_remoteName']={syn:'Returns the bluetooth name the remote device, if found on the bluetooth network.',lib:'bluetoothlink&rarr;get_remoteName()',pro:'string get_remoteName()',cmt:'<p>Returns the bluetooth name the remote device, if found on the bluetooth network.</p>',ret:'a string corresponding to the bluetooth name the remote device, if found on the bluetooth network',ext:'On failure, throws an exception or returns <tt>Y_REMOTENAME_INVALID</tt>.'};
doc['BluetoothLink']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'bluetoothlink&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['BluetoothLink']['get_volume']={syn:'Returns the connected headset volume, in per cents.',lib:'bluetoothlink&rarr;get_volume()',pro:'int get_volume()',cmt:'<p>Returns the connected headset volume, in per cents.</p>',ret:'an integer corresponding to the connected headset volume, in per cents',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['BluetoothLink']['isOnline']={syn:'Checks if the cellular interface is currently reachable, without raising any error.',lib:'bluetoothlink&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the cellular interface is currently reachable, without raising any error. If there is a cached value for the cellular interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the cellular interface.</p>',ret:'<tt>true</tt> if the cellular interface can be reached, and <tt>false</tt> otherwise'};
doc['BluetoothLink']['load']={syn:'Preloads the cellular interface cache with a specified validity duration.',lib:'bluetoothlink&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the cellular interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'bluetoothlink&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['BluetoothLink']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'bluetoothlink&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['nextBluetoothLink']={syn:'Continues the enumeration of cellular interfaces started using <tt>yFirstBluetoothLink()</tt>.',lib:'bluetoothlink&rarr;nextBluetoothLink()',pro:'YBluetoothLink * nextBluetoothLink()',cmt:'<p>Continues the enumeration of cellular interfaces started using <tt>yFirstBluetoothLink()</tt>.</p>',ret:'a pointer to a <tt>YBluetoothLink</tt> object, corresponding to a cellular interface currently online, or a <tt>null</tt> pointer if there are no more cellular interfaces to enumerate.'};
doc['BluetoothLink']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'bluetoothlink&rarr;registerValueCallback()',pro:'int registerValueCallback(YBluetoothLinkValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['BluetoothLink']['set_logicalName']={syn:'Changes the logical name of the cellular interface.',lib:'bluetoothlink&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the cellular interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the cellular interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_mute']={syn:'Changes the state of the mute function.',lib:'bluetoothlink&rarr;set_mute()',pro:'int set_mute(Y_MUTE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_pairingPin']={syn:'Changes the PIN code used by the module for bluetooth pairing.',lib:'bluetoothlink&rarr;set_pairingPin()',pro:'int set_pairingPin(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the PIN code used by the module for bluetooth pairing. Remember to call the <tt>saveToFlash()</tt> method of the module to save the new value in the device flash.</p>',par:{newval:'a string corresponding to the PIN code used by the module for bluetooth pairing'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_preAmplifier']={syn:'Changes the audio pre-amplifier volume, in per cents.',lib:'bluetoothlink&rarr;set_preAmplifier()',pro:'int set_preAmplifier(int <span id=pn>newval</span>)',cmt:'<p>Changes the audio pre-amplifier volume, in per cents.</p>',par:{newval:'an integer corresponding to the audio pre-amplifier volume, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_remoteAddress']={syn:'Changes the MAC-48 address defining which remote device to connect to.',lib:'bluetoothlink&rarr;set_remoteAddress()',pro:'int set_remoteAddress(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the MAC-48 address defining which remote device to connect to.</p>',par:{newval:'a string corresponding to the MAC-48 address defining which remote device to connect to'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'bluetoothlink&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['BluetoothLink']['set_volume']={syn:'Changes the connected headset volume, in per cents.',lib:'bluetoothlink&rarr;set_volume()',pro:'int set_volume(int <span id=pn>newval</span>)',cmt:'<p>Changes the connected headset volume, in per cents.</p>',par:{newval:'an integer corresponding to the connected headset volume, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['BluetoothLink']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'bluetoothlink&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: BluetoothLink)
//--- (generated code: AudioIn)
doc['AudioIn']={'':{syn:'AudioIn function interface',inc:'#include &quot;yocto_audioin.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to configure the volume of the input channel.</p>'}};
doc['AudioIn']['FindAudioIn']={syn:'Retrieves an audio input for a given identifier.',lib:'YAudioIn::FindAudioIn()',pro:'YAudioIn* FindAudioIn(string <span id=pn>func</span>)',cmt:'<p>Retrieves an audio input for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the audio input is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YAudioIn.isOnline()</tt> to test if the audio input is indeed online at a given time. In case of ambiguity when looking for an audio input by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the audio input'},ret:'a <tt>YAudioIn</tt> object allowing you to drive the audio input.'};
doc['AudioIn']['FirstAudioIn']={syn:'Starts the enumeration of audio inputs currently accessible.',lib:'YAudioIn::FirstAudioIn()',pro:'YAudioIn* FirstAudioIn()',cmt:'<p>Starts the enumeration of audio inputs currently accessible. Use the method <tt>YAudioIn.nextAudioIn()</tt> to iterate on next audio inputs.</p>',ret:'a pointer to a <tt>YAudioIn</tt> object, corresponding to the first audio input currently online, or a <tt>null</tt> pointer if there are none.'};
doc['AudioIn']['clearCache']={syn:'Invalidates the cache.',lib:'audioin&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the audio input attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['AudioIn']['describe']={syn:'Returns a short text that describes unambiguously the instance of the audio input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'audioin&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the audio input in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the audio input (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AudioIn']['get_advertisedValue']={syn:'Returns the current value of the audio input (no more than 6 characters).',lib:'audioin&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the audio input (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the audio input (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AudioIn']['get_errorMessage']={syn:'Returns the error message of the latest error with the audio input.',lib:'audioin&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the audio input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the audio input object'};
doc['AudioIn']['get_errorType']={syn:'Returns the numerical error code of the latest error with the audio input.',lib:'audioin&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the audio input. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the audio input object'};
doc['AudioIn']['get_friendlyName']={syn:'Returns a global identifier of the audio input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'audioin&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the audio input in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the audio input if they are defined, otherwise the serial number of the module and the hardware identifier of the audio input (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the audio input using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AudioIn']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'audioin&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['AudioIn']['get_functionId']={syn:'Returns the hardware identifier of the audio input, without reference to the module.',lib:'audioin&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the audio input, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the audio input (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AudioIn']['get_hardwareId']={syn:'Returns the unique hardware identifier of the audio input in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'audioin&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the audio input in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the audio input (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the audio input (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AudioIn']['get_logicalName']={syn:'Returns the logical name of the audio input.',lib:'audioin&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the audio input.</p>',ret:'a string corresponding to the logical name of the audio input.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AudioIn']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'audioin&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['AudioIn']['get_mute']={syn:'Returns the state of the mute function.',lib:'audioin&rarr;get_mute()',pro:'Y_MUTE_enum get_mute()',cmt:'<p>Returns the state of the mute function.</p>',ret:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function',ext:'On failure, throws an exception or returns <tt>Y_MUTE_INVALID</tt>.'};
doc['AudioIn']['get_noSignalFor']={syn:'Returns the number of seconds elapsed without detecting a signal.',lib:'audioin&rarr;get_noSignalFor()',pro:'int get_noSignalFor()',cmt:'<p>Returns the number of seconds elapsed without detecting a signal.</p>',ret:'an integer corresponding to the number of seconds elapsed without detecting a signal',ext:'On failure, throws an exception or returns <tt>Y_NOSIGNALFOR_INVALID</tt>.'};
doc['AudioIn']['get_signal']={syn:'Returns the detected input signal level.',lib:'audioin&rarr;get_signal()',pro:'int get_signal()',cmt:'<p>Returns the detected input signal level.</p>',ret:'an integer corresponding to the detected input signal level',ext:'On failure, throws an exception or returns <tt>Y_SIGNAL_INVALID</tt>.'};
doc['AudioIn']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'audioin&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['AudioIn']['get_volume']={syn:'Returns audio input gain, in per cents.',lib:'audioin&rarr;get_volume()',pro:'int get_volume()',cmt:'<p>Returns audio input gain, in per cents.</p>',ret:'an integer corresponding to audio input gain, in per cents',ext:'On failure, throws an exception or returns <tt>Y_VOLUME_INVALID</tt>.'};
doc['AudioIn']['get_volumeRange']={syn:'Returns the supported volume range.',lib:'audioin&rarr;get_volumeRange()',pro:'string get_volumeRange()',cmt:'<p>Returns the supported volume range. The low value of the range corresponds to the minimal audible value. To completely mute the sound, use <tt>set_mute()</tt> instead of the <tt>set_volume()</tt>.</p>',ret:'a string corresponding to the supported volume range',ext:'On failure, throws an exception or returns <tt>Y_VOLUMERANGE_INVALID</tt>.'};
doc['AudioIn']['isOnline']={syn:'Checks if the audio input is currently reachable, without raising any error.',lib:'audioin&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the audio input is currently reachable, without raising any error. If there is a cached value for the audio input in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the audio input.</p>',ret:'<tt>true</tt> if the audio input can be reached, and <tt>false</tt> otherwise'};
doc['AudioIn']['load']={syn:'Preloads the audio input cache with a specified validity duration.',lib:'audioin&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the audio input cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'audioin&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['AudioIn']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'audioin&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['nextAudioIn']={syn:'Continues the enumeration of audio inputs started using <tt>yFirstAudioIn()</tt>.',lib:'audioin&rarr;nextAudioIn()',pro:'YAudioIn * nextAudioIn()',cmt:'<p>Continues the enumeration of audio inputs started using <tt>yFirstAudioIn()</tt>.</p>',ret:'a pointer to a <tt>YAudioIn</tt> object, corresponding to an audio input currently online, or a <tt>null</tt> pointer if there are no more audio inputs to enumerate.'};
doc['AudioIn']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'audioin&rarr;registerValueCallback()',pro:'int registerValueCallback(YAudioInValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['AudioIn']['set_logicalName']={syn:'Changes the logical name of the audio input.',lib:'audioin&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the audio input. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the audio input.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['set_mute']={syn:'Changes the state of the mute function.',lib:'audioin&rarr;set_mute()',pro:'int set_mute(Y_MUTE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the state of the mute function. Remember to call the matching module <tt>saveToFlash()</tt> method to save the setting permanently.</p>',par:{newval:'either <tt>Y_MUTE_FALSE</tt> or <tt>Y_MUTE_TRUE</tt>, according to the state of the mute function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'audioin&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['AudioIn']['set_volume']={syn:'Changes audio input gain, in per cents.',lib:'audioin&rarr;set_volume()',pro:'int set_volume(int <span id=pn>newval</span>)',cmt:'<p>Changes audio input gain, in per cents.</p>',par:{newval:'an integer corresponding to audio input gain, in per cents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['AudioIn']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'audioin&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: AudioIn)
//--- (generated code: QuadratureDecoder)
doc['QuadratureDecoder']={'':{syn:'QuadratureDecoder function interface',inc:'#include &quot;yocto_quadraturedecoder.h&quot;',cmt:'<p>The class YQuadratureDecoder allows you to decode a two-wire signal produced by a quadrature encoder. It inherits from YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger.</p>'}};
doc['QuadratureDecoder']['FindQuadratureDecoder']={syn:'Retrieves a quadrature decoder for a given identifier.',lib:'YQuadratureDecoder::FindQuadratureDecoder()',pro:'YQuadratureDecoder* FindQuadratureDecoder(string <span id=pn>func</span>)',cmt:'<p>Retrieves a quadrature decoder for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the quadrature decoder is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YQuadratureDecoder.isOnline()</tt> to test if the quadrature decoder is indeed online at a given time. In case of ambiguity when looking for a quadrature decoder by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the quadrature decoder'},ret:'a <tt>YQuadratureDecoder</tt> object allowing you to drive the quadrature decoder.'};
doc['QuadratureDecoder']['FirstQuadratureDecoder']={syn:'Starts the enumeration of quadrature decoders currently accessible.',lib:'YQuadratureDecoder::FirstQuadratureDecoder()',pro:'YQuadratureDecoder* FirstQuadratureDecoder()',cmt:'<p>Starts the enumeration of quadrature decoders currently accessible. Use the method <tt>YQuadratureDecoder.nextQuadratureDecoder()</tt> to iterate on next quadrature decoders.</p>',ret:'a pointer to a <tt>YQuadratureDecoder</tt> object, corresponding to the first quadrature decoder currently online, or a <tt>null</tt> pointer if there are none.'};
doc['QuadratureDecoder']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'quadraturedecoder&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['clearCache']={syn:'Invalidates the cache.',lib:'quadraturedecoder&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the quadrature decoder attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['QuadratureDecoder']['describe']={syn:'Returns a short text that describes unambiguously the instance of the quadrature decoder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'quadraturedecoder&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the quadrature decoder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the quadrature decoder (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['QuadratureDecoder']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'quadraturedecoder&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_advertisedValue']={syn:'Returns the current value of the quadrature decoder (no more than 6 characters).',lib:'quadraturedecoder&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the quadrature decoder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the quadrature decoder (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.',lib:'quadraturedecoder&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in pas, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_currentValue']={syn:'Returns the current value of the position, in pas, as a floating point number.',lib:'quadraturedecoder&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the position, in pas, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the position, in pas, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'quadraturedecoder&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['QuadratureDecoder']['get_decoding']={syn:'Returns the current activation state of the quadrature decoder.',lib:'quadraturedecoder&rarr;get_decoding()',pro:'Y_DECODING_enum get_decoding()',cmt:'<p>Returns the current activation state of the quadrature decoder.</p>',ret:'either <tt>Y_DECODING_OFF</tt> or <tt>Y_DECODING_ON</tt>, according to the current activation state of the quadrature decoder',ext:'On failure, throws an exception or returns <tt>Y_DECODING_INVALID</tt>.'};
doc['QuadratureDecoder']['get_errorMessage']={syn:'Returns the error message of the latest error with the quadrature decoder.',lib:'quadraturedecoder&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the quadrature decoder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the quadrature decoder object'};
doc['QuadratureDecoder']['get_errorType']={syn:'Returns the numerical error code of the latest error with the quadrature decoder.',lib:'quadraturedecoder&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the quadrature decoder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the quadrature decoder object'};
doc['QuadratureDecoder']['get_friendlyName']={syn:'Returns a global identifier of the quadrature decoder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'quadraturedecoder&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the quadrature decoder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the quadrature decoder if they are defined, otherwise the serial number of the module and the hardware identifier of the quadrature decoder (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the quadrature decoder using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['QuadratureDecoder']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'quadraturedecoder&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['QuadratureDecoder']['get_functionId']={syn:'Returns the hardware identifier of the quadrature decoder, without reference to the module.',lib:'quadraturedecoder&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the quadrature decoder, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the quadrature decoder (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['QuadratureDecoder']['get_hardwareId']={syn:'Returns the unique hardware identifier of the quadrature decoder in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'quadraturedecoder&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the quadrature decoder in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the quadrature decoder (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the quadrature decoder (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['QuadratureDecoder']['get_highestValue']={syn:'Returns the maximal value observed for the position since the device was started.',lib:'quadraturedecoder&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the position since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'quadraturedecoder&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['QuadratureDecoder']['get_logicalName']={syn:'Returns the logical name of the quadrature decoder.',lib:'quadraturedecoder&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the quadrature decoder.</p>',ret:'a string corresponding to the logical name of the quadrature decoder.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['QuadratureDecoder']['get_lowestValue']={syn:'Returns the minimal value observed for the position since the device was started.',lib:'quadraturedecoder&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the position since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the position since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'quadraturedecoder&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['QuadratureDecoder']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'quadraturedecoder&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['QuadratureDecoder']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'quadraturedecoder&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['QuadratureDecoder']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'quadraturedecoder&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['QuadratureDecoder']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'quadraturedecoder&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['QuadratureDecoder']['get_speed']={syn:'Returns the increments frequency, in Hz.',lib:'quadraturedecoder&rarr;get_speed()',pro:'double get_speed()',cmt:'<p>Returns the increments frequency, in Hz.</p>',ret:'a floating point number corresponding to the increments frequency, in Hz',ext:'On failure, throws an exception or returns <tt>Y_SPEED_INVALID</tt>.'};
doc['QuadratureDecoder']['get_unit']={syn:'Returns the measuring unit for the position.',lib:'quadraturedecoder&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the position.</p>',ret:'a string corresponding to the measuring unit for the position',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['QuadratureDecoder']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'quadraturedecoder&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['QuadratureDecoder']['isOnline']={syn:'Checks if the quadrature decoder is currently reachable, without raising any error.',lib:'quadraturedecoder&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the quadrature decoder is currently reachable, without raising any error. If there is a cached value for the quadrature decoder in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the quadrature decoder.</p>',ret:'<tt>true</tt> if the quadrature decoder can be reached, and <tt>false</tt> otherwise'};
doc['QuadratureDecoder']['load']={syn:'Preloads the quadrature decoder cache with a specified validity duration.',lib:'quadraturedecoder&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the quadrature decoder cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'quadraturedecoder&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['QuadratureDecoder']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'quadraturedecoder&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'quadraturedecoder&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['nextQuadratureDecoder']={syn:'Continues the enumeration of quadrature decoders started using <tt>yFirstQuadratureDecoder()</tt>.',lib:'quadraturedecoder&rarr;nextQuadratureDecoder()',pro:'YQuadratureDecoder * nextQuadratureDecoder()',cmt:'<p>Continues the enumeration of quadrature decoders started using <tt>yFirstQuadratureDecoder()</tt>.</p>',ret:'a pointer to a <tt>YQuadratureDecoder</tt> object, corresponding to a quadrature decoder currently online, or a <tt>null</tt> pointer if there are no more quadrature decoders to enumerate.'};
doc['QuadratureDecoder']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'quadraturedecoder&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YQuadratureDecoderTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['QuadratureDecoder']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'quadraturedecoder&rarr;registerValueCallback()',pro:'int registerValueCallback(YQuadratureDecoderValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['QuadratureDecoder']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'quadraturedecoder&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_currentValue']={syn:'Changes the current expected position of the quadrature decoder.',lib:'quadraturedecoder&rarr;set_currentValue()',pro:'int set_currentValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the current expected position of the quadrature decoder. Invoking this function implicitely activates the quadrature decoder.</p>',par:{newval:'a floating point number corresponding to the current expected position of the quadrature decoder'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_decoding']={syn:'Changes the activation state of the quadrature decoder.',lib:'quadraturedecoder&rarr;set_decoding()',pro:'int set_decoding(Y_DECODING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the activation state of the quadrature decoder.</p>',par:{newval:'either <tt>Y_DECODING_OFF</tt> or <tt>Y_DECODING_ON</tt>, according to the activation state of the quadrature decoder'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'quadraturedecoder&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'quadraturedecoder&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_logicalName']={syn:'Changes the logical name of the quadrature decoder.',lib:'quadraturedecoder&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the quadrature decoder. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the quadrature decoder.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'quadraturedecoder&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'quadraturedecoder&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'quadraturedecoder&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['QuadratureDecoder']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'quadraturedecoder&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['QuadratureDecoder']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'quadraturedecoder&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['QuadratureDecoder']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'quadraturedecoder&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['QuadratureDecoder']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'quadraturedecoder&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: QuadratureDecoder)
//--- (generated code: CurrentLoopOutput)
doc['CurrentLoopOutput']={'':{syn:'CurrentLoopOutput function interface',inc:'#include &quot;yocto_currentloopoutput.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to change the value of the 4-20mA \x09 output as well as to know the current loop state.</p>'}};
doc['CurrentLoopOutput']['FindCurrentLoopOutput']={syn:'Retrieves a 4-20mA output for a given identifier.',lib:'YCurrentLoopOutput::FindCurrentLoopOutput()',pro:'YCurrentLoopOutput* FindCurrentLoopOutput(string <span id=pn>func</span>)',cmt:'<p>Retrieves a 4-20mA output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the 4-20mA output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YCurrentLoopOutput.isOnline()</tt> to test if the 4-20mA output is indeed online at a given time. In case of ambiguity when looking for a 4-20mA output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the 4-20mA output'},ret:'a <tt>YCurrentLoopOutput</tt> object allowing you to drive the 4-20mA output.'};
doc['CurrentLoopOutput']['FirstCurrentLoopOutput']={syn:'Starts the enumeration of 4-20mA outputs currently accessible.',lib:'YCurrentLoopOutput::FirstCurrentLoopOutput()',pro:'YCurrentLoopOutput* FirstCurrentLoopOutput()',cmt:'<p>Starts the enumeration of 4-20mA outputs currently accessible. Use the method <tt>YCurrentLoopOutput.nextCurrentLoopOutput()</tt> to iterate on next 4-20mA outputs.</p>',ret:'a pointer to a <tt>YCurrentLoopOutput</tt> object, corresponding to the first 4-20mA output currently online, or a <tt>null</tt> pointer if there are none.'};
doc['CurrentLoopOutput']['clearCache']={syn:'Invalidates the cache.',lib:'currentloopoutput&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the 4-20mA output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['CurrentLoopOutput']['currentMove']={syn:'Performs a smooth transistion of current flowing in the loop.',lib:'currentloopoutput&rarr;currentMove()',pro:'int currentMove(double <span id=pn>mA_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transistion of current flowing in the loop. Any current explicit change cancels any ongoing transition process.</p>',par:{mA_target:'new current value at the end of the transition (floating-point number, representing the end current in mA)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.'};
doc['CurrentLoopOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the 4-20mA output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'currentloopoutput&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the 4-20mA output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the 4-20mA output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CurrentLoopOutput']['get_advertisedValue']={syn:'Returns the current value of the 4-20mA output (no more than 6 characters).',lib:'currentloopoutput&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the 4-20mA output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the 4-20mA output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_current']={syn:'Returns the loop current set point in mA.',lib:'currentloopoutput&rarr;get_current()',pro:'double get_current()',cmt:'<p>Returns the loop current set point in mA.</p>',ret:'a floating point number corresponding to the loop current set point in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENT_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_currentAtStartUp']={syn:'Returns the current in the loop at device startup, in mA.',lib:'currentloopoutput&rarr;get_currentAtStartUp()',pro:'double get_currentAtStartUp()',cmt:'<p>Returns the current in the loop at device startup, in mA.</p>',ret:'a floating point number corresponding to the current in the loop at device startup, in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENTATSTARTUP_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the 4-20mA output.',lib:'currentloopoutput&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the 4-20mA output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the 4-20mA output object'};
doc['CurrentLoopOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the 4-20mA output.',lib:'currentloopoutput&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the 4-20mA output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the 4-20mA output object'};
doc['CurrentLoopOutput']['get_friendlyName']={syn:'Returns a global identifier of the 4-20mA output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'currentloopoutput&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the 4-20mA output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the 4-20mA output if they are defined, otherwise the serial number of the module and the hardware identifier of the 4-20mA output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the 4-20mA output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'currentloopoutput&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_functionId']={syn:'Returns the hardware identifier of the 4-20mA output, without reference to the module.',lib:'currentloopoutput&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the 4-20mA output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the 4-20mA output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the 4-20mA output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'currentloopoutput&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the 4-20mA output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the 4-20mA output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the 4-20mA output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_logicalName']={syn:'Returns the logical name of the 4-20mA output.',lib:'currentloopoutput&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the 4-20mA output.</p>',ret:'a string corresponding to the logical name of the 4-20mA output.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_loopPower']={syn:'Returns the loop powerstate.',lib:'currentloopoutput&rarr;get_loopPower()',pro:'Y_LOOPPOWER_enum get_loopPower()',cmt:'<p>Returns the loop powerstate. POWEROK: the loop \x09 is powered. NOPWR: the loop in not powered. LOWPWR: the loop is not powered enough to maintain the current required (insufficient voltage).</p>',ret:'a value among <tt>Y_LOOPPOWER_NOPWR</tt>, <tt>Y_LOOPPOWER_LOWPWR</tt> and <tt>Y_LOOPPOWER_POWEROK</tt> corresponding to the loop powerstate',ext:'On failure, throws an exception or returns <tt>Y_LOOPPOWER_INVALID</tt>.'};
doc['CurrentLoopOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'currentloopoutput&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['CurrentLoopOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'currentloopoutput&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['CurrentLoopOutput']['isOnline']={syn:'Checks if the 4-20mA output is currently reachable, without raising any error.',lib:'currentloopoutput&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the 4-20mA output is currently reachable, without raising any error. If there is a cached value for the 4-20mA output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the 4-20mA output.</p>',ret:'<tt>true</tt> if the 4-20mA output can be reached, and <tt>false</tt> otherwise'};
doc['CurrentLoopOutput']['load']={syn:'Preloads the 4-20mA output cache with a specified validity duration.',lib:'currentloopoutput&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the 4-20mA output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'currentloopoutput&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['CurrentLoopOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'currentloopoutput&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['nextCurrentLoopOutput']={syn:'Continues the enumeration of 4-20mA outputs started using <tt>yFirstCurrentLoopOutput()</tt>.',lib:'currentloopoutput&rarr;nextCurrentLoopOutput()',pro:'YCurrentLoopOutput * nextCurrentLoopOutput()',cmt:'<p>Continues the enumeration of 4-20mA outputs started using <tt>yFirstCurrentLoopOutput()</tt>.</p>',ret:'a pointer to a <tt>YCurrentLoopOutput</tt> object, corresponding to a 4-20mA output currently online, or a <tt>null</tt> pointer if there are no more 4-20mA outputs to enumerate.'};
doc['CurrentLoopOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'currentloopoutput&rarr;registerValueCallback()',pro:'int registerValueCallback(YCurrentLoopOutputValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['CurrentLoopOutput']['set_current']={syn:'Changes the current loop, the valid range is from 3 to 21mA.',lib:'currentloopoutput&rarr;set_current()',pro:'int set_current(double <span id=pn>newval</span>)',cmt:'<p>Changes the current loop, the valid range is from 3 to 21mA. If the loop is \x09 not propely powered, the target current is not reached and \x09\x09loopPower is set to LOWPWR.</p>',par:{newval:'a floating point number corresponding to the current loop, the valid range is from 3 to 21mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['set_currentAtStartUp']={syn:'Changes the loop current at device start up.',lib:'currentloopoutput&rarr;set_currentAtStartUp()',pro:'int set_currentAtStartUp(double <span id=pn>newval</span>)',cmt:'<p>Changes the loop current at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the loop current at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['set_logicalName']={syn:'Changes the logical name of the 4-20mA output.',lib:'currentloopoutput&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the 4-20mA output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the 4-20mA output.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['CurrentLoopOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'currentloopoutput&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['CurrentLoopOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'currentloopoutput&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: CurrentLoopOutput)
//--- (generated code: ColorLedCluster)
doc['ColorLedCluster']={'':{syn:'ColorLedCluster function interface',inc:'#include &quot;yocto_colorledcluster.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to drive a color LED cluster. Unlike the ColorLed class, the ColorLedCluster allows to handle several LEDs at one. Color changes can be done using RGB coordinates as well as HSL coordinates. The module performs all conversions form RGB to HSL automatically. It is then self-evident to turn on a LED with a given hue and to progressively vary its saturation or lightness. If needed, you can find more information on the difference between RGB and HSL in the section following this one.</p>'}};
doc['ColorLedCluster']['FindColorLedCluster']={syn:'Retrieves a RGB LED cluster for a given identifier.',lib:'YColorLedCluster::FindColorLedCluster()',pro:'YColorLedCluster* FindColorLedCluster(string <span id=pn>func</span>)',cmt:'<p>Retrieves a RGB LED cluster for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the RGB LED cluster is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YColorLedCluster.isOnline()</tt> to test if the RGB LED cluster is indeed online at a given time. In case of ambiguity when looking for a RGB LED cluster by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the RGB LED cluster'},ret:'a <tt>YColorLedCluster</tt> object allowing you to drive the RGB LED cluster.'};
doc['ColorLedCluster']['FirstColorLedCluster']={syn:'Starts the enumeration of RGB LED clusters currently accessible.',lib:'YColorLedCluster::FirstColorLedCluster()',pro:'YColorLedCluster* FirstColorLedCluster()',cmt:'<p>Starts the enumeration of RGB LED clusters currently accessible. Use the method <tt>YColorLedCluster.nextColorLedCluster()</tt> to iterate on next RGB LED clusters.</p>',ret:'a pointer to a <tt>YColorLedCluster</tt> object, corresponding to the first RGB LED cluster currently online, or a <tt>null</tt> pointer if there are none.'};
doc['ColorLedCluster']['addHslMoveToBlinkSeq']={syn:'Adds an HSL transition to a sequence.',lib:'colorledcluster&rarr;addHslMoveToBlinkSeq()',pro:'int addHslMoveToBlinkSeq(int <span id=pn>seqIndex</span>, int <span id=pn>hslValue</span>, int <span id=pn>delay</span>)',cmt:'<p>Adds an HSL transition to a sequence. A sequence is a transition list, which can be executed in loop by an group of LEDs. Sequences are persistant and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',hslValue:'target color (0xHHSSLL)',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addJumpToBlinkSeq']={syn:'Adds to a sequence a jump to another sequence.',lib:'colorledcluster&rarr;addJumpToBlinkSeq()',pro:'int addJumpToBlinkSeq(int <span id=pn>seqIndex</span>, int <span id=pn>linkSeqIndex</span>)',cmt:'<p>Adds to a sequence a jump to another sequence. When a pixel will reach this jump, it will be automatically relinked to the new sequence, and will run it starting from the beginning.</p>',par:{seqIndex:'sequence index.',linkSeqIndex:'index of the sequence to chain.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addMirrorToBlinkSeq']={syn:'Adds a mirror ending to a sequence.',lib:'colorledcluster&rarr;addMirrorToBlinkSeq()',pro:'int addMirrorToBlinkSeq(int <span id=pn>seqIndex</span>)',cmt:'<p>Adds a mirror ending to a sequence. When the sequence will reach the end of the last transition, its running speed will automatically be reversed so that the sequence plays in the reverse direction, like in a mirror. After the first transition of the sequence is played at the end of the reverse execution, the sequence starts again in the initial direction.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addRgbMoveToBlinkSeq']={syn:'Adds an RGB transition to a sequence.',lib:'colorledcluster&rarr;addRgbMoveToBlinkSeq()',pro:'int addRgbMoveToBlinkSeq(int <span id=pn>seqIndex</span>, int <span id=pn>rgbValue</span>, int <span id=pn>delay</span>)',cmt:'<p>Adds an RGB transition to a sequence. A sequence is a transition list, which can be executed in loop by a group of LEDs. Sequences are persistent and are saved in the device flash memory as soon as the <tt>saveBlinkSeq()</tt> method is called.</p>',par:{seqIndex:'sequence index.',rgbValue:'target color (0xRRGGBB)',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['addUnlinkToBlinkSeq']={syn:'Adds a to a sequence a hard stop code.',lib:'colorledcluster&rarr;addUnlinkToBlinkSeq()',pro:'int addUnlinkToBlinkSeq(int <span id=pn>seqIndex</span>)',cmt:'<p>Adds a to a sequence a hard stop code. When a pixel will reach this stop code, instead of restarting the sequence in a loop it will automatically be unlinked from the sequence.</p>',par:{seqIndex:'sequence index.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['clearCache']={syn:'Invalidates the cache.',lib:'colorledcluster&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the RGB LED cluster attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['ColorLedCluster']['describe']={syn:'Returns a short text that describes unambiguously the instance of the RGB LED cluster in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorledcluster&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the RGB LED cluster in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the RGB LED cluster (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLedCluster']['get_activeLedCount']={syn:'Returns the number of LEDs currently handled by the device.',lib:'colorledcluster&rarr;get_activeLedCount()',pro:'int get_activeLedCount()',cmt:'<p>Returns the number of LEDs currently handled by the device.</p>',ret:'an integer corresponding to the number of LEDs currently handled by the device',ext:'On failure, throws an exception or returns <tt>Y_ACTIVELEDCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_advertisedValue']={syn:'Returns the current value of the RGB LED cluster (no more than 6 characters).',lib:'colorledcluster&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the RGB LED cluster (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the RGB LED cluster (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqMaxCount']={syn:'Returns the maximum number of sequences that the device can handle.',lib:'colorledcluster&rarr;get_blinkSeqMaxCount()',pro:'int get_blinkSeqMaxCount()',cmt:'<p>Returns the maximum number of sequences that the device can handle.</p>',ret:'an integer corresponding to the maximum number of sequences that the device can handle',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqMaxSize']={syn:'Returns the maximum length of sequences.',lib:'colorledcluster&rarr;get_blinkSeqMaxSize()',pro:'int get_blinkSeqMaxSize()',cmt:'<p>Returns the maximum length of sequences.</p>',ret:'an integer corresponding to the maximum length of sequences',ext:'On failure, throws an exception or returns <tt>Y_BLINKSEQMAXSIZE_INVALID</tt>.'};
doc['ColorLedCluster']['get_blinkSeqSignatures']={syn:'Returns a list on 32 bit signatures for specified blinking sequences.',lib:'colorledcluster&rarr;get_blinkSeqSignatures()',pro:'vector&lt;int&gt; get_blinkSeqSignatures(int <span id=pn>seqIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list on 32 bit signatures for specified blinking sequences. Since blinking sequences cannot be read from the device, this can be used to detect if a specific blinking sequence is already programmed.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of 32 bit integer signatures',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_blinkSeqState']={syn:'Returns a list of integers with the started state for specified blinking sequences.',lib:'colorledcluster&rarr;get_blinkSeqState()',pro:'vector&lt;int&gt; get_blinkSeqState(int <span id=pn>seqIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the started state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_blinkSeqStateAtPowerOn']={syn:'Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.',lib:'colorledcluster&rarr;get_blinkSeqStateAtPowerOn()',pro:'vector&lt;int&gt; get_blinkSeqStateAtPowerOn(int <span id=pn>seqIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the \x22auto-start at power on\x22 flag state for specified blinking sequences.</p>',par:{seqIndex:'index of the first blinking sequence which should be returned',count:'number of blinking sequences which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_blinkSeqStateSpeed']={syn:'Returns a list of integers with the current speed for specified blinking sequences.',lib:'colorledcluster&rarr;get_blinkSeqStateSpeed()',pro:'vector&lt;int&gt; get_blinkSeqStateSpeed(int <span id=pn>seqIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list of integers with the current speed for specified blinking sequences.</p>',par:{seqIndex:'index of the first sequence speed which should be returned',count:'number of sequence speeds which should be returned'},ret:'a list of integers, 0 for sequences turned off and 1 for sequences running',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_errorMessage']={syn:'Returns the error message of the latest error with the RGB LED cluster.',lib:'colorledcluster&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the RGB LED cluster. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the RGB LED cluster object'};
doc['ColorLedCluster']['get_errorType']={syn:'Returns the numerical error code of the latest error with the RGB LED cluster.',lib:'colorledcluster&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the RGB LED cluster. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the RGB LED cluster object'};
doc['ColorLedCluster']['get_friendlyName']={syn:'Returns a global identifier of the RGB LED cluster in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'colorledcluster&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the RGB LED cluster in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the RGB LED cluster if they are defined, otherwise the serial number of the module and the hardware identifier of the RGB LED cluster (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the RGB LED cluster using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLedCluster']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'colorledcluster&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['ColorLedCluster']['get_functionId']={syn:'Returns the hardware identifier of the RGB LED cluster, without reference to the module.',lib:'colorledcluster&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the RGB LED cluster, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the RGB LED cluster (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLedCluster']['get_hardwareId']={syn:'Returns the unique hardware identifier of the RGB LED cluster in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'colorledcluster&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the RGB LED cluster in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the RGB LED cluster (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the RGB LED cluster (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLedCluster']['get_linkedSeqArray']={syn:'Returns a list on sequence index for each RGB LED.',lib:'colorledcluster&rarr;get_linkedSeqArray()',pro:'vector&lt;int&gt; get_linkedSeqArray(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list on sequence index for each RGB LED. The first number represents the sequence index for the the first LED, the second number represents the sequence index for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of integers with sequence index',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_logicalName']={syn:'Returns the logical name of the RGB LED cluster.',lib:'colorledcluster&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the RGB LED cluster.</p>',ret:'a string corresponding to the logical name of the RGB LED cluster.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLedCluster']['get_maxLedCount']={syn:'Returns the maximum number of LEDs that the device can handle.',lib:'colorledcluster&rarr;get_maxLedCount()',pro:'int get_maxLedCount()',cmt:'<p>Returns the maximum number of LEDs that the device can handle.</p>',ret:'an integer corresponding to the maximum number of LEDs that the device can handle',ext:'On failure, throws an exception or returns <tt>Y_MAXLEDCOUNT_INVALID</tt>.'};
doc['ColorLedCluster']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'colorledcluster&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['ColorLedCluster']['get_rgbColorArray']={syn:'Returns a list on 24bit RGB color values with the current colors displayed on the RGB leds.',lib:'colorledcluster&rarr;get_rgbColorArray()',pro:'vector&lt;int&gt; get_rgbColorArray(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list on 24bit RGB color values with the current colors displayed on the RGB leds. The first number represents the RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_rgbColorArrayAtPowerOn']={syn:'Returns a list on 24bit RGB color values with the RGB LEDs startup colors.',lib:'colorledcluster&rarr;get_rgbColorArrayAtPowerOn()',pro:'vector&lt;int&gt; get_rgbColorArrayAtPowerOn(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a list on 24bit RGB color values with the RGB LEDs startup colors. The first number represents the startup RGB value of the first LED, the second number represents the RGB value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a list of 24bit color codes with RGB components of selected LEDs, as 0xRRGGBB.',ext:'On failure, throws an exception or returns an empty array.'};
doc['ColorLedCluster']['get_rgbColorBuffer']={syn:'Returns a binary buffer with content from the LED RGB buffer, as is.',lib:'colorledcluster&rarr;get_rgbColorBuffer()',pro:'string get_rgbColorBuffer(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Returns a binary buffer with content from the LED RGB buffer, as is. First three bytes are RGB components for the first LED in the interval, the next three bytes for the second LED in the interval, etc.</p>',par:{ledIndex:'index of the first LED which should be returned',count:'number of LEDs which should be returned'},ret:'a binary buffer with RGB components of selected LEDs.',ext:'On failure, throws an exception or returns an empty binary buffer.'};
doc['ColorLedCluster']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'colorledcluster&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['ColorLedCluster']['hslArrayOfs_move']={syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'colorledcluster&rarr;hslArrayOfs_move()',pro:'int hslArrayOfs_move(int <span id=pn>ledIndex</span>, vector&lt;int&gt; <span id=pn>hslList</span>, int <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['hslArray_move']={syn:'Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes.',lib:'colorledcluster&rarr;hslArray_move()',pro:'int hslArray_move(vector&lt;int&gt; <span id=pn>hslList</span>, int <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth HSL color transition to the specified pixel-by-pixel list of HSL color codes. The first color code represents the target HSL value of the first LED, the second color code represents the target value of the second LED, etc.</p>',par:{hslList:'a list of target 24bit HSL codes, in the form 0xHHSSLL',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['hsl_move']={syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'colorledcluster&rarr;hsl_move()',pro:'int hsl_move(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>, int <span id=pn>hslValue</span>, int <span id=pn>delay</span>)',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the HSL space. In HSL, hue is a circular value (0..360\xB0). There are always two paths to perform the transition: by increasing or by decreasing the hue. The module selects the shortest transition. If the difference is exactly 180\xB0, the module selects the transition which increases the hue.</p>',par:{ledIndex:'index of the fisrt affected LED.',count:'affected LED count.',hslValue:'new color (0xHHSSLL).',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['isOnline']={syn:'Checks if the RGB LED cluster is currently reachable, without raising any error.',lib:'colorledcluster&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the RGB LED cluster is currently reachable, without raising any error. If there is a cached value for the RGB LED cluster in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the RGB LED cluster.</p>',ret:'<tt>true</tt> if the RGB LED cluster can be reached, and <tt>false</tt> otherwise'};
doc['ColorLedCluster']['linkLedToBlinkSeq']={syn:'Links adjacent LEDs to a specific sequence.',lib:'colorledcluster&rarr;linkLedToBlinkSeq()',pro:'int linkLedToBlinkSeq(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>, int <span id=pn>seqIndex</span>, int <span id=pn>offset</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence. These LEDs start to execute the sequence as soon as startBlinkSeq is called. It is possible to add an offset in the execution: that way we can have several groups of LED executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['linkLedToBlinkSeqAtPowerOn']={syn:'Links adjacent LEDs to a specific sequence at device poweron.',lib:'colorledcluster&rarr;linkLedToBlinkSeqAtPowerOn()',pro:'int linkLedToBlinkSeqAtPowerOn(int <span id=pn>ledIndex</span>,&nbsp;int <span id=pn>count</span>,&nbsp;int <span id=pn>seqIndex</span>,&nbsp;int <span id=pn>offset</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence at device poweron. Don\x27t forget to configure the sequence auto start flag as well and call <tt>saveLedsConfigAtPowerOn()</tt>. It is possible to add an offset in the execution: that way we can have several groups of LEDs executing the same sequence, with a temporal offset. A LED cannot be linked to more than one sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',offset:'execution offset in ms.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['linkLedToPeriodicBlinkSeq']={syn:'Links adjacent LEDs to a specific sequence.',lib:'colorledcluster&rarr;linkLedToPeriodicBlinkSeq()',pro:'int linkLedToPeriodicBlinkSeq(int <span id=pn>ledIndex</span>,&nbsp;int <span id=pn>count</span>,&nbsp;int <span id=pn>seqIndex</span>,&nbsp;int <span id=pn>periods</span>)',cmt:'<p>Links adjacent LEDs to a specific sequence. These LED start to execute the sequence as soon as startBlinkSeq is called. This function automatically introduces a shift between LEDs so that the specified number of sequence periods appears on the group of LEDs (wave effect).</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',seqIndex:'sequence index.',periods:'number of periods to show on LEDs.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['load']={syn:'Preloads the RGB LED cluster cache with a specified validity duration.',lib:'colorledcluster&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the RGB LED cluster cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'colorledcluster&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['ColorLedCluster']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'colorledcluster&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['nextColorLedCluster']={syn:'Continues the enumeration of RGB LED clusters started using <tt>yFirstColorLedCluster()</tt>.',lib:'colorledcluster&rarr;nextColorLedCluster()',pro:'YColorLedCluster * nextColorLedCluster()',cmt:'<p>Continues the enumeration of RGB LED clusters started using <tt>yFirstColorLedCluster()</tt>.</p>',ret:'a pointer to a <tt>YColorLedCluster</tt> object, corresponding to a RGB LED cluster currently online, or a <tt>null</tt> pointer if there are no more RGB LED clusters to enumerate.'};
doc['ColorLedCluster']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'colorledcluster&rarr;registerValueCallback()',pro:'int registerValueCallback(YColorLedClusterValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['ColorLedCluster']['resetBlinkSeq']={syn:'Stops a sequence execution and resets its contents.',lib:'colorledcluster&rarr;resetBlinkSeq()',pro:'int resetBlinkSeq(int <span id=pn>seqIndex</span>)',cmt:'<p>Stops a sequence execution and resets its contents. Leds linked to this sequence are not automatically updated anymore.</p>',par:{seqIndex:'index of the sequence to reset'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['rgbArrayOfs_move']={syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'colorledcluster&rarr;rgbArrayOfs_move()',pro:'int rgbArrayOfs_move(int <span id=pn>ledIndex</span>, vector&lt;int&gt; <span id=pn>rgbList</span>, int <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['rgbArray_move']={syn:'Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes.',lib:'colorledcluster&rarr;rgbArray_move()',pro:'int rgbArray_move(vector&lt;int&gt; <span id=pn>rgbList</span>, int <span id=pn>delay</span>)',cmt:'<p>Sets up a smooth RGB color transition to the specified pixel-by-pixel list of RGB color codes. The first color code represents the target RGB value of the first LED, the next color code represents the target value of the next LED, etc.</p>',par:{rgbList:'a list of target 24bit RGB codes, in the form 0xRRGGBB',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['rgb_move']={syn:'Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner.',lib:'colorledcluster&rarr;rgb_move()',pro:'int rgb_move(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>, int <span id=pn>rgbValue</span>, int <span id=pn>delay</span>)',cmt:'<p>Allows you to modify the current color of a group of adjacent LEDs to another color, in a seamless and autonomous manner. The transition is performed in the RGB space.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color (0xRRGGBB).',delay:'transition duration in ms'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['saveBlinkSeq']={syn:'Saves the definition of a sequence.',lib:'colorledcluster&rarr;saveBlinkSeq()',pro:'int saveBlinkSeq(int <span id=pn>seqIndex</span>)',cmt:'<p>Saves the definition of a sequence. Warning: only sequence steps and flags are saved. to save the LEDs startup bindings, the method <tt>saveLedsConfigAtPowerOn()</tt> must be called.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['saveLedsConfigAtPowerOn']={syn:'Saves the LEDs power-on configuration.',lib:'colorledcluster&rarr;saveLedsConfigAtPowerOn()',pro:'int saveLedsConfigAtPowerOn()',cmt:'<p>Saves the LEDs power-on configuration. This includes the start-up color or sequence binding for all LEDs. Warning: if some LEDs are linked to a sequence, the method <tt>saveBlinkSeq()</tt> must also be called to save the sequence definition.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_activeLedCount']={syn:'Changes the number of LEDs currently handled by the device.',lib:'colorledcluster&rarr;set_activeLedCount()',pro:'int set_activeLedCount(int <span id=pn>newval</span>)',cmt:'<p>Changes the number of LEDs currently handled by the device.</p>',par:{newval:'an integer corresponding to the number of LEDs currently handled by the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_blinkSeqSpeed']={syn:'Changes the execution speed of a sequence.',lib:'colorledcluster&rarr;set_blinkSeqSpeed()',pro:'int set_blinkSeqSpeed(int <span id=pn>seqIndex</span>, int <span id=pn>speed</span>)',cmt:'<p>Changes the execution speed of a sequence. The natural execution speed is 1000 per thousand. If you configure a slower speed, you can play the sequence in slow-motion. If you set a negative speed, you can play the sequence in reverse direction.</p>',par:{seqIndex:'index of the sequence to start.',speed:'sequence running speed (-1000...1000).'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_blinkSeqStateAtPowerOn']={syn:'Configures a sequence to make it start automatically at device startup.',lib:'colorledcluster&rarr;set_blinkSeqStateAtPowerOn()',pro:'int set_blinkSeqStateAtPowerOn(int <span id=pn>seqIndex</span>, int <span id=pn>autostart</span>)',cmt:'<p>Configures a sequence to make it start automatically at device startup. Note that a sequence with a zero duration can\x27t be started. Don\x27t forget to call <tt>saveBlinkSeq()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{seqIndex:'index of the sequence to reset.',autostart:'0 to keep the sequence turned off and 1 to start it automatically.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColor']={syn:'Changes the current color of consecutive LEDs in the cluster, using a HSL color.',lib:'colorledcluster&rarr;set_hslColor()',pro:'int set_hslColor(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>, int <span id=pn>hslValue</span>)',cmt:'<p>Changes the current color of consecutive LEDs in the cluster, using a HSL color. Encoding is done as follows: 0xHHSSLL.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',hslValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColorArray']={syn:'Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is.',lib:'colorledcluster&rarr;set_hslColorArray()',pro:'int set_hslColorArray(int <span id=pn>ledIndex</span>, vector&lt;int&gt; <span id=pn>hslList</span>)',cmt:'<p>Sends 24bit HSL colors (provided as a list of integers) to the LED HSL buffer, as is. The first number represents the HSL value of the LED specified as parameter, the second number represents the HSL value of the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',hslList:'a list of 24bit HSL codes, in the form 0xHHSSLL'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_hslColorBuffer']={syn:'Sends a binary buffer to the LED HSL buffer, as is.',lib:'colorledcluster&rarr;set_hslColorBuffer()',pro:'int set_hslColorBuffer(int <span id=pn>ledIndex</span>, string <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the LED HSL buffer, as is. First three bytes are HSL components for the LED specified as parameter, the next three bytes for the second LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_logicalName']={syn:'Changes the logical name of the RGB LED cluster.',lib:'colorledcluster&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the RGB LED cluster. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the RGB LED cluster.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColor']={syn:'Changes the current color of consecutve LEDs in the cluster, using a RGB color.',lib:'colorledcluster&rarr;set_rgbColor()',pro:'int set_rgbColor(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>, int <span id=pn>rgbValue</span>)',cmt:'<p>Changes the current color of consecutve LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColorArray']={syn:'Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is.',lib:'colorledcluster&rarr;set_rgbColorArray()',pro:'int set_rgbColorArray(int <span id=pn>ledIndex</span>, vector&lt;int&gt; <span id=pn>rgbList</span>)',cmt:'<p>Sends 24bit RGB colors (provided as a list of integers) to the LED RGB buffer, as is. The first number represents the RGB value of the LED specified as parameter, the second number represents the RGB value of the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',rgbList:'a list of 24bit RGB codes, in the form 0xRRGGBB'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColorAtPowerOn']={syn:'Changes the color at device startup of consecutve LEDs in the cluster, using a RGB color.',lib:'colorledcluster&rarr;set_rgbColorAtPowerOn()',pro:'int set_rgbColorAtPowerOn(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>, int <span id=pn>rgbValue</span>)',cmt:'<p>Changes the color at device startup of consecutve LEDs in the cluster, using a RGB color. Encoding is done as follows: 0xRRGGBB. Don\x27t forget to call <tt>saveLedsConfigAtPowerOn()</tt> to make sure the modification is saved in the device flash memory.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.',rgbValue:'new color.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_rgbColorBuffer']={syn:'Sends a binary buffer to the LED RGB buffer, as is.',lib:'colorledcluster&rarr;set_rgbColorBuffer()',pro:'int set_rgbColorBuffer(int <span id=pn>ledIndex</span>, string <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the LED RGB buffer, as is. First three bytes are RGB components for LED specified as parameter, the next three bytes for the next LED, etc.</p>',par:{ledIndex:'index of the first LED which should be updated',buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'colorledcluster&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['ColorLedCluster']['startBlinkSeq']={syn:'Starts a sequence execution: every LED linked to that sequence starts to run it in a loop.',lib:'colorledcluster&rarr;startBlinkSeq()',pro:'int startBlinkSeq(int <span id=pn>seqIndex</span>)',cmt:'<p>Starts a sequence execution: every LED linked to that sequence starts to run it in a loop. Note that a sequence with a zero duration can\x27t be started.</p>',par:{seqIndex:'index of the sequence to start.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['stopBlinkSeq']={syn:'Stops a sequence execution.',lib:'colorledcluster&rarr;stopBlinkSeq()',pro:'int stopBlinkSeq(int <span id=pn>seqIndex</span>)',cmt:'<p>Stops a sequence execution. If started again, the execution restarts from the beginning.</p>',par:{seqIndex:'index of the sequence to stop.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['unlinkLedFromBlinkSeq']={syn:'Unlinks adjacent LEDs from a sequence.',lib:'colorledcluster&rarr;unlinkLedFromBlinkSeq()',pro:'int unlinkLedFromBlinkSeq(int <span id=pn>ledIndex</span>, int <span id=pn>count</span>)',cmt:'<p>Unlinks adjacent LEDs from a sequence.</p>',par:{ledIndex:'index of the first affected LED.',count:'affected LED count.'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['ColorLedCluster']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'colorledcluster&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: ColorLedCluster)
//--- (generated code: SpiPort)
doc['SpiPort']={'':{syn:'SPI Port function interface',inc:'#include &quot;yocto_spiport.h&quot;',cmt:'<p>The SpiPort function interface allows you to fully drive a Yoctopuce SPI port, to send and receive data, and to configure communication parameters (baud rate, bit count, parity, flow control and protocol). Note that Yoctopuce SPI ports are not exposed as virtual COM ports. They are meant to be used in the same way as all Yoctopuce devices.</p>'}};
doc['SpiPort']['FindSpiPort']={syn:'Retrieves a SPI port for a given identifier.',lib:'YSpiPort::FindSpiPort()',pro:'YSpiPort* FindSpiPort(string <span id=pn>func</span>)',cmt:'<p>Retrieves a SPI port for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the SPI port is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YSpiPort.isOnline()</tt> to test if the SPI port is indeed online at a given time. In case of ambiguity when looking for a SPI port by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the SPI port'},ret:'a <tt>YSpiPort</tt> object allowing you to drive the SPI port.'};
doc['SpiPort']['FirstSpiPort']={syn:'Starts the enumeration of SPI ports currently accessible.',lib:'YSpiPort::FirstSpiPort()',pro:'YSpiPort* FirstSpiPort()',cmt:'<p>Starts the enumeration of SPI ports currently accessible. Use the method <tt>YSpiPort.nextSpiPort()</tt> to iterate on next SPI ports.</p>',ret:'a pointer to a <tt>YSpiPort</tt> object, corresponding to the first SPI port currently online, or a <tt>null</tt> pointer if there are none.'};
doc['SpiPort']['clearCache']={syn:'Invalidates the cache.',lib:'spiport&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the SPI port attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['SpiPort']['describe']={syn:'Returns a short text that describes unambiguously the instance of the SPI port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'spiport&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the SPI port in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the SPI port (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['SpiPort']['get_advertisedValue']={syn:'Returns the current value of the SPI port (no more than 6 characters).',lib:'spiport&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the SPI port (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the SPI port (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['SpiPort']['get_currentJob']={syn:'Returns the name of the job file currently in use.',lib:'spiport&rarr;get_currentJob()',pro:'string get_currentJob()',cmt:'<p>Returns the name of the job file currently in use.</p>',ret:'a string corresponding to the name of the job file currently in use',ext:'On failure, throws an exception or returns <tt>Y_CURRENTJOB_INVALID</tt>.'};
doc['SpiPort']['get_errCount']={syn:'Returns the total number of communication errors detected since last reset.',lib:'spiport&rarr;get_errCount()',pro:'int get_errCount()',cmt:'<p>Returns the total number of communication errors detected since last reset.</p>',ret:'an integer corresponding to the total number of communication errors detected since last reset',ext:'On failure, throws an exception or returns <tt>Y_ERRCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_errorMessage']={syn:'Returns the error message of the latest error with the SPI port.',lib:'spiport&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the SPI port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the SPI port object'};
doc['SpiPort']['get_errorType']={syn:'Returns the numerical error code of the latest error with the SPI port.',lib:'spiport&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the SPI port. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the SPI port object'};
doc['SpiPort']['get_friendlyName']={syn:'Returns a global identifier of the SPI port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'spiport&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the SPI port in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the SPI port if they are defined, otherwise the serial number of the module and the hardware identifier of the SPI port (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the SPI port using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['SpiPort']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'spiport&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['SpiPort']['get_functionId']={syn:'Returns the hardware identifier of the SPI port, without reference to the module.',lib:'spiport&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the SPI port, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the SPI port (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['SpiPort']['get_hardwareId']={syn:'Returns the unique hardware identifier of the SPI port in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'spiport&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the SPI port in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the SPI port (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the SPI port (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['SpiPort']['get_lastMsg']={syn:'Returns the latest message fully received (for Line and Frame protocols).',lib:'spiport&rarr;get_lastMsg()',pro:'string get_lastMsg()',cmt:'<p>Returns the latest message fully received (for Line and Frame protocols).</p>',ret:'a string corresponding to the latest message fully received (for Line and Frame protocols)',ext:'On failure, throws an exception or returns <tt>Y_LASTMSG_INVALID</tt>.'};
doc['SpiPort']['get_logicalName']={syn:'Returns the logical name of the SPI port.',lib:'spiport&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the SPI port.</p>',ret:'a string corresponding to the logical name of the SPI port.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['SpiPort']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'spiport&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['SpiPort']['get_protocol']={syn:'Returns the type of protocol used over the serial line, as a string.',lib:'spiport&rarr;get_protocol()',pro:'string get_protocol()',cmt:'<p>Returns the type of protocol used over the serial line, as a string. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream.</p>',ret:'a string corresponding to the type of protocol used over the serial line, as a string',ext:'On failure, throws an exception or returns <tt>Y_PROTOCOL_INVALID</tt>.'};
doc['SpiPort']['get_rxCount']={syn:'Returns the total number of bytes received since last reset.',lib:'spiport&rarr;get_rxCount()',pro:'int get_rxCount()',cmt:'<p>Returns the total number of bytes received since last reset.</p>',ret:'an integer corresponding to the total number of bytes received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_rxMsgCount']={syn:'Returns the total number of messages received since last reset.',lib:'spiport&rarr;get_rxMsgCount()',pro:'int get_rxMsgCount()',cmt:'<p>Returns the total number of messages received since last reset.</p>',ret:'an integer corresponding to the total number of messages received since last reset',ext:'On failure, throws an exception or returns <tt>Y_RXMSGCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_shitftSampling']={syn:'Returns true when the SDI line phase is shifted with regards to the SDO line.',lib:'spiport&rarr;get_shitftSampling()',pro:'Y_SHITFTSAMPLING_enum get_shitftSampling()',cmt:'<p>Returns true when the SDI line phase is shifted with regards to the SDO line.</p>',ret:'either <tt>Y_SHITFTSAMPLING_OFF</tt> or <tt>Y_SHITFTSAMPLING_ON</tt>, according to true when the SDI line phase is shifted with regards to the SDO line',ext:'On failure, throws an exception or returns <tt>Y_SHITFTSAMPLING_INVALID</tt>.'};
doc['SpiPort']['get_spiMode']={syn:'Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22.',lib:'spiport&rarr;get_spiMode()',pro:'string get_spiMode()',cmt:'<p>Returns the SPI port communication parameters, as a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',ret:'a string corresponding to the SPI port communication parameters, as a string such as \x22125000,0,msb\x22',ext:'On failure, throws an exception or returns <tt>Y_SPIMODE_INVALID</tt>.'};
doc['SpiPort']['get_ssPolarity']={syn:'Returns the SS line polarity.',lib:'spiport&rarr;get_ssPolarity()',pro:'Y_SSPOLARITY_enum get_ssPolarity()',cmt:'<p>Returns the SS line polarity.</p>',ret:'either <tt>Y_SSPOLARITY_ACTIVE_LOW</tt> or <tt>Y_SSPOLARITY_ACTIVE_HIGH</tt>, according to the SS line polarity',ext:'On failure, throws an exception or returns <tt>Y_SSPOLARITY_INVALID</tt>.'};
doc['SpiPort']['get_startupJob']={syn:'Returns the job file to use when the device is powered on.',lib:'spiport&rarr;get_startupJob()',pro:'string get_startupJob()',cmt:'<p>Returns the job file to use when the device is powered on.</p>',ret:'a string corresponding to the job file to use when the device is powered on',ext:'On failure, throws an exception or returns <tt>Y_STARTUPJOB_INVALID</tt>.'};
doc['SpiPort']['get_txCount']={syn:'Returns the total number of bytes transmitted since last reset.',lib:'spiport&rarr;get_txCount()',pro:'int get_txCount()',cmt:'<p>Returns the total number of bytes transmitted since last reset.</p>',ret:'an integer corresponding to the total number of bytes transmitted since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_txMsgCount']={syn:'Returns the total number of messages send since last reset.',lib:'spiport&rarr;get_txMsgCount()',pro:'int get_txMsgCount()',cmt:'<p>Returns the total number of messages send since last reset.</p>',ret:'an integer corresponding to the total number of messages send since last reset',ext:'On failure, throws an exception or returns <tt>Y_TXMSGCOUNT_INVALID</tt>.'};
doc['SpiPort']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'spiport&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['SpiPort']['get_voltageLevel']={syn:'Returns the voltage level used on the serial line.',lib:'spiport&rarr;get_voltageLevel()',pro:'Y_VOLTAGELEVEL_enum get_voltageLevel()',cmt:'<p>Returns the voltage level used on the serial line.</p>',ret:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage level used on the serial line',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGELEVEL_INVALID</tt>.'};
doc['SpiPort']['isOnline']={syn:'Checks if the SPI port is currently reachable, without raising any error.',lib:'spiport&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the SPI port is currently reachable, without raising any error. If there is a cached value for the SPI port in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the SPI port.</p>',ret:'<tt>true</tt> if the SPI port can be reached, and <tt>false</tt> otherwise'};
doc['SpiPort']['load']={syn:'Preloads the SPI port cache with a specified validity duration.',lib:'spiport&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the SPI port cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'spiport&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['SpiPort']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'spiport&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['nextSpiPort']={syn:'Continues the enumeration of SPI ports started using <tt>yFirstSpiPort()</tt>.',lib:'spiport&rarr;nextSpiPort()',pro:'YSpiPort * nextSpiPort()',cmt:'<p>Continues the enumeration of SPI ports started using <tt>yFirstSpiPort()</tt>.</p>',ret:'a pointer to a <tt>YSpiPort</tt> object, corresponding to a SPI port currently online, or a <tt>null</tt> pointer if there are no more SPI ports to enumerate.'};
doc['SpiPort']['queryLine']={syn:'Sends a text line query to the serial port, and reads the reply, if any.',lib:'spiport&rarr;queryLine()',pro:'string queryLine(string <span id=pn>query</span>, int <span id=pn>maxWait</span>)',cmt:'<p>Sends a text line query to the serial port, and reads the reply, if any. This function is intended to be used when the serial port is configured for \x27Line\x27 protocol.</p>',par:{query:'the line query to send (without CR/LF)',maxWait:'the maximum number of milliseconds to wait for a reply.'},ret:'the next text line received after sending the text query, as a string. Additional lines can be obtained by calling readLine or readMessages.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SpiPort']['readArray']={syn:'Reads data from the receive buffer as a list of bytes, starting at current stream position.',lib:'spiport&rarr;readArray()',pro:'vector&lt;int&gt; readArray(int <span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a list of bytes, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a sequence of bytes with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readBin']={syn:'Reads data from the receive buffer as a binary buffer, starting at current stream position.',lib:'spiport&rarr;readBin()',pro:'string readBin(int <span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a binary buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of bytes to read'},ret:'a binary object with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readByte']={syn:'Reads one byte from the receive buffer, starting at current stream position.',lib:'spiport&rarr;readByte()',pro:'int readByte()',cmt:'<p>Reads one byte from the receive buffer, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, or if there is no data available yet, the function returns YAPI_NO_MORE_DATA.</p>',ret:'the next byte',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readHex']={syn:'Reads data from the receive buffer as a hexadecimal string, starting at current stream position.',lib:'spiport&rarr;readHex()',pro:'string readHex(int <span id=pn>nBytes</span>)',cmt:'<p>Reads data from the receive buffer as a hexadecimal string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nBytes:'the maximum number of bytes to read'},ret:'a string with receive buffer contents, encoded in hexadecimal',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readLine']={syn:'Reads a single line (or message) from the receive buffer, starting at current stream position.',lib:'spiport&rarr;readLine()',pro:'string readLine()',cmt:'<p>Reads a single line (or message) from the receive buffer, starting at current stream position. This function is intended to be used when the serial port is configured for a message protocol, such as \x27Line\x27 mode or frame protocols.</p><p> If data at current stream position is not available anymore in the receive buffer, the function returns the oldest available line and moves the stream position just after. If no new full line is received, the function returns an empty line.</p>',ret:'a string with a single line of text',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['readMessages']={syn:'Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position.',lib:'spiport&rarr;readMessages()',pro:'vector&lt;string&gt; readMessages(string <span id=pn>pattern</span>, int <span id=pn>maxWait</span>)',cmt:'<p>Searches for incoming messages in the serial port receive buffer matching a given pattern, starting at current position. This function will only compare and return printable characters in the message strings. Binary protocols are handled as hexadecimal strings.</p><p> The search returns all messages matching the expression provided as argument in the buffer. If no matching message is found, the search waits for one up to the specified maximum timeout (in milliseconds).</p>',par:{pattern:'a limited regular expression describing the expected message format, or an empty string if all messages should be returned (no filtering). When using binary protocols, the format applies to the hexadecimal representation of the message.',maxWait:'the maximum number of milliseconds to wait for a message if none is found in the receive buffer.'},ret:'an array of strings containing the messages found, if any. Binary messages are converted to hexadecimal representation.',ext:'On failure, throws an exception or returns an empty array.'};
doc['SpiPort']['readStr']={syn:'Reads data from the receive buffer as a string, starting at current stream position.',lib:'spiport&rarr;readStr()',pro:'string readStr(int <span id=pn>nChars</span>)',cmt:'<p>Reads data from the receive buffer as a string, starting at current stream position. If data at current stream position is not available anymore in the receive buffer, the function performs a short read.</p>',par:{nChars:'the maximum number of characters to read'},ret:'a string with receive buffer contents',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['read_avail']={syn:'Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.',lib:'spiport&rarr;read_avail()',pro:'int read_avail()',cmt:'<p>Returns the number of bytes available to read in the input buffer starting from the current absolute stream position pointer of the API object.</p>',ret:'the number of bytes available to read'};
doc['SpiPort']['read_seek']={syn:'Changes the current internal stream position to the specified value.',lib:'spiport&rarr;read_seek()',pro:'int read_seek(int <span id=pn>absPos</span>)',cmt:'<p>Changes the current internal stream position to the specified value. This function does not affect the device, it only changes the value stored in the API object for the next read operations.</p>',par:{absPos:'the absolute position index for next read operations.'},ret:'nothing.'};
doc['SpiPort']['read_tell']={syn:'Returns the current absolute stream position pointer of the API object.',lib:'spiport&rarr;read_tell()',pro:'int read_tell()',cmt:'<p>Returns the current absolute stream position pointer of the API object.</p>',ret:'the absolute position index for next read operations.'};
doc['SpiPort']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'spiport&rarr;registerValueCallback()',pro:'int registerValueCallback(YSpiPortValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['SpiPort']['reset']={syn:'Clears the serial port buffer and resets counters to zero.',lib:'spiport&rarr;reset()',pro:'int reset()',cmt:'<p>Clears the serial port buffer and resets counters to zero.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['selectJob']={syn:'Load and start processing the specified job file.',lib:'spiport&rarr;selectJob()',pro:'int selectJob(string <span id=pn>jobfile</span>)',cmt:'<p>Load and start processing the specified job file. The file must have been previously created using the user interface or uploaded on the device filesystem using the <tt>uploadJob()</tt> function.</p>',par:{jobfile:'name of the job file (on the device filesystem)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_SS']={syn:'Manually sets the state of the SS line.',lib:'spiport&rarr;set_SS()',pro:'int set_SS(int <span id=pn>val</span>)',cmt:'<p>Manually sets the state of the SS line. This function has no effect when the SS line is handled automatically.</p>',par:{val:'1 to turn SS active, 0 to release SS.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_currentJob']={syn:'Changes the job to use when the device is powered on.',lib:'spiport&rarr;set_currentJob()',pro:'int set_currentJob(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_logicalName']={syn:'Changes the logical name of the SPI port.',lib:'spiport&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the SPI port. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the SPI port.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_protocol']={syn:'Changes the type of protocol used over the serial line.',lib:'spiport&rarr;set_protocol()',pro:'int set_protocol(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the type of protocol used over the serial line. Possible values are \x22Line\x22 for ASCII messages separated by CR and/or LF, \x22Frame:[timeout]ms\x22 for binary messages separated by a delay time, \x22Char\x22 for a continuous ASCII stream or \x22Byte\x22 for a continuous binary stream. The suffix \x22/[wait]ms\x22 can be added to reduce the transmit rate so that there is always at lest the specified number of milliseconds between each bytes sent.</p>',par:{newval:'a string corresponding to the type of protocol used over the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_shitftSampling']={syn:'Changes the SDI line sampling shift.',lib:'spiport&rarr;set_shitftSampling()',pro:'int set_shitftSampling(Y_SHITFTSAMPLING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the SDI line sampling shift. When disabled, SDI line is sampled in the middle of data output time. When enabled, SDI line is samples at the end of data output time.</p>',par:{newval:'either <tt>Y_SHITFTSAMPLING_OFF</tt> or <tt>Y_SHITFTSAMPLING_ON</tt>, according to the SDI line sampling shift'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_spiMode']={syn:'Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22.',lib:'spiport&rarr;set_spiMode()',pro:'int set_spiMode(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the SPI port communication parameters, with a string such as \x22125000,0,msb\x22. The string includes the baud rate, the SPI mode (between 0 and 3) and the bit order.</p>',par:{newval:'a string corresponding to the SPI port communication parameters, with a string such as \x22125000,0,msb\x22'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_ssPolarity']={syn:'Changes the SS line polarity.',lib:'spiport&rarr;set_ssPolarity()',pro:'int set_ssPolarity(Y_SSPOLARITY_enum <span id=pn>newval</span>)',cmt:'<p>Changes the SS line polarity.</p>',par:{newval:'either <tt>Y_SSPOLARITY_ACTIVE_LOW</tt> or <tt>Y_SSPOLARITY_ACTIVE_HIGH</tt>, according to the SS line polarity'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_startupJob']={syn:'Changes the job to use when the device is powered on.',lib:'spiport&rarr;set_startupJob()',pro:'int set_startupJob(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the job to use when the device is powered on. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the job to use when the device is powered on'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'spiport&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['SpiPort']['set_voltageLevel']={syn:'Changes the voltage type used on the serial line.',lib:'spiport&rarr;set_voltageLevel()',pro:'int set_voltageLevel(Y_VOLTAGELEVEL_enum <span id=pn>newval</span>)',cmt:'<p>Changes the voltage type used on the serial line. Valid values will depend on the Yoctopuce device model featuring the serial port feature. Check your device documentation to find out which values are valid for that specific model. \x09 Trying to set an invalid value will have no effect.</p>',par:{newval:'a value among <tt>Y_VOLTAGELEVEL_OFF</tt>, <tt>Y_VOLTAGELEVEL_TTL3V</tt>, <tt>Y_VOLTAGELEVEL_TTL3VR</tt>, <tt>Y_VOLTAGELEVEL_TTL5V</tt>, <tt>Y_VOLTAGELEVEL_TTL5VR</tt>, <tt>Y_VOLTAGELEVEL_RS232</tt> and <tt>Y_VOLTAGELEVEL_RS485</tt> corresponding to the voltage type used on the serial line'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'spiport&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['uploadJob']={syn:'Saves the job definition string (JSON data) into a job file.',lib:'spiport&rarr;uploadJob()',pro:'int uploadJob(string <span id=pn>jobfile</span>, string <span id=pn>jsonDef</span>)',cmt:'<p>Saves the job definition string (JSON data) into a job file. The job file can be later enabled using <tt>selectJob()</tt>.</p>',par:{jobfile:'name of the job file to save on the device filesystem',jsonDef:'a string containing a JSON definition of the job'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeArray']={syn:'Sends a byte sequence (provided as a list of bytes) to the serial port.',lib:'spiport&rarr;writeArray()',pro:'int writeArray(vector&lt;int&gt; <span id=pn>byteList</span>)',cmt:'<p>Sends a byte sequence (provided as a list of bytes) to the serial port.</p>',par:{byteList:'a list of byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeBin']={syn:'Sends a binary buffer to the serial port, as is.',lib:'spiport&rarr;writeBin()',pro:'int writeBin(string <span id=pn>buff</span>)',cmt:'<p>Sends a binary buffer to the serial port, as is.</p>',par:{buff:'the binary buffer to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeByte']={syn:'Sends a single byte to the serial port.',lib:'spiport&rarr;writeByte()',pro:'int writeByte(int <span id=pn>code</span>)',cmt:'<p>Sends a single byte to the serial port.</p>',par:{code:'the byte to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeHex']={syn:'Sends a byte sequence (provided as a hexadecimal string) to the serial port.',lib:'spiport&rarr;writeHex()',pro:'int writeHex(string <span id=pn>hexString</span>)',cmt:'<p>Sends a byte sequence (provided as a hexadecimal string) to the serial port.</p>',par:{hexString:'a string of hexadecimal byte codes'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeLine']={syn:'Sends an ASCII string to the serial port, followed by a line break (CR LF).',lib:'spiport&rarr;writeLine()',pro:'int writeLine(string <span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, followed by a line break (CR LF).</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['SpiPort']['writeStr']={syn:'Sends an ASCII string to the serial port, as is.',lib:'spiport&rarr;writeStr()',pro:'int writeStr(string <span id=pn>text</span>)',cmt:'<p>Sends an ASCII string to the serial port, as is.</p>',par:{text:'the text string to send'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: SpiPort)
//--- (generated code: MessageBox)
doc['MessageBox']={'':{syn:'MessageBox function interface',inc:'#include &quot;yocto_messagebox.h&quot;',cmt:'<p>YMessageBox functions provides SMS sending and receiving capability to GSM-enabled Yoctopuce devices.</p>'}};
doc['MessageBox']['FindMessageBox']={syn:'Retrieves a MessageBox interface for a given identifier.',lib:'YMessageBox::FindMessageBox()',pro:'YMessageBox* FindMessageBox(string <span id=pn>func</span>)',cmt:'<p>Retrieves a MessageBox interface for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the MessageBox interface is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMessageBox.isOnline()</tt> to test if the MessageBox interface is indeed online at a given time. In case of ambiguity when looking for a MessageBox interface by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the MessageBox interface'},ret:'a <tt>YMessageBox</tt> object allowing you to drive the MessageBox interface.'};
doc['MessageBox']['FirstMessageBox']={syn:'Starts the enumeration of MessageBox interfaces currently accessible.',lib:'YMessageBox::FirstMessageBox()',pro:'YMessageBox* FirstMessageBox()',cmt:'<p>Starts the enumeration of MessageBox interfaces currently accessible. Use the method <tt>YMessageBox.nextMessageBox()</tt> to iterate on next MessageBox interfaces.</p>',ret:'a pointer to a <tt>YMessageBox</tt> object, corresponding to the first MessageBox interface currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MessageBox']['clearCache']={syn:'Invalidates the cache.',lib:'messagebox&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the MessageBox interface attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MessageBox']['clearPduCounters']={syn:'Clear the SMS units counters.',lib:'messagebox&rarr;clearPduCounters()',pro:'int clearPduCounters()',cmt:'<p>Clear the SMS units counters.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['describe']={syn:'Returns a short text that describes unambiguously the instance of the MessageBox interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'messagebox&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the MessageBox interface in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the MessageBox interface (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MessageBox']['get_advertisedValue']={syn:'Returns the current value of the MessageBox interface (no more than 6 characters).',lib:'messagebox&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the MessageBox interface (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the MessageBox interface (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MessageBox']['get_errorMessage']={syn:'Returns the error message of the latest error with the MessageBox interface.',lib:'messagebox&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the MessageBox interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the MessageBox interface object'};
doc['MessageBox']['get_errorType']={syn:'Returns the numerical error code of the latest error with the MessageBox interface.',lib:'messagebox&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the MessageBox interface. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the MessageBox interface object'};
doc['MessageBox']['get_friendlyName']={syn:'Returns a global identifier of the MessageBox interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'messagebox&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the MessageBox interface in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the MessageBox interface if they are defined, otherwise the serial number of the module and the hardware identifier of the MessageBox interface (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the MessageBox interface using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MessageBox']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'messagebox&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MessageBox']['get_functionId']={syn:'Returns the hardware identifier of the MessageBox interface, without reference to the module.',lib:'messagebox&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the MessageBox interface, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the MessageBox interface (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MessageBox']['get_hardwareId']={syn:'Returns the unique hardware identifier of the MessageBox interface in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'messagebox&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the MessageBox interface in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the MessageBox interface (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the MessageBox interface (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MessageBox']['get_logicalName']={syn:'Returns the logical name of the MessageBox interface.',lib:'messagebox&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the MessageBox interface.</p>',ret:'a string corresponding to the logical name of the MessageBox interface.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MessageBox']['get_messages']={syn:'Returns the list of messages received and not deleted.',lib:'messagebox&rarr;get_messages()',pro:'vector&lt;YSms&gt; get_messages()',cmt:'<p>Returns the list of messages received and not deleted. This function will automatically decode concatenated SMS.</p>',ret:'an YSms object list.',ext:'On failure, throws an exception or returns an empty list.'};
doc['MessageBox']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'messagebox&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MessageBox']['get_pduReceived']={syn:'Returns the number of SMS units received so far.',lib:'messagebox&rarr;get_pduReceived()',pro:'int get_pduReceived()',cmt:'<p>Returns the number of SMS units received so far.</p>',ret:'an integer corresponding to the number of SMS units received so far',ext:'On failure, throws an exception or returns <tt>Y_PDURECEIVED_INVALID</tt>.'};
doc['MessageBox']['get_pduSent']={syn:'Returns the number of SMS units sent so far.',lib:'messagebox&rarr;get_pduSent()',pro:'int get_pduSent()',cmt:'<p>Returns the number of SMS units sent so far.</p>',ret:'an integer corresponding to the number of SMS units sent so far',ext:'On failure, throws an exception or returns <tt>Y_PDUSENT_INVALID</tt>.'};
doc['MessageBox']['get_slotsCount']={syn:'Returns the total number of message storage slots on the SIM card.',lib:'messagebox&rarr;get_slotsCount()',pro:'int get_slotsCount()',cmt:'<p>Returns the total number of message storage slots on the SIM card.</p>',ret:'an integer corresponding to the total number of message storage slots on the SIM card',ext:'On failure, throws an exception or returns <tt>Y_SLOTSCOUNT_INVALID</tt>.'};
doc['MessageBox']['get_slotsInUse']={syn:'Returns the number of message storage slots currently in use.',lib:'messagebox&rarr;get_slotsInUse()',pro:'int get_slotsInUse()',cmt:'<p>Returns the number of message storage slots currently in use.</p>',ret:'an integer corresponding to the number of message storage slots currently in use',ext:'On failure, throws an exception or returns <tt>Y_SLOTSINUSE_INVALID</tt>.'};
doc['MessageBox']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'messagebox&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MessageBox']['isOnline']={syn:'Checks if the MessageBox interface is currently reachable, without raising any error.',lib:'messagebox&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the MessageBox interface is currently reachable, without raising any error. If there is a cached value for the MessageBox interface in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the MessageBox interface.</p>',ret:'<tt>true</tt> if the MessageBox interface can be reached, and <tt>false</tt> otherwise'};
doc['MessageBox']['load']={syn:'Preloads the MessageBox interface cache with a specified validity duration.',lib:'messagebox&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the MessageBox interface cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'messagebox&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MessageBox']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'messagebox&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['newMessage']={syn:'Creates a new empty SMS message, to be configured and sent later on.',lib:'messagebox&rarr;newMessage()',pro:'YSms newMessage(string <span id=pn>recipient</span>)',cmt:'<p>Creates a new empty SMS message, to be configured and sent later on.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['nextMessageBox']={syn:'Continues the enumeration of MessageBox interfaces started using <tt>yFirstMessageBox()</tt>.',lib:'messagebox&rarr;nextMessageBox()',pro:'YMessageBox * nextMessageBox()',cmt:'<p>Continues the enumeration of MessageBox interfaces started using <tt>yFirstMessageBox()</tt>.</p>',ret:'a pointer to a <tt>YMessageBox</tt> object, corresponding to a MessageBox interface currently online, or a <tt>null</tt> pointer if there are no more MessageBox interfaces to enumerate.'};
doc['MessageBox']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'messagebox&rarr;registerValueCallback()',pro:'int registerValueCallback(YMessageBoxValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MessageBox']['sendFlashMessage']={syn:'Sends a Flash SMS (class 0 message).',lib:'messagebox&rarr;sendFlashMessage()',pro:'int sendFlashMessage(string <span id=pn>recipient</span>, string <span id=pn>message</span>)',cmt:'<p>Sends a Flash SMS (class 0 message). Flash messages are displayed on the handset immediately and are usually not saved on the SIM card. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> et <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['sendTextMessage']={syn:'Sends a regular text SMS, with standard parameters.',lib:'messagebox&rarr;sendTextMessage()',pro:'int sendTextMessage(string <span id=pn>recipient</span>, string <span id=pn>message</span>)',cmt:'<p>Sends a regular text SMS, with standard parameters. This function can send messages of more than 160 characters, using SMS concatenation. ISO-latin accented characters are supported. For sending messages with special unicode characters such as asian characters and emoticons, use <tt>newMessage</tt> to create a new message and define the content of using methods <tt>addText</tt> and <tt>addUnicodeData</tt>.</p>',par:{recipient:'a text string with the recipient phone number, either as a national number, or in international format starting with a plus sign',message:'the text to be sent in the message'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_logicalName']={syn:'Changes the logical name of the MessageBox interface.',lib:'messagebox&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the MessageBox interface. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the MessageBox interface.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_pduReceived']={syn:'Changes the value of the incoming SMS units counter.',lib:'messagebox&rarr;set_pduReceived()',pro:'int set_pduReceived(int <span id=pn>newval</span>)',cmt:'<p>Changes the value of the incoming SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the incoming SMS units counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_pduSent']={syn:'Changes the value of the outgoing SMS units counter.',lib:'messagebox&rarr;set_pduSent()',pro:'int set_pduSent(int <span id=pn>newval</span>)',cmt:'<p>Changes the value of the outgoing SMS units counter.</p>',par:{newval:'an integer corresponding to the value of the outgoing SMS units counter'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MessageBox']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'messagebox&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MessageBox']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'messagebox&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MessageBox)
//--- (generated code: StepperMotor)
doc['StepperMotor']={'':{syn:'StepperMotor function interface',inc:'#include &quot;yocto_steppermotor.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['StepperMotor']['FindStepperMotor']={syn:'Retrieves a stepper motor for a given identifier.',lib:'YStepperMotor::FindStepperMotor()',pro:'YStepperMotor* FindStepperMotor(string <span id=pn>func</span>)',cmt:'<p>Retrieves a stepper motor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the stepper motor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YStepperMotor.isOnline()</tt> to test if the stepper motor is indeed online at a given time. In case of ambiguity when looking for a stepper motor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the stepper motor'},ret:'a <tt>YStepperMotor</tt> object allowing you to drive the stepper motor.'};
doc['StepperMotor']['FirstStepperMotor']={syn:'Starts the enumeration of stepper motors currently accessible.',lib:'YStepperMotor::FirstStepperMotor()',pro:'YStepperMotor* FirstStepperMotor()',cmt:'<p>Starts the enumeration of stepper motors currently accessible. Use the method <tt>YStepperMotor.nextStepperMotor()</tt> to iterate on next stepper motors.</p>',ret:'a pointer to a <tt>YStepperMotor</tt> object, corresponding to the first stepper motor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['StepperMotor']['abortAndBrake']={syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'steppermotor&rarr;abortAndBrake()',pro:'int abortAndBrake()',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['abortAndHiZ']={syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'steppermotor&rarr;abortAndHiZ()',pro:'int abortAndHiZ()',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['alertStepDir']={syn:'Move one single step in the selected direction without regards to end switches.',lib:'steppermotor&rarr;alertStepDir()',pro:'int alertStepDir(int <span id=pn>dir</span>)',cmt:'<p>Move one single step in the selected direction without regards to end switches. The move occures even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',par:{dir:'Value +1 ou -1, according to the desired direction of the move'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['alertStepOut']={syn:'Move one step in the direction opposite the direction set when the most recent alert was raised.',lib:'steppermotor&rarr;alertStepOut()',pro:'int alertStepOut()',cmt:'<p>Move one step in the direction opposite the direction set when the most recent alert was raised. The move occures even if the system is still in alert mode (end switch depressed). Caution. use this function with great care as it may cause mechanical damages !</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['changeSpeed']={syn:'Starts the motor at a given speed.',lib:'steppermotor&rarr;changeSpeed()',pro:'int changeSpeed(double <span id=pn>speed</span>)',cmt:'<p>Starts the motor at a given speed. The time needed to reach the requested speed will depend on the acceleration parameters configured for the motor.</p>',par:{speed:'desired speed, in steps per second. The minimal non-zero speed is 0.001 pulse per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['clearCache']={syn:'Invalidates the cache.',lib:'steppermotor&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the stepper motor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['StepperMotor']['describe']={syn:'Returns a short text that describes unambiguously the instance of the stepper motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'steppermotor&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the stepper motor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the stepper motor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['StepperMotor']['emergencyStop']={syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'steppermotor&rarr;emergencyStop()',pro:'int emergencyStop()',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['findHomePosition']={syn:'Starts the motor backward at the specified speed, to search for the motor home position.',lib:'steppermotor&rarr;findHomePosition()',pro:'int findHomePosition(double <span id=pn>speed</span>)',cmt:'<p>Starts the motor backward at the specified speed, to search for the motor home position.</p>',par:{speed:'desired speed, in steps per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['get_advertisedValue']={syn:'Returns the current value of the stepper motor (no more than 6 characters).',lib:'steppermotor&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the stepper motor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the stepper motor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['StepperMotor']['get_auxSignal']={syn:'Returns the current value of the signal generated on the auxiliary output.',lib:'steppermotor&rarr;get_auxSignal()',pro:'int get_auxSignal()',cmt:'<p>Returns the current value of the signal generated on the auxiliary output.</p>',ret:'an integer corresponding to the current value of the signal generated on the auxiliary output',ext:'On failure, throws an exception or returns <tt>Y_AUXSIGNAL_INVALID</tt>.'};
doc['StepperMotor']['get_diags']={syn:'Returns the stepper motor controller diagnostics, as a bitmap.',lib:'steppermotor&rarr;get_diags()',pro:'int get_diags()',cmt:'<p>Returns the stepper motor controller diagnostics, as a bitmap.</p>',ret:'an integer corresponding to the stepper motor controller diagnostics, as a bitmap',ext:'On failure, throws an exception or returns <tt>Y_DIAGS_INVALID</tt>.'};
doc['StepperMotor']['get_errorMessage']={syn:'Returns the error message of the latest error with the stepper motor.',lib:'steppermotor&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the stepper motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the stepper motor object'};
doc['StepperMotor']['get_errorType']={syn:'Returns the numerical error code of the latest error with the stepper motor.',lib:'steppermotor&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the stepper motor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the stepper motor object'};
doc['StepperMotor']['get_friendlyName']={syn:'Returns a global identifier of the stepper motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'steppermotor&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the stepper motor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the stepper motor if they are defined, otherwise the serial number of the module and the hardware identifier of the stepper motor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the stepper motor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['StepperMotor']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'steppermotor&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['StepperMotor']['get_functionId']={syn:'Returns the hardware identifier of the stepper motor, without reference to the module.',lib:'steppermotor&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the stepper motor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the stepper motor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['StepperMotor']['get_hardwareId']={syn:'Returns the unique hardware identifier of the stepper motor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'steppermotor&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the stepper motor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the stepper motor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the stepper motor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['StepperMotor']['get_logicalName']={syn:'Returns the logical name of the stepper motor.',lib:'steppermotor&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the stepper motor.</p>',ret:'a string corresponding to the logical name of the stepper motor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['StepperMotor']['get_maxAccel']={syn:'Returns the maximal motor acceleration, measured in steps per second^2.',lib:'steppermotor&rarr;get_maxAccel()',pro:'double get_maxAccel()',cmt:'<p>Returns the maximal motor acceleration, measured in steps per second^2.</p>',ret:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2',ext:'On failure, throws an exception or returns <tt>Y_MAXACCEL_INVALID</tt>.'};
doc['StepperMotor']['get_maxSpeed']={syn:'Returns the maximal motor speed, measured in steps per second.',lib:'steppermotor&rarr;get_maxSpeed()',pro:'double get_maxSpeed()',cmt:'<p>Returns the maximal motor speed, measured in steps per second.</p>',ret:'a floating point number corresponding to the maximal motor speed, measured in steps per second',ext:'On failure, throws an exception or returns <tt>Y_MAXSPEED_INVALID</tt>.'};
doc['StepperMotor']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'steppermotor&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['StepperMotor']['get_motorState']={syn:'Returns the motor working state.',lib:'steppermotor&rarr;get_motorState()',pro:'Y_MOTORSTATE_enum get_motorState()',cmt:'<p>Returns the motor working state.</p>',ret:'a value among <tt>Y_MOTORSTATE_ABSENT</tt>, <tt>Y_MOTORSTATE_ALERT</tt>, <tt>Y_MOTORSTATE_HI_Z</tt>, <tt>Y_MOTORSTATE_STOP</tt>, <tt>Y_MOTORSTATE_RUN</tt> and <tt>Y_MOTORSTATE_BATCH</tt> corresponding to the motor working state',ext:'On failure, throws an exception or returns <tt>Y_MOTORSTATE_INVALID</tt>.'};
doc['StepperMotor']['get_overcurrent']={syn:'Returns the overcurrent alert and emergency stop threshold, measured in mA.',lib:'steppermotor&rarr;get_overcurrent()',pro:'int get_overcurrent()',cmt:'<p>Returns the overcurrent alert and emergency stop threshold, measured in mA.</p>',ret:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA',ext:'On failure, throws an exception or returns <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['StepperMotor']['get_pullinSpeed']={syn:'Returns the motor speed immediately reachable from stop state, measured in steps per second.',lib:'steppermotor&rarr;get_pullinSpeed()',pro:'double get_pullinSpeed()',cmt:'<p>Returns the motor speed immediately reachable from stop state, measured in steps per second.</p>',ret:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second',ext:'On failure, throws an exception or returns <tt>Y_PULLINSPEED_INVALID</tt>.'};
doc['StepperMotor']['get_speed']={syn:'Returns current motor speed, measured in steps per second.',lib:'steppermotor&rarr;get_speed()',pro:'double get_speed()',cmt:'<p>Returns current motor speed, measured in steps per second. To change speed, use method <tt>changeSpeed()</tt>.</p>',ret:'a floating point number corresponding to current motor speed, measured in steps per second',ext:'On failure, throws an exception or returns <tt>Y_SPEED_INVALID</tt>.'};
doc['StepperMotor']['get_stepPos']={syn:'Returns the current logical motor position, measured in steps.',lib:'steppermotor&rarr;get_stepPos()',pro:'double get_stepPos()',cmt:'<p>Returns the current logical motor position, measured in steps. The value may include a fractional part when micro-stepping is in use.</p>',ret:'a floating point number corresponding to the current logical motor position, measured in steps',ext:'On failure, throws an exception or returns <tt>Y_STEPPOS_INVALID</tt>.'};
doc['StepperMotor']['get_stepping']={syn:'Returns the stepping mode used to drive the motor.',lib:'steppermotor&rarr;get_stepping()',pro:'Y_STEPPING_enum get_stepping()',cmt:'<p>Returns the stepping mode used to drive the motor.</p>',ret:'a value among <tt>Y_STEPPING_MICROSTEP16</tt>, <tt>Y_STEPPING_MICROSTEP8</tt>, <tt>Y_STEPPING_MICROSTEP4</tt>, <tt>Y_STEPPING_HALFSTEP</tt> and <tt>Y_STEPPING_FULLSTEP</tt> corresponding to the stepping mode used to drive the motor',ext:'On failure, throws an exception or returns <tt>Y_STEPPING_INVALID</tt>.'};
doc['StepperMotor']['get_tCurrRun']={syn:'Returns the torque regulation current when the motor is running, measured in mA.',lib:'steppermotor&rarr;get_tCurrRun()',pro:'int get_tCurrRun()',cmt:'<p>Returns the torque regulation current when the motor is running, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is running, measured in mA',ext:'On failure, throws an exception or returns <tt>Y_TCURRRUN_INVALID</tt>.'};
doc['StepperMotor']['get_tCurrStop']={syn:'Returns the torque regulation current when the motor is stopped, measured in mA.',lib:'steppermotor&rarr;get_tCurrStop()',pro:'int get_tCurrStop()',cmt:'<p>Returns the torque regulation current when the motor is stopped, measured in mA.</p>',ret:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA',ext:'On failure, throws an exception or returns <tt>Y_TCURRSTOP_INVALID</tt>.'};
doc['StepperMotor']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'steppermotor&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['StepperMotor']['isOnline']={syn:'Checks if the stepper motor is currently reachable, without raising any error.',lib:'steppermotor&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the stepper motor is currently reachable, without raising any error. If there is a cached value for the stepper motor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the stepper motor.</p>',ret:'<tt>true</tt> if the stepper motor can be reached, and <tt>false</tt> otherwise'};
doc['StepperMotor']['load']={syn:'Preloads the stepper motor cache with a specified validity duration.',lib:'steppermotor&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the stepper motor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'steppermotor&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['StepperMotor']['moveRel']={syn:'Starts the motor to reach a given relative position.',lib:'steppermotor&rarr;moveRel()',pro:'int moveRel(double <span id=pn>relPos</span>)',cmt:'<p>Starts the motor to reach a given relative position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['moveRelSlow']={syn:'Starts the motor to reach a given relative position, keeping the speed under the specified limit.',lib:'steppermotor&rarr;moveRelSlow()',pro:'int moveRelSlow(double <span id=pn>relPos</span>, double <span id=pn>maxSpeed</span>)',cmt:'<p>Starts the motor to reach a given relative position, keeping the speed under the specified limit. The time needed to reach the requested position will depend on the acceleration parameters configured for the motor.</p>',par:{relPos:'relative position, measured in steps from the current position.',maxSpeed:'limit speed, in steps per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['moveTo']={syn:'Starts the motor to reach a given absolute position.',lib:'steppermotor&rarr;moveTo()',pro:'int moveTo(double <span id=pn>absPos</span>)',cmt:'<p>Starts the motor to reach a given absolute position. The time needed to reach the requested position will depend on the acceleration and max speed parameters configured for the motor.</p>',par:{absPos:'absolute position, measured in steps from the origin.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'steppermotor&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['nextStepperMotor']={syn:'Continues the enumeration of stepper motors started using <tt>yFirstStepperMotor()</tt>.',lib:'steppermotor&rarr;nextStepperMotor()',pro:'YStepperMotor * nextStepperMotor()',cmt:'<p>Continues the enumeration of stepper motors started using <tt>yFirstStepperMotor()</tt>.</p>',ret:'a pointer to a <tt>YStepperMotor</tt> object, corresponding to a stepper motor currently online, or a <tt>null</tt> pointer if there are no more stepper motors to enumerate.'};
doc['StepperMotor']['pause']={syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'steppermotor&rarr;pause()',pro:'int pause(int <span id=pn>waitMs</span>)',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'steppermotor&rarr;registerValueCallback()',pro:'int registerValueCallback(YStepperMotorValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['StepperMotor']['reset']={syn:'Reinitialize the controller and clear all alert flags.',lib:'steppermotor&rarr;reset()',pro:'int reset()',cmt:'<p>Reinitialize the controller and clear all alert flags.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_auxSignal']={syn:'Changes the value of the signal generated on the auxiliary output.',lib:'steppermotor&rarr;set_auxSignal()',pro:'int set_auxSignal(int <span id=pn>newval</span>)',cmt:'<p>Changes the value of the signal generated on the auxiliary output. Acceptable values depend on the auxiliary output signal type configured.</p>',par:{newval:'an integer corresponding to the value of the signal generated on the auxiliary output'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_logicalName']={syn:'Changes the logical name of the stepper motor.',lib:'steppermotor&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the stepper motor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the stepper motor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_maxAccel']={syn:'Changes the maximal motor acceleration, measured in steps per second^2.',lib:'steppermotor&rarr;set_maxAccel()',pro:'int set_maxAccel(double <span id=pn>newval</span>)',cmt:'<p>Changes the maximal motor acceleration, measured in steps per second^2.</p>',par:{newval:'a floating point number corresponding to the maximal motor acceleration, measured in steps per second^2'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_maxSpeed']={syn:'Changes the maximal motor speed, measured in steps per second.',lib:'steppermotor&rarr;set_maxSpeed()',pro:'int set_maxSpeed(double <span id=pn>newval</span>)',cmt:'<p>Changes the maximal motor speed, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the maximal motor speed, measured in steps per second'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_overcurrent']={syn:'Changes the overcurrent alert and emergency stop threshold, measured in mA.',lib:'steppermotor&rarr;set_overcurrent()',pro:'int set_overcurrent(int <span id=pn>newval</span>)',cmt:'<p>Changes the overcurrent alert and emergency stop threshold, measured in mA.</p>',par:{newval:'an integer corresponding to the overcurrent alert and emergency stop threshold, measured in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_pullinSpeed']={syn:'Changes the motor speed immediately reachable from stop state, measured in steps per second.',lib:'steppermotor&rarr;set_pullinSpeed()',pro:'int set_pullinSpeed(double <span id=pn>newval</span>)',cmt:'<p>Changes the motor speed immediately reachable from stop state, measured in steps per second.</p>',par:{newval:'a floating point number corresponding to the motor speed immediately reachable from stop state, measured in steps per second'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_stepPos']={syn:'Changes the current logical motor position, measured in steps.',lib:'steppermotor&rarr;set_stepPos()',pro:'int set_stepPos(double <span id=pn>newval</span>)',cmt:'<p>Changes the current logical motor position, measured in steps. This command does not cause any motor move, as its purpose is only to setup the origin of the position counter. The fractional part of the position, that corresponds to the physical position of the rotor, is not changed. To trigger a motor move, use methods <tt>moveTo()</tt> or <tt>moveRel()</tt> instead.</p>',par:{newval:'a floating point number corresponding to the current logical motor position, measured in steps'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_stepping']={syn:'Changes the stepping mode used to drive the motor.',lib:'steppermotor&rarr;set_stepping()',pro:'int set_stepping(Y_STEPPING_enum <span id=pn>newval</span>)',cmt:'<p>Changes the stepping mode used to drive the motor.</p>',par:{newval:'a value among <tt>Y_STEPPING_MICROSTEP16</tt>, <tt>Y_STEPPING_MICROSTEP8</tt>, <tt>Y_STEPPING_MICROSTEP4</tt>, <tt>Y_STEPPING_HALFSTEP</tt> and <tt>Y_STEPPING_FULLSTEP</tt> corresponding to the stepping mode used to drive the motor'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_tCurrRun']={syn:'Changes the torque regulation current when the motor is running, measured in mA.',lib:'steppermotor&rarr;set_tCurrRun()',pro:'int set_tCurrRun(int <span id=pn>newval</span>)',cmt:'<p>Changes the torque regulation current when the motor is running, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is running, measured in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_tCurrStop']={syn:'Changes the torque regulation current when the motor is stopped, measured in mA.',lib:'steppermotor&rarr;set_tCurrStop()',pro:'int set_tCurrStop(int <span id=pn>newval</span>)',cmt:'<p>Changes the torque regulation current when the motor is stopped, measured in mA.</p>',par:{newval:'an integer corresponding to the torque regulation current when the motor is stopped, measured in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['StepperMotor']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'steppermotor&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['StepperMotor']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'steppermotor&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: StepperMotor)
//--- (generated code: Proximity)
doc['Proximity']={'':{syn:'Proximity function interface',inc:'#include &quot;yocto_proximity.h&quot;',cmt:'<p>The Yoctopuce class YProximity allows you to use and configure Yoctopuce proximity sensors. It inherits from the YSensor class the core functions to read measurements, to register callback functions, to access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}};
doc['Proximity']['FindProximity']={syn:'Retrieves a proximity sensor for a given identifier.',lib:'YProximity::FindProximity()',pro:'YProximity* FindProximity(string <span id=pn>func</span>)',cmt:'<p>Retrieves a proximity sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the proximity sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YProximity.isOnline()</tt> to test if the proximity sensor is indeed online at a given time. In case of ambiguity when looking for a proximity sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the proximity sensor'},ret:'a <tt>YProximity</tt> object allowing you to drive the proximity sensor.'};
doc['Proximity']['FirstProximity']={syn:'Starts the enumeration of proximity sensors currently accessible.',lib:'YProximity::FirstProximity()',pro:'YProximity* FirstProximity()',cmt:'<p>Starts the enumeration of proximity sensors currently accessible. Use the method <tt>YProximity.nextProximity()</tt> to iterate on next proximity sensors.</p>',ret:'a pointer to a <tt>YProximity</tt> object, corresponding to the first proximity sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['Proximity']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'proximity&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['clearCache']={syn:'Invalidates the cache.',lib:'proximity&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the proximity sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['Proximity']['describe']={syn:'Returns a short text that describes unambiguously the instance of the proximity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'proximity&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the proximity sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the proximity sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Proximity']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'proximity&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['Proximity']['get_advertisedValue']={syn:'Returns the current value of the proximity sensor (no more than 6 characters).',lib:'proximity&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the proximity sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the proximity sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Proximity']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'proximity&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Proximity']['get_currentValue']={syn:'Returns the current value of the proximity detection, in the specified unit, as a floating point number.',lib:'proximity&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the proximity detection, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the proximity detection, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Proximity']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'proximity&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['Proximity']['get_detectionHysteresis']={syn:'Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity&rarr;get_detectionHysteresis()',pro:'int get_detectionHysteresis()',cmt:'<p>Returns the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:'On failure, throws an exception or returns <tt>Y_DETECTIONHYSTERESIS_INVALID</tt>.'};
doc['Proximity']['get_detectionThreshold']={syn:'Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity&rarr;get_detectionThreshold()',pro:'int get_detectionThreshold()',cmt:'<p>Returns the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',ret:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)',ext:'On failure, throws an exception or returns <tt>Y_DETECTIONTHRESHOLD_INVALID</tt>.'};
doc['Proximity']['get_errorMessage']={syn:'Returns the error message of the latest error with the proximity sensor.',lib:'proximity&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the proximity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the proximity sensor object'};
doc['Proximity']['get_errorType']={syn:'Returns the numerical error code of the latest error with the proximity sensor.',lib:'proximity&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the proximity sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the proximity sensor object'};
doc['Proximity']['get_friendlyName']={syn:'Returns a global identifier of the proximity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'proximity&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the proximity sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the proximity sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the proximity sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the proximity sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Proximity']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'proximity&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['Proximity']['get_functionId']={syn:'Returns the hardware identifier of the proximity sensor, without reference to the module.',lib:'proximity&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the proximity sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the proximity sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Proximity']['get_hardwareId']={syn:'Returns the unique hardware identifier of the proximity sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'proximity&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the proximity sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the proximity sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the proximity sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Proximity']['get_highestValue']={syn:'Returns the maximal value observed for the proximity detection since the device was started.',lib:'proximity&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the proximity detection since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Proximity']['get_isPresent']={syn:'Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.',lib:'proximity&rarr;get_isPresent()',pro:'Y_ISPRESENT_enum get_isPresent()',cmt:'<p>Returns true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise.</p>',ret:'either <tt>Y_ISPRESENT_FALSE</tt> or <tt>Y_ISPRESENT_TRUE</tt>, according to true if the input (considered as binary) is active (detection value is smaller than the specified <tt>threshold</tt>), and false otherwise',ext:'On failure, throws an exception or returns <tt>Y_ISPRESENT_INVALID</tt>.'};
doc['Proximity']['get_lastTimeApproached']={syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).',lib:'proximity&rarr;get_lastTimeApproached()',pro:'s64 get_lastTimeApproached()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from absent to present)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEAPPROACHED_INVALID</tt>.'};
doc['Proximity']['get_lastTimeRemoved']={syn:'Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).',lib:'proximity&rarr;get_lastTimeRemoved()',pro:'s64 get_lastTimeRemoved()',cmt:'<p>Returns the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent).</p>',ret:'an integer corresponding to the number of elapsed milliseconds between the module power on and the last observed detection (the input contact transitioned from present to absent)',ext:'On failure, throws an exception or returns <tt>Y_LASTTIMEREMOVED_INVALID</tt>.'};
doc['Proximity']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'proximity&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['Proximity']['get_logicalName']={syn:'Returns the logical name of the proximity sensor.',lib:'proximity&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the proximity sensor.</p>',ret:'a string corresponding to the logical name of the proximity sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Proximity']['get_lowestValue']={syn:'Returns the minimal value observed for the proximity detection since the device was started.',lib:'proximity&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the proximity detection since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the proximity detection since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Proximity']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'proximity&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['Proximity']['get_presenceMinTime']={syn:'Returns the minimal detection duration before signaling a presence event.',lib:'proximity&rarr;get_presenceMinTime()',pro:'int get_presenceMinTime()',cmt:'<p>Returns the minimal detection duration before signaling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signaling a presence event',ext:'On failure, throws an exception or returns <tt>Y_PRESENCEMINTIME_INVALID</tt>.'};
doc['Proximity']['get_proximityReportMode']={syn:'Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'proximity&rarr;get_proximityReportMode()',pro:'Y_PROXIMITYREPORTMODE_enum get_proximityReportMode()',cmt:'<p>Returns the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.</p>',ret:'a value among <tt>Y_PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>Y_PROXIMITYREPORTMODE_PRESENCE</tt> and <tt>Y_PROXIMITYREPORTMODE_PULSECOUNT</tt> corresponding to the parameter (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks',ext:'On failure, throws an exception or returns <tt>Y_PROXIMITYREPORTMODE_INVALID</tt>.'};
doc['Proximity']['get_pulseCounter']={syn:'Returns the pulse counter value.',lib:'proximity&rarr;get_pulseCounter()',pro:'s64 get_pulseCounter()',cmt:'<p>Returns the pulse counter value. The value is a 32 bit integer. In case of overflow (>=2^32), the counter will wrap. To reset the counter, just \x09 call the resetCounter() method.</p>',ret:'an integer corresponding to the pulse counter value',ext:'On failure, throws an exception or returns <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['Proximity']['get_pulseTimer']={syn:'Returns the timer of the pulse counter (ms).',lib:'proximity&rarr;get_pulseTimer()',pro:'s64 get_pulseTimer()',cmt:'<p>Returns the timer of the pulse counter (ms).</p>',ret:'an integer corresponding to the timer of the pulse counter (ms)',ext:'On failure, throws an exception or returns <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Proximity']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'proximity&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['Proximity']['get_removalMinTime']={syn:'Returns the minimal detection duration before signaling a removal event.',lib:'proximity&rarr;get_removalMinTime()',pro:'int get_removalMinTime()',cmt:'<p>Returns the minimal detection duration before signaling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',ret:'an integer corresponding to the minimal detection duration before signaling a removal event',ext:'On failure, throws an exception or returns <tt>Y_REMOVALMINTIME_INVALID</tt>.'};
doc['Proximity']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'proximity&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['Proximity']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'proximity&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Proximity']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'proximity&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['Proximity']['get_signalValue']={syn:'Returns the current value of signal measured by the proximity sensor.',lib:'proximity&rarr;get_signalValue()',pro:'double get_signalValue()',cmt:'<p>Returns the current value of signal measured by the proximity sensor.</p>',ret:'a floating point number corresponding to the current value of signal measured by the proximity sensor',ext:'On failure, throws an exception or returns <tt>Y_SIGNALVALUE_INVALID</tt>.'};
doc['Proximity']['get_unit']={syn:'Returns the measuring unit for the proximity detection.',lib:'proximity&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the proximity detection.</p>',ret:'a string corresponding to the measuring unit for the proximity detection',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['Proximity']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'proximity&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['Proximity']['isOnline']={syn:'Checks if the proximity sensor is currently reachable, without raising any error.',lib:'proximity&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the proximity sensor is currently reachable, without raising any error. If there is a cached value for the proximity sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the proximity sensor.</p>',ret:'<tt>true</tt> if the proximity sensor can be reached, and <tt>false</tt> otherwise'};
doc['Proximity']['load']={syn:'Preloads the proximity sensor cache with a specified validity duration.',lib:'proximity&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the proximity sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'proximity&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['Proximity']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'proximity&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'proximity&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['nextProximity']={syn:'Continues the enumeration of proximity sensors started using <tt>yFirstProximity()</tt>.',lib:'proximity&rarr;nextProximity()',pro:'YProximity * nextProximity()',cmt:'<p>Continues the enumeration of proximity sensors started using <tt>yFirstProximity()</tt>.</p>',ret:'a pointer to a <tt>YProximity</tt> object, corresponding to a proximity sensor currently online, or a <tt>null</tt> pointer if there are no more proximity sensors to enumerate.'};
doc['Proximity']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'proximity&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YProximityTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['Proximity']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'proximity&rarr;registerValueCallback()',pro:'int registerValueCallback(YProximityValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['Proximity']['resetCounter']={syn:'Resets the pulse counter value as well as its timer.',lib:'proximity&rarr;resetCounter()',pro:'int resetCounter()',cmt:'<p>Resets the pulse counter value as well as its timer.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'proximity&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_detectionHysteresis']={syn:'Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity&rarr;set_detectionHysteresis()',pro:'int set_detectionHysteresis(int <span id=pn>newval</span>)',cmt:'<p>Changes the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',par:{newval:'an integer corresponding to the hysteresis used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_detectionThreshold']={syn:'Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).',lib:'proximity&rarr;set_detectionThreshold()',pro:'int set_detectionThreshold(int <span id=pn>newval</span>)',cmt:'<p>Changes the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off).</p>',par:{newval:'an integer corresponding to the threshold used to determine the logical state of the proximity sensor, when considered as a binary input (on/off)'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'proximity&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'proximity&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_logicalName']={syn:'Changes the logical name of the proximity sensor.',lib:'proximity&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the proximity sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the proximity sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'proximity&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_presenceMinTime']={syn:'Changes the minimal detection duration before signaling a presence event.',lib:'proximity&rarr;set_presenceMinTime()',pro:'int set_presenceMinTime(int <span id=pn>newval</span>)',cmt:'<p>Changes the minimal detection duration before signaling a presence event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signaling a presence event'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_proximityReportMode']={syn:'Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks.',lib:'proximity&rarr;set_proximityReportMode()',pro:'int set_proximityReportMode(Y_PROXIMITYREPORTMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks. The edge count value is limited to the 6 lowest digits. For values greater than one million, use get_pulseCounter().</p>',par:{newval:'a value among <tt>Y_PROXIMITYREPORTMODE_NUMERIC</tt>, <tt>Y_PROXIMITYREPORTMODE_PRESENCE</tt> and <tt>Y_PROXIMITYREPORTMODE_PULSECOUNT</tt> corresponding to the parameter type (sensor value, presence or pulse count) returned by the get_currentValue function and callbacks'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_removalMinTime']={syn:'Changes the minimal detection duration before signaling a removal event.',lib:'proximity&rarr;set_removalMinTime()',pro:'int set_removalMinTime(int <span id=pn>newval</span>)',cmt:'<p>Changes the minimal detection duration before signaling a removal event. Any shorter detection is considered as noise or bounce (false positive) and filtered out.</p>',par:{newval:'an integer corresponding to the minimal detection duration before signaling a removal event'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'proximity&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'proximity&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['Proximity']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'proximity&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['Proximity']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'proximity&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Proximity']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'proximity&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['Proximity']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'proximity&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: Proximity)
//--- (generated code: MultiAxisController)
doc['MultiAxisController']={'':{syn:'MultiAxisController function interface',inc:'#include &quot;yocto_multiaxiscontroller.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to drive a stepper motor.</p>'}};
doc['MultiAxisController']['FindMultiAxisController']={syn:'Retrieves a multi-axis controller for a given identifier.',lib:'YMultiAxisController::FindMultiAxisController()',pro:'YMultiAxisController* FindMultiAxisController(string <span id=pn>func</span>)',cmt:'<p>Retrieves a multi-axis controller for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-axis controller is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiAxisController.isOnline()</tt> to test if the multi-axis controller is indeed online at a given time. In case of ambiguity when looking for a multi-axis controller by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-axis controller'},ret:'a <tt>YMultiAxisController</tt> object allowing you to drive the multi-axis controller.'};
doc['MultiAxisController']['FirstMultiAxisController']={syn:'Starts the enumeration of multi-axis controllers currently accessible.',lib:'YMultiAxisController::FirstMultiAxisController()',pro:'YMultiAxisController* FirstMultiAxisController()',cmt:'<p>Starts the enumeration of multi-axis controllers currently accessible. Use the method <tt>YMultiAxisController.nextMultiAxisController()</tt> to iterate on next multi-axis controllers.</p>',ret:'a pointer to a <tt>YMultiAxisController</tt> object, corresponding to the first multi-axis controller currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MultiAxisController']['abortAndBrake']={syn:'Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.',lib:'multiaxiscontroller&rarr;abortAndBrake()',pro:'int abortAndBrake()',cmt:'<p>Stops the motor smoothly as soon as possible, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['abortAndHiZ']={syn:'Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.',lib:'multiaxiscontroller&rarr;abortAndHiZ()',pro:'int abortAndHiZ()',cmt:'<p>Turn the controller into Hi-Z mode immediately, without waiting for ongoing move completion.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['clearCache']={syn:'Invalidates the cache.',lib:'multiaxiscontroller&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-axis controller attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MultiAxisController']['describe']={syn:'Returns a short text that describes unambiguously the instance of the multi-axis controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multiaxiscontroller&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-axis controller in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-axis controller (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiAxisController']['emergencyStop']={syn:'Stops the motor with an emergency alert, without taking any additional precaution.',lib:'multiaxiscontroller&rarr;emergencyStop()',pro:'int emergencyStop()',cmt:'<p>Stops the motor with an emergency alert, without taking any additional precaution.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['findHomePosition']={syn:'Starts all motors backward at the specified speeds, to search for the motor home position.',lib:'multiaxiscontroller&rarr;findHomePosition()',pro:'int findHomePosition(vector&lt;double&gt; <span id=pn>speed</span>)',cmt:'<p>Starts all motors backward at the specified speeds, to search for the motor home position.</p>',par:{speed:'desired speed for all axis, in steps per second.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['get_advertisedValue']={syn:'Returns the current value of the multi-axis controller (no more than 6 characters).',lib:'multiaxiscontroller&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the multi-axis controller (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-axis controller (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiAxisController']['get_errorMessage']={syn:'Returns the error message of the latest error with the multi-axis controller.',lib:'multiaxiscontroller&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-axis controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-axis controller object'};
doc['MultiAxisController']['get_errorType']={syn:'Returns the numerical error code of the latest error with the multi-axis controller.',lib:'multiaxiscontroller&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-axis controller. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-axis controller object'};
doc['MultiAxisController']['get_friendlyName']={syn:'Returns a global identifier of the multi-axis controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'multiaxiscontroller&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-axis controller in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-axis controller if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-axis controller (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-axis controller using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiAxisController']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'multiaxiscontroller&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MultiAxisController']['get_functionId']={syn:'Returns the hardware identifier of the multi-axis controller, without reference to the module.',lib:'multiaxiscontroller&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-axis controller, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-axis controller (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiAxisController']['get_globalState']={syn:'Returns the stepper motor set overall state.',lib:'multiaxiscontroller&rarr;get_globalState()',pro:'Y_GLOBALSTATE_enum get_globalState()',cmt:'<p>Returns the stepper motor set overall state.</p>',ret:'a value among <tt>Y_GLOBALSTATE_ABSENT</tt>, <tt>Y_GLOBALSTATE_ALERT</tt>, <tt>Y_GLOBALSTATE_HI_Z</tt>, <tt>Y_GLOBALSTATE_STOP</tt>, <tt>Y_GLOBALSTATE_RUN</tt> and <tt>Y_GLOBALSTATE_BATCH</tt> corresponding to the stepper motor set overall state',ext:'On failure, throws an exception or returns <tt>Y_GLOBALSTATE_INVALID</tt>.'};
doc['MultiAxisController']['get_hardwareId']={syn:'Returns the unique hardware identifier of the multi-axis controller in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'multiaxiscontroller&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-axis controller in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-axis controller (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-axis controller (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiAxisController']['get_logicalName']={syn:'Returns the logical name of the multi-axis controller.',lib:'multiaxiscontroller&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the multi-axis controller.</p>',ret:'a string corresponding to the logical name of the multi-axis controller.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiAxisController']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'multiaxiscontroller&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MultiAxisController']['get_nAxis']={syn:'Returns the number of synchronized controllers.',lib:'multiaxiscontroller&rarr;get_nAxis()',pro:'int get_nAxis()',cmt:'<p>Returns the number of synchronized controllers.</p>',ret:'an integer corresponding to the number of synchronized controllers',ext:'On failure, throws an exception or returns <tt>Y_NAXIS_INVALID</tt>.'};
doc['MultiAxisController']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'multiaxiscontroller&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MultiAxisController']['isOnline']={syn:'Checks if the multi-axis controller is currently reachable, without raising any error.',lib:'multiaxiscontroller&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the multi-axis controller is currently reachable, without raising any error. If there is a cached value for the multi-axis controller in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-axis controller.</p>',ret:'<tt>true</tt> if the multi-axis controller can be reached, and <tt>false</tt> otherwise'};
doc['MultiAxisController']['load']={syn:'Preloads the multi-axis controller cache with a specified validity duration.',lib:'multiaxiscontroller&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-axis controller cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'multiaxiscontroller&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MultiAxisController']['moveRel']={syn:'Starts all motors synchronously to reach a given relative position.',lib:'multiaxiscontroller&rarr;moveRel()',pro:'int moveRel(vector&lt;double&gt; <span id=pn>relPos</span>)',cmt:'<p>Starts all motors synchronously to reach a given relative position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{relPos:'relative position, measured in steps from the current position.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['moveTo']={syn:'Starts all motors synchronously to reach a given absolute position.',lib:'multiaxiscontroller&rarr;moveTo()',pro:'int moveTo(vector&lt;double&gt; <span id=pn>absPos</span>)',cmt:'<p>Starts all motors synchronously to reach a given absolute position. The time needed to reach the requested position will depend on the lowest acceleration and max speed parameters configured for all motors. The final position will be reached on all axis at the same time.</p>',par:{absPos:'absolute position, measured in steps from each origin.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'multiaxiscontroller&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['nextMultiAxisController']={syn:'Continues the enumeration of multi-axis controllers started using <tt>yFirstMultiAxisController()</tt>.',lib:'multiaxiscontroller&rarr;nextMultiAxisController()',pro:'YMultiAxisController * nextMultiAxisController()',cmt:'<p>Continues the enumeration of multi-axis controllers started using <tt>yFirstMultiAxisController()</tt>.</p>',ret:'a pointer to a <tt>YMultiAxisController</tt> object, corresponding to a multi-axis controller currently online, or a <tt>null</tt> pointer if there are no more multi-axis controllers to enumerate.'};
doc['MultiAxisController']['pause']={syn:'Keep the motor in the same state for the specified amount of time, before processing next command.',lib:'multiaxiscontroller&rarr;pause()',pro:'int pause(int <span id=pn>waitMs</span>)',cmt:'<p>Keep the motor in the same state for the specified amount of time, before processing next command.</p>',par:{waitMs:'wait time, specified in milliseconds.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'multiaxiscontroller&rarr;registerValueCallback()',pro:'int registerValueCallback(YMultiAxisControllerValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MultiAxisController']['reset']={syn:'Reinitialize all controllers and clear all alert flags.',lib:'multiaxiscontroller&rarr;reset()',pro:'int reset()',cmt:'<p>Reinitialize all controllers and clear all alert flags.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_logicalName']={syn:'Changes the logical name of the multi-axis controller.',lib:'multiaxiscontroller&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-axis controller. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-axis controller.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_nAxis']={syn:'Changes the number of synchronized controllers.',lib:'multiaxiscontroller&rarr;set_nAxis()',pro:'int set_nAxis(int <span id=pn>newval</span>)',cmt:'<p>Changes the number of synchronized controllers.</p>',par:{newval:'an integer corresponding to the number of synchronized controllers'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiAxisController']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'multiaxiscontroller&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MultiAxisController']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'multiaxiscontroller&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MultiAxisController)
//--- (generated code: RangeFinder)
doc['RangeFinder']={'':{syn:'RangeFinder function interface',inc:'#include &quot;yocto_rangefinder.h&quot;',cmt:'<p>The Yoctopuce class YRangeFinder allows you to use and configure Yoctopuce range finder sensors. It inherits from the YSensor class the core functions to read measurements, register callback functions, access the autonomous datalogger. This class adds the ability to easily perform a one-point linear calibration to compensate the effect of a glass or filter placed in front of the sensor.</p>'}};
doc['RangeFinder']['FindRangeFinder']={syn:'Retrieves a range finder for a given identifier.',lib:'YRangeFinder::FindRangeFinder()',pro:'YRangeFinder* FindRangeFinder(string <span id=pn>func</span>)',cmt:'<p>Retrieves a range finder for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the range finder is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YRangeFinder.isOnline()</tt> to test if the range finder is indeed online at a given time. In case of ambiguity when looking for a range finder by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the range finder'},ret:'a <tt>YRangeFinder</tt> object allowing you to drive the range finder.'};
doc['RangeFinder']['FirstRangeFinder']={syn:'Starts the enumeration of range finders currently accessible.',lib:'YRangeFinder::FirstRangeFinder()',pro:'YRangeFinder* FirstRangeFinder()',cmt:'<p>Starts the enumeration of range finders currently accessible. Use the method <tt>YRangeFinder.nextRangeFinder()</tt> to iterate on next range finders.</p>',ret:'a pointer to a <tt>YRangeFinder</tt> object, corresponding to the first range finder currently online, or a <tt>null</tt> pointer if there are none.'};
doc['RangeFinder']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'rangefinder&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['cancelCoverGlassCalibrations']={syn:'Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings.',lib:'rangefinder&rarr;cancelCoverGlassCalibrations()',pro:'int cancelCoverGlassCalibrations()',cmt:'<p>Cancels the effect of previous hardware calibration procedures to compensate for cover glass, and restores factory settings. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['clearCache']={syn:'Invalidates the cache.',lib:'rangefinder&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the range finder attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['RangeFinder']['describe']={syn:'Returns a short text that describes unambiguously the instance of the range finder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'rangefinder&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the range finder in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the range finder (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['RangeFinder']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'rangefinder&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['RangeFinder']['get_advertisedValue']={syn:'Returns the current value of the range finder (no more than 6 characters).',lib:'rangefinder&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the range finder (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the range finder (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.',lib:'rangefinder&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in mm, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_currentTemperature']={syn:'Returns the current sensor temperature, as a floating point number.',lib:'rangefinder&rarr;get_currentTemperature()',pro:'double get_currentTemperature()',cmt:'<p>Returns the current sensor temperature, as a floating point number.</p>',ret:'a floating point number corresponding to the current sensor temperature, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTTEMPERATURE_INVALID</tt>.'};
doc['RangeFinder']['get_currentValue']={syn:'Returns the current value of the range measured, in mm, as a floating point number.',lib:'rangefinder&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the range measured, in mm, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the range measured, in mm, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'rangefinder&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['RangeFinder']['get_errorMessage']={syn:'Returns the error message of the latest error with the range finder.',lib:'rangefinder&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the range finder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the range finder object'};
doc['RangeFinder']['get_errorType']={syn:'Returns the numerical error code of the latest error with the range finder.',lib:'rangefinder&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the range finder. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the range finder object'};
doc['RangeFinder']['get_friendlyName']={syn:'Returns a global identifier of the range finder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'rangefinder&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the range finder in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the range finder if they are defined, otherwise the serial number of the module and the hardware identifier of the range finder (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the range finder using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['RangeFinder']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'rangefinder&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['RangeFinder']['get_functionId']={syn:'Returns the hardware identifier of the range finder, without reference to the module.',lib:'rangefinder&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the range finder, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the range finder (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['RangeFinder']['get_hardwareCalibrationTemperature']={syn:'Returns the temperature at the time when the latest calibration was performed.',lib:'rangefinder&rarr;get_hardwareCalibrationTemperature()',pro:'double get_hardwareCalibrationTemperature()',cmt:'<p>Returns the temperature at the time when the latest calibration was performed. This function can be used to determine if a new calibration for ambient temperature is required.</p>',ret:'a temperature, as a floating point number. On failure, throws an exception or return YAPI_INVALID_DOUBLE.'};
doc['RangeFinder']['get_hardwareId']={syn:'Returns the unique hardware identifier of the range finder in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'rangefinder&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the range finder in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the range finder (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the range finder (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['RangeFinder']['get_highestValue']={syn:'Returns the maximal value observed for the range measured since the device was started.',lib:'rangefinder&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the range measured since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'rangefinder&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['RangeFinder']['get_logicalName']={syn:'Returns the logical name of the range finder.',lib:'rangefinder&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the range finder.</p>',ret:'a string corresponding to the logical name of the range finder.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['RangeFinder']['get_lowestValue']={syn:'Returns the minimal value observed for the range measured since the device was started.',lib:'rangefinder&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the range measured since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the range measured since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['RangeFinder']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'rangefinder&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['RangeFinder']['get_rangeFinderMode']={syn:'Returns the range finder running mode.',lib:'rangefinder&rarr;get_rangeFinderMode()',pro:'Y_RANGEFINDERMODE_enum get_rangeFinderMode()',cmt:'<p>Returns the range finder running mode. The rangefinder running mode allows you to put priority on precision, speed or maximum range.</p>',ret:'a value among <tt>Y_RANGEFINDERMODE_DEFAULT</tt>, <tt>Y_RANGEFINDERMODE_LONG_RANGE</tt>, <tt>Y_RANGEFINDERMODE_HIGH_ACCURACY</tt> and <tt>Y_RANGEFINDERMODE_HIGH_SPEED</tt> corresponding to the range finder running mode',ext:'On failure, throws an exception or returns <tt>Y_RANGEFINDERMODE_INVALID</tt>.'};
doc['RangeFinder']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'rangefinder&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['RangeFinder']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'rangefinder&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['RangeFinder']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'rangefinder&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['RangeFinder']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'rangefinder&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['RangeFinder']['get_unit']={syn:'Returns the measuring unit for the range measured.',lib:'rangefinder&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the range measured.</p>',ret:'a string corresponding to the measuring unit for the range measured',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['RangeFinder']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'rangefinder&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['RangeFinder']['isOnline']={syn:'Checks if the range finder is currently reachable, without raising any error.',lib:'rangefinder&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the range finder is currently reachable, without raising any error. If there is a cached value for the range finder in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the range finder.</p>',ret:'<tt>true</tt> if the range finder can be reached, and <tt>false</tt> otherwise'};
doc['RangeFinder']['load']={syn:'Preloads the range finder cache with a specified validity duration.',lib:'rangefinder&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the range finder cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'rangefinder&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['RangeFinder']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'rangefinder&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'rangefinder&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['nextRangeFinder']={syn:'Continues the enumeration of range finders started using <tt>yFirstRangeFinder()</tt>.',lib:'rangefinder&rarr;nextRangeFinder()',pro:'YRangeFinder * nextRangeFinder()',cmt:'<p>Continues the enumeration of range finders started using <tt>yFirstRangeFinder()</tt>.</p>',ret:'a pointer to a <tt>YRangeFinder</tt> object, corresponding to a range finder currently online, or a <tt>null</tt> pointer if there are no more range finders to enumerate.'};
doc['RangeFinder']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'rangefinder&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YRangeFinderTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['RangeFinder']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'rangefinder&rarr;registerValueCallback()',pro:'int registerValueCallback(YRangeFinderValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['RangeFinder']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'rangefinder&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'rangefinder&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'rangefinder&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_logicalName']={syn:'Changes the logical name of the range finder.',lib:'rangefinder&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the range finder. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the range finder.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'rangefinder&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_rangeFinderMode']={syn:'Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.',lib:'rangefinder&rarr;set_rangeFinderMode()',pro:'int set_rangeFinderMode(Y_RANGEFINDERMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the rangefinder running mode, allowing you to put priority on precision, speed or maximum range.</p>',par:{newval:'a value among <tt>Y_RANGEFINDERMODE_DEFAULT</tt>, <tt>Y_RANGEFINDERMODE_LONG_RANGE</tt>, <tt>Y_RANGEFINDERMODE_HIGH_ACCURACY</tt> and <tt>Y_RANGEFINDERMODE_HIGH_SPEED</tt> corresponding to the rangefinder running mode, allowing you to put priority on precision, speed or maximum range'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'rangefinder&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'rangefinder&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_unit']={syn:'Changes the measuring unit for the measured range.',lib:'rangefinder&rarr;set_unit()',pro:'int set_unit(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the measured range. That unit is a string. String value can be <tt>\x22</tt> or <tt>mm</tt>. Any other value is ignored. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept. WARNING: if a specific calibration is defined for the rangeFinder function, a unit system change will probably break it.</p>',par:{newval:'a string corresponding to the measuring unit for the measured range'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'rangefinder&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['RangeFinder']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'rangefinder&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['RangeFinder']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'rangefinder&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['RangeFinder']['triggerOffsetCalibration']={syn:'Triggers the hardware offset calibration of the distance sensor.',lib:'rangefinder&rarr;triggerOffsetCalibration()',pro:'int triggerOffsetCalibration(double <span id=pn>targetDist</span>)',cmt:'<p>Triggers the hardware offset calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerSpadCalibration']={syn:'Triggers the photon detector hardware calibration.',lib:'rangefinder&rarr;triggerSpadCalibration()',pro:'int triggerSpadCalibration()',cmt:'<p>Triggers the photon detector hardware calibration. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerTemperatureCalibration']={syn:'Triggers a sensor calibration according to the current ambient temperature.',lib:'rangefinder&rarr;triggerTemperatureCalibration()',pro:'int triggerTemperatureCalibration()',cmt:'<p>Triggers a sensor calibration according to the current ambient temperature. That calibration process needs no physical interaction with the sensor. It is performed automatically at device startup, but it is recommended to start it again when the temperature delta since the latest calibration exceeds 8\xB0C.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['triggerXTalkCalibration']={syn:'Triggers the hardware cross-talk calibration of the distance sensor.',lib:'rangefinder&rarr;triggerXTalkCalibration()',pro:'int triggerXTalkCalibration(double <span id=pn>targetDist</span>)',cmt:'<p>Triggers the hardware cross-talk calibration of the distance sensor. This function is part of the calibration procedure to compensate for the the effect of a cover glass. Make sure to read the chapter about hardware calibration for details on the calibration procedure for proper results.</p>',par:{targetDist:'true distance of the calibration target, in mm or inches, depending on the unit selected in the device'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds. On failure, throws an exception or returns a negative error code.'};
doc['RangeFinder']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'rangefinder&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: RangeFinder)
//--- (generated code: DaisyChain)
doc['DaisyChain']={'':{syn:'DaisyChain function interface',inc:'#include &quot;yocto_daisychain.h&quot;',cmt:'<p>The YDaisyChain interface can be used to verify that devices that are daisy-chained directly from device to device, without a hub, are detected properly.</p>'}};
doc['DaisyChain']['FindDaisyChain']={syn:'Retrieves a module chain for a given identifier.',lib:'YDaisyChain::FindDaisyChain()',pro:'YDaisyChain* FindDaisyChain(string <span id=pn>func</span>)',cmt:'<p>Retrieves a module chain for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the module chain is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YDaisyChain.isOnline()</tt> to test if the module chain is indeed online at a given time. In case of ambiguity when looking for a module chain by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the module chain'},ret:'a <tt>YDaisyChain</tt> object allowing you to drive the module chain.'};
doc['DaisyChain']['FirstDaisyChain']={syn:'Starts the enumeration of module chains currently accessible.',lib:'YDaisyChain::FirstDaisyChain()',pro:'YDaisyChain* FirstDaisyChain()',cmt:'<p>Starts the enumeration of module chains currently accessible. Use the method <tt>YDaisyChain.nextDaisyChain()</tt> to iterate on next module chains.</p>',ret:'a pointer to a <tt>YDaisyChain</tt> object, corresponding to the first module chain currently online, or a <tt>null</tt> pointer if there are none.'};
doc['DaisyChain']['clearCache']={syn:'Invalidates the cache.',lib:'daisychain&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the module chain attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['DaisyChain']['describe']={syn:'Returns a short text that describes unambiguously the instance of the module chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'daisychain&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the module chain in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the module chain (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DaisyChain']['get_advertisedValue']={syn:'Returns the current value of the module chain (no more than 6 characters).',lib:'daisychain&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the module chain (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the module chain (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DaisyChain']['get_childCount']={syn:'Returns the number of child nodes currently detected.',lib:'daisychain&rarr;get_childCount()',pro:'int get_childCount()',cmt:'<p>Returns the number of child nodes currently detected.</p>',ret:'an integer corresponding to the number of child nodes currently detected',ext:'On failure, throws an exception or returns <tt>Y_CHILDCOUNT_INVALID</tt>.'};
doc['DaisyChain']['get_daisyState']={syn:'Returns the state of the daisy-link between modules.',lib:'daisychain&rarr;get_daisyState()',pro:'Y_DAISYSTATE_enum get_daisyState()',cmt:'<p>Returns the state of the daisy-link between modules.</p>',ret:'a value among <tt>Y_DAISYSTATE_READY</tt>, <tt>Y_DAISYSTATE_IS_CHILD</tt>, <tt>Y_DAISYSTATE_FIRMWARE_MISMATCH</tt>, <tt>Y_DAISYSTATE_CHILD_MISSING</tt> and <tt>Y_DAISYSTATE_CHILD_LOST</tt> corresponding to the state of the daisy-link between modules',ext:'On failure, throws an exception or returns <tt>Y_DAISYSTATE_INVALID</tt>.'};
doc['DaisyChain']['get_errorMessage']={syn:'Returns the error message of the latest error with the module chain.',lib:'daisychain&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the module chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the module chain object'};
doc['DaisyChain']['get_errorType']={syn:'Returns the numerical error code of the latest error with the module chain.',lib:'daisychain&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the module chain. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the module chain object'};
doc['DaisyChain']['get_friendlyName']={syn:'Returns a global identifier of the module chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'daisychain&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the module chain in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the module chain if they are defined, otherwise the serial number of the module and the hardware identifier of the module chain (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the module chain using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DaisyChain']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'daisychain&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['DaisyChain']['get_functionId']={syn:'Returns the hardware identifier of the module chain, without reference to the module.',lib:'daisychain&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the module chain, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the module chain (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DaisyChain']['get_hardwareId']={syn:'Returns the unique hardware identifier of the module chain in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'daisychain&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the module chain in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the module chain (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the module chain (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DaisyChain']['get_logicalName']={syn:'Returns the logical name of the module chain.',lib:'daisychain&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the module chain.</p>',ret:'a string corresponding to the logical name of the module chain.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DaisyChain']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'daisychain&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['DaisyChain']['get_requiredChildCount']={syn:'Returns the number of child nodes expected in normal conditions.',lib:'daisychain&rarr;get_requiredChildCount()',pro:'int get_requiredChildCount()',cmt:'<p>Returns the number of child nodes expected in normal conditions.</p>',ret:'an integer corresponding to the number of child nodes expected in normal conditions',ext:'On failure, throws an exception or returns <tt>Y_REQUIREDCHILDCOUNT_INVALID</tt>.'};
doc['DaisyChain']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'daisychain&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['DaisyChain']['isOnline']={syn:'Checks if the module chain is currently reachable, without raising any error.',lib:'daisychain&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the module chain is currently reachable, without raising any error. If there is a cached value for the module chain in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the module chain.</p>',ret:'<tt>true</tt> if the module chain can be reached, and <tt>false</tt> otherwise'};
doc['DaisyChain']['load']={syn:'Preloads the module chain cache with a specified validity duration.',lib:'daisychain&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the module chain cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'daisychain&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['DaisyChain']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'daisychain&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['nextDaisyChain']={syn:'Continues the enumeration of module chains started using <tt>yFirstDaisyChain()</tt>.',lib:'daisychain&rarr;nextDaisyChain()',pro:'YDaisyChain * nextDaisyChain()',cmt:'<p>Continues the enumeration of module chains started using <tt>yFirstDaisyChain()</tt>.</p>',ret:'a pointer to a <tt>YDaisyChain</tt> object, corresponding to a module chain currently online, or a <tt>null</tt> pointer if there are no more module chains to enumerate.'};
doc['DaisyChain']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'daisychain&rarr;registerValueCallback()',pro:'int registerValueCallback(YDaisyChainValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['DaisyChain']['set_logicalName']={syn:'Changes the logical name of the module chain.',lib:'daisychain&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the module chain. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the module chain.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['set_requiredChildCount']={syn:'Changes the number of child nodes expected in normal conditions.',lib:'daisychain&rarr;set_requiredChildCount()',pro:'int set_requiredChildCount(int <span id=pn>newval</span>)',cmt:'<p>Changes the number of child nodes expected in normal conditions. If the value is zero, no check is performed. If it is non-zero, the number child nodes is checked on startup and the status will change to error if the count does not match.</p>',par:{newval:'an integer corresponding to the number of child nodes expected in normal conditions'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['DaisyChain']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'daisychain&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['DaisyChain']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'daisychain&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: DaisyChain)
//--- (generated code: VoltageOutput)
doc['VoltageOutput']={'':{syn:'VoltageOutput function interface',inc:'#include &quot;yocto_voltageoutput.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to change the value of the voltage output.</p>'}};
doc['VoltageOutput']['FindVoltageOutput']={syn:'Retrieves a voltage output for a given identifier.',lib:'YVoltageOutput::FindVoltageOutput()',pro:'YVoltageOutput* FindVoltageOutput(string <span id=pn>func</span>)',cmt:'<p>Retrieves a voltage output for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the voltage output is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YVoltageOutput.isOnline()</tt> to test if the voltage output is indeed online at a given time. In case of ambiguity when looking for a voltage output by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the voltage output'},ret:'a <tt>YVoltageOutput</tt> object allowing you to drive the voltage output.'};
doc['VoltageOutput']['FirstVoltageOutput']={syn:'Starts the enumeration of voltage outputs currently accessible.',lib:'YVoltageOutput::FirstVoltageOutput()',pro:'YVoltageOutput* FirstVoltageOutput()',cmt:'<p>Starts the enumeration of voltage outputs currently accessible. Use the method <tt>YVoltageOutput.nextVoltageOutput()</tt> to iterate on next voltage outputs.</p>',ret:'a pointer to a <tt>YVoltageOutput</tt> object, corresponding to the first voltage output currently online, or a <tt>null</tt> pointer if there are none.'};
doc['VoltageOutput']['clearCache']={syn:'Invalidates the cache.',lib:'voltageoutput&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the voltage output attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['VoltageOutput']['describe']={syn:'Returns a short text that describes unambiguously the instance of the voltage output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltageoutput&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the voltage output in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the voltage output (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['VoltageOutput']['get_advertisedValue']={syn:'Returns the current value of the voltage output (no more than 6 characters).',lib:'voltageoutput&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the voltage output (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the voltage output (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VoltageOutput']['get_currentVoltage']={syn:'Returns the output voltage set point, in V.',lib:'voltageoutput&rarr;get_currentVoltage()',pro:'double get_currentVoltage()',cmt:'<p>Returns the output voltage set point, in V.</p>',ret:'a floating point number corresponding to the output voltage set point, in V',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVOLTAGE_INVALID</tt>.'};
doc['VoltageOutput']['get_errorMessage']={syn:'Returns the error message of the latest error with the voltage output.',lib:'voltageoutput&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the voltage output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the voltage output object'};
doc['VoltageOutput']['get_errorType']={syn:'Returns the numerical error code of the latest error with the voltage output.',lib:'voltageoutput&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the voltage output. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the voltage output object'};
doc['VoltageOutput']['get_friendlyName']={syn:'Returns a global identifier of the voltage output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'voltageoutput&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the voltage output in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the voltage output if they are defined, otherwise the serial number of the module and the hardware identifier of the voltage output (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the voltage output using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['VoltageOutput']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'voltageoutput&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['VoltageOutput']['get_functionId']={syn:'Returns the hardware identifier of the voltage output, without reference to the module.',lib:'voltageoutput&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the voltage output, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the voltage output (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['VoltageOutput']['get_hardwareId']={syn:'Returns the unique hardware identifier of the voltage output in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'voltageoutput&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the voltage output in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the voltage output (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the voltage output (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['VoltageOutput']['get_logicalName']={syn:'Returns the logical name of the voltage output.',lib:'voltageoutput&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the voltage output.</p>',ret:'a string corresponding to the logical name of the voltage output.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VoltageOutput']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'voltageoutput&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['VoltageOutput']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'voltageoutput&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['VoltageOutput']['get_voltageAtStartUp']={syn:'Returns the selected voltage output at device startup, in V.',lib:'voltageoutput&rarr;get_voltageAtStartUp()',pro:'double get_voltageAtStartUp()',cmt:'<p>Returns the selected voltage output at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage output at device startup, in V',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGEATSTARTUP_INVALID</tt>.'};
doc['VoltageOutput']['isOnline']={syn:'Checks if the voltage output is currently reachable, without raising any error.',lib:'voltageoutput&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the voltage output is currently reachable, without raising any error. If there is a cached value for the voltage output in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the voltage output.</p>',ret:'<tt>true</tt> if the voltage output can be reached, and <tt>false</tt> otherwise'};
doc['VoltageOutput']['load']={syn:'Preloads the voltage output cache with a specified validity duration.',lib:'voltageoutput&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the voltage output cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'voltageoutput&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['VoltageOutput']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'voltageoutput&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['nextVoltageOutput']={syn:'Continues the enumeration of voltage outputs started using <tt>yFirstVoltageOutput()</tt>.',lib:'voltageoutput&rarr;nextVoltageOutput()',pro:'YVoltageOutput * nextVoltageOutput()',cmt:'<p>Continues the enumeration of voltage outputs started using <tt>yFirstVoltageOutput()</tt>.</p>',ret:'a pointer to a <tt>YVoltageOutput</tt> object, corresponding to a voltage output currently online, or a <tt>null</tt> pointer if there are no more voltage outputs to enumerate.'};
doc['VoltageOutput']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'voltageoutput&rarr;registerValueCallback()',pro:'int registerValueCallback(YVoltageOutputValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['VoltageOutput']['set_currentVoltage']={syn:'Changes the output voltage, in V.',lib:'voltageoutput&rarr;set_currentVoltage()',pro:'int set_currentVoltage(double <span id=pn>newval</span>)',cmt:'<p>Changes the output voltage, in V. Valid range is from 0 to 10V.</p>',par:{newval:'a floating point number corresponding to the output voltage, in V'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['set_logicalName']={syn:'Changes the logical name of the voltage output.',lib:'voltageoutput&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the voltage output. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the voltage output.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'voltageoutput&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['VoltageOutput']['set_voltageAtStartUp']={syn:'Changes the output voltage at device start up.',lib:'voltageoutput&rarr;set_voltageAtStartUp()',pro:'int set_voltageAtStartUp(double <span id=pn>newval</span>)',cmt:'<p>Changes the output voltage at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the output voltage at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'voltageoutput&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['VoltageOutput']['voltageMove']={syn:'Performs a smooth transistion of output voltage.',lib:'voltageoutput&rarr;voltageMove()',pro:'int voltageMove(double <span id=pn>V_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Performs a smooth transistion of output voltage. Any explicit voltage change cancels any ongoing transition process.</p>',par:{V_target:'new output voltage value at the end of the transition (floating-point number, representing the end voltage in V)',ms_duration:'total duration of the transition, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.'};
//--- (end of generated code: VoltageOutput)
//--- (generated code: WeighScale)
doc['WeighScale']={'':{syn:'WeighScale function interface',inc:'#include &quot;yocto_weighscale.h&quot;',cmt:'<p>The YWeighScale class provides a weight measurement from a ratiometric load cell sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cell itself.</p>'}};
doc['WeighScale']['FindWeighScale']={syn:'Retrieves a weighing scale sensor for a given identifier.',lib:'YWeighScale::FindWeighScale()',pro:'YWeighScale* FindWeighScale(string <span id=pn>func</span>)',cmt:'<p>Retrieves a weighing scale sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the weighing scale sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YWeighScale.isOnline()</tt> to test if the weighing scale sensor is indeed online at a given time. In case of ambiguity when looking for a weighing scale sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the weighing scale sensor'},ret:'a <tt>YWeighScale</tt> object allowing you to drive the weighing scale sensor.'};
doc['WeighScale']['FirstWeighScale']={syn:'Starts the enumeration of weighing scale sensors currently accessible.',lib:'YWeighScale::FirstWeighScale()',pro:'YWeighScale* FirstWeighScale()',cmt:'<p>Starts the enumeration of weighing scale sensors currently accessible. Use the method <tt>YWeighScale.nextWeighScale()</tt> to iterate on next weighing scale sensors.</p>',ret:'a pointer to a <tt>YWeighScale</tt> object, corresponding to the first weighing scale sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['WeighScale']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'weighscale&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['clearCache']={syn:'Invalidates the cache.',lib:'weighscale&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the weighing scale sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['WeighScale']['describe']={syn:'Returns a short text that describes unambiguously the instance of the weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'weighscale&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the weighing scale sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['WeighScale']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'weighscale&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['WeighScale']['get_advertisedValue']={syn:'Returns the current value of the weighing scale sensor (no more than 6 characters).',lib:'weighscale&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the weighing scale sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['WeighScale']['get_compTempAdaptRatio']={syn:'Returns the averaged temperature update rate, in percents.',lib:'weighscale&rarr;get_compTempAdaptRatio()',pro:'double get_compTempAdaptRatio()',cmt:'<p>Returns the averaged temperature update rate, in percents. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambiant temperature and the current compensation temperature. The standard rate is 0.04 percents, and the maximal rate is 65 percents.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in percents',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPADAPTRATIO_INVALID</tt>.'};
doc['WeighScale']['get_compTempAvg']={syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'weighscale&rarr;get_compTempAvg()',pro:'double get_compTempAvg()',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPAVG_INVALID</tt>.'};
doc['WeighScale']['get_compTempChg']={syn:'Returns the current temperature variation, used for thermal compensation.',lib:'weighscale&rarr;get_compTempChg()',pro:'double get_compTempChg()',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPCHG_INVALID</tt>.'};
doc['WeighScale']['get_compensation']={syn:'Returns the current current thermal compensation value.',lib:'weighscale&rarr;get_compensation()',pro:'double get_compensation()',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:'On failure, throws an exception or returns <tt>Y_COMPENSATION_INVALID</tt>.'};
doc['WeighScale']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'weighscale&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['WeighScale']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'weighscale&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'weighscale&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['WeighScale']['get_errorMessage']={syn:'Returns the error message of the latest error with the weighing scale sensor.',lib:'weighscale&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the weighing scale sensor object'};
doc['WeighScale']['get_errorType']={syn:'Returns the numerical error code of the latest error with the weighing scale sensor.',lib:'weighscale&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the weighing scale sensor object'};
doc['WeighScale']['get_excitation']={syn:'Returns the current load cell bridge excitation method.',lib:'weighscale&rarr;get_excitation()',pro:'Y_EXCITATION_enum get_excitation()',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method',ext:'On failure, throws an exception or returns <tt>Y_EXCITATION_INVALID</tt>.'};
doc['WeighScale']['get_friendlyName']={syn:'Returns a global identifier of the weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'weighscale&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the weighing scale sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the weighing scale sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the weighing scale sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['WeighScale']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'weighscale&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['WeighScale']['get_functionId']={syn:'Returns the hardware identifier of the weighing scale sensor, without reference to the module.',lib:'weighscale&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the weighing scale sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the weighing scale sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['WeighScale']['get_hardwareId']={syn:'Returns the unique hardware identifier of the weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'weighscale&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the weighing scale sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the weighing scale sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['WeighScale']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'weighscale&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'weighscale&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['WeighScale']['get_logicalName']={syn:'Returns the logical name of the weighing scale sensor.',lib:'weighscale&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the weighing scale sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['WeighScale']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'weighscale&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['WeighScale']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'weighscale&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['WeighScale']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'weighscale&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['WeighScale']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'weighscale&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['WeighScale']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'weighscale&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['WeighScale']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'weighscale&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['WeighScale']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'weighscale&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['WeighScale']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'weighscale&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['WeighScale']['get_zeroTracking']={syn:'Returns the zero tracking threshold value.',lib:'weighscale&rarr;get_zeroTracking()',pro:'double get_zeroTracking()',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:'On failure, throws an exception or returns <tt>Y_ZEROTRACKING_INVALID</tt>.'};
doc['WeighScale']['isOnline']={syn:'Checks if the weighing scale sensor is currently reachable, without raising any error.',lib:'weighscale&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the weighing scale sensor is currently reachable, without raising any error. If there is a cached value for the weighing scale sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the weighing scale sensor.</p>',ret:'<tt>true</tt> if the weighing scale sensor can be reached, and <tt>false</tt> otherwise'};
doc['WeighScale']['load']={syn:'Preloads the weighing scale sensor cache with a specified validity duration.',lib:'weighscale&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the weighing scale sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'weighscale&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['WeighScale']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'weighscale&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadOffsetAvgCompensationTable']={syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function.',lib:'weighscale&rarr;loadOffsetAvgCompensationTable()',pro:'int loadOffsetAvgCompensationTable(vector&lt;double&gt;&amp; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadOffsetChgCompensationTable']={syn:'Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function.',lib:'weighscale&rarr;loadOffsetChgCompensationTable()',pro:'int loadOffsetChgCompensationTable(vector&lt;double&gt;&amp; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight offset thermal compensation table previously configured using the <tt>set_offsetChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the offset correction applied for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadSpanAvgCompensationTable']={syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function.',lib:'weighscale&rarr;loadSpanAvgCompensationTable()',pro:'int loadSpanAvgCompensationTable(vector&lt;double&gt;&amp; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanAvgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all averaged temperatures for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['loadSpanChgCompensationTable']={syn:'Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function.',lib:'weighscale&rarr;loadSpanChgCompensationTable()',pro:'int loadSpanChgCompensationTable(vector&lt;double&gt;&amp; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>compValues</span>)',cmt:'<p>Retrieves the weight span thermal compensation table previously configured using the <tt>set_spanChgCompensationTable</tt> function. The weight correction is applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, that is filled by the function with all variation of temperature for which an span correction is specified.',compValues:'array of floating point numbers, that is filled by the function with the span correction applied for each of variation of temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'weighscale&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['nextWeighScale']={syn:'Continues the enumeration of weighing scale sensors started using <tt>yFirstWeighScale()</tt>.',lib:'weighscale&rarr;nextWeighScale()',pro:'YWeighScale * nextWeighScale()',cmt:'<p>Continues the enumeration of weighing scale sensors started using <tt>yFirstWeighScale()</tt>.</p>',ret:'a pointer to a <tt>YWeighScale</tt> object, corresponding to a weighing scale sensor currently online, or a <tt>null</tt> pointer if there are no more weighing scale sensors to enumerate.'};
doc['WeighScale']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'weighscale&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YWeighScaleTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['WeighScale']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'weighscale&rarr;registerValueCallback()',pro:'int registerValueCallback(YWeighScaleValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['WeighScale']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'weighscale&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_compTempAdaptRatio']={syn:'Changes the averaged temperature update rate, in percents.',lib:'weighscale&rarr;set_compTempAdaptRatio()',pro:'int set_compTempAdaptRatio(double <span id=pn>newval</span>)',cmt:'<p>Changes the averaged temperature update rate, in percents. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambiant temperature and the current compensation temperature. The standard rate is 0.04 percents, and the maximal rate is 65 percents.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in percents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_excitation']={syn:'Changes the current load cell bridge excitation method.',lib:'weighscale&rarr;set_excitation()',pro:'int set_excitation(Y_EXCITATION_enum <span id=pn>newval</span>)',cmt:'<p>Changes the current load cell bridge excitation method.</p>',par:{newval:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'weighscale&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'weighscale&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_logicalName']={syn:'Changes the logical name of the weighing scale sensor.',lib:'weighscale&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the weighing scale sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the weighing scale sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'weighscale&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_offsetAvgCompensationTable']={syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature.',lib:'weighscale&rarr;set_offsetAvgCompensationTable()',pro:'int set_offsetAvgCompensationTable(vector&lt;double&gt; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>compValues</span>)',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the averaged compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_offsetChgCompensationTable']={syn:'Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'weighscale&rarr;set_offsetChgCompensationTable()',pro:'int set_offsetChgCompensationTable(vector&lt;double&gt; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>compValues</span>)',cmt:'<p>Records a weight offset thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to temperature variations for which an offset correction is specified.',compValues:'array of floating point numbers, corresponding to the offset correction to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'weighscale&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'weighscale&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_spanAvgCompensationTable']={syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature.',lib:'weighscale&rarr;set_spanAvgCompensationTable()',pro:'int set_spanAvgCompensationTable(vector&lt;double&gt; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>compValues</span>)',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the compensation temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all averaged temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_spanChgCompensationTable']={syn:'Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature.',lib:'weighscale&rarr;set_spanChgCompensationTable()',pro:'int set_spanChgCompensationTable(vector&lt;double&gt; <span id=pn>tempValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>compValues</span>)',cmt:'<p>Records a weight span thermal compensation table, in order to automatically correct the measured weight based on the variation of temperature. The weight correction will be applied by linear interpolation between specified points.</p>',par:{tempValues:'array of floating point numbers, corresponding to all variations of temperatures for which a span correction is specified.',compValues:'array of floating point numbers, corresponding to the span correction (in percents) to apply for each of the temperature variation included in the first argument, index by index.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_unit']={syn:'Changes the measuring unit for the weight.',lib:'weighscale&rarr;set_unit()',pro:'int set_unit(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'weighscale&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['WeighScale']['set_zeroTracking']={syn:'Changes the zero tracking threshold value.',lib:'weighscale&rarr;set_zeroTracking()',pro:'int set_zeroTracking(double <span id=pn>newval</span>)',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['setupSpan']={syn:'Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.',lib:'weighscale&rarr;setupSpan()',pro:'int setupSpan(double <span id=pn>currWeight</span>, double <span id=pn>maxWeight</span>)',cmt:'<p>Configures the load cell span parameters (stored in the corresponding genericSensor) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expectect on the load cell.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'weighscale&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['WeighScale']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'weighscale&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['WeighScale']['tare']={syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'weighscale&rarr;tare()',pro:'int tare()',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['WeighScale']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'weighscale&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: WeighScale)
//--- (generated code: PowerSupply)
doc['PowerSupply']={'':{syn:'PowerSupply function interface',inc:'#include &quot;yocto_powersupply.h&quot;',cmt:'<p>The Yoctopuce application programming interface allows you to change the voltage set point, the current limit and the enable/disable the output.</p>'}};
doc['PowerSupply']['FindPowerSupply']={syn:'Retrieves a regulated power supply for a given identifier.',lib:'YPowerSupply::FindPowerSupply()',pro:'YPowerSupply* FindPowerSupply(string <span id=pn>func</span>)',cmt:'<p>Retrieves a regulated power supply for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the regulated power supply is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YPowerSupply.isOnline()</tt> to test if the regulated power supply is indeed online at a given time. In case of ambiguity when looking for a regulated power supply by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the regulated power supply'},ret:'a <tt>YPowerSupply</tt> object allowing you to drive the regulated power supply.'};
doc['PowerSupply']['FirstPowerSupply']={syn:'Starts the enumeration of regulated power supplies currently accessible.',lib:'YPowerSupply::FirstPowerSupply()',pro:'YPowerSupply* FirstPowerSupply()',cmt:'<p>Starts the enumeration of regulated power supplies currently accessible. Use the method <tt>YPowerSupply.nextPowerSupply()</tt> to iterate on next regulated power supplies.</p>',ret:'a pointer to a <tt>YPowerSupply</tt> object, corresponding to the first regulated power supply currently online, or a <tt>null</tt> pointer if there are none.'};
doc['PowerSupply']['clearCache']={syn:'Invalidates the cache.',lib:'powersupply&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the regulated power supply attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['PowerSupply']['describe']={syn:'Returns a short text that describes unambiguously the instance of the regulated power supply in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'powersupply&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the regulated power supply in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the regulated power supply (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['PowerSupply']['get_advertisedValue']={syn:'Returns the current value of the regulated power supply (no more than 6 characters).',lib:'powersupply&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the regulated power supply (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the regulated power supply (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['PowerSupply']['get_currentAtStartUp']={syn:'Returns the selected current limit at device startup, in mA.',lib:'powersupply&rarr;get_currentAtStartUp()',pro:'double get_currentAtStartUp()',cmt:'<p>Returns the selected current limit at device startup, in mA.</p>',ret:'a floating point number corresponding to the selected current limit at device startup, in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENTATSTARTUP_INVALID</tt>.'};
doc['PowerSupply']['get_currentLimit']={syn:'Returns the current limit, in mA.',lib:'powersupply&rarr;get_currentLimit()',pro:'double get_currentLimit()',cmt:'<p>Returns the current limit, in mA.</p>',ret:'a floating point number corresponding to the current limit, in mA',ext:'On failure, throws an exception or returns <tt>Y_CURRENTLIMIT_INVALID</tt>.'};
doc['PowerSupply']['get_errorMessage']={syn:'Returns the error message of the latest error with the regulated power supply.',lib:'powersupply&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the regulated power supply. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the regulated power supply object'};
doc['PowerSupply']['get_errorType']={syn:'Returns the numerical error code of the latest error with the regulated power supply.',lib:'powersupply&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the regulated power supply. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the regulated power supply object'};
doc['PowerSupply']['get_friendlyName']={syn:'Returns a global identifier of the regulated power supply in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'powersupply&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the regulated power supply in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the regulated power supply if they are defined, otherwise the serial number of the module and the hardware identifier of the regulated power supply (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the regulated power supply using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['PowerSupply']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'powersupply&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['PowerSupply']['get_functionId']={syn:'Returns the hardware identifier of the regulated power supply, without reference to the module.',lib:'powersupply&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the regulated power supply, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the regulated power supply (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['PowerSupply']['get_hardwareId']={syn:'Returns the unique hardware identifier of the regulated power supply in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'powersupply&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the regulated power supply in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the regulated power supply (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the regulated power supply (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['PowerSupply']['get_inputVoltage']={syn:'Returns the measured input voltage, in V.',lib:'powersupply&rarr;get_inputVoltage()',pro:'double get_inputVoltage()',cmt:'<p>Returns the measured input voltage, in V.</p>',ret:'a floating point number corresponding to the measured input voltage, in V',ext:'On failure, throws an exception or returns <tt>Y_INPUTVOLTAGE_INVALID</tt>.'};
doc['PowerSupply']['get_ldoTemperature']={syn:'Returns the LDO temperature, in Celsius.',lib:'powersupply&rarr;get_ldoTemperature()',pro:'double get_ldoTemperature()',cmt:'<p>Returns the LDO temperature, in Celsius.</p>',ret:'a floating point number corresponding to the LDO temperature, in Celsius',ext:'On failure, throws an exception or returns <tt>Y_LDOTEMPERATURE_INVALID</tt>.'};
doc['PowerSupply']['get_logicalName']={syn:'Returns the logical name of the regulated power supply.',lib:'powersupply&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the regulated power supply.</p>',ret:'a string corresponding to the logical name of the regulated power supply.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['PowerSupply']['get_measuredCurrent']={syn:'Returns the measured output current, in mA.',lib:'powersupply&rarr;get_measuredCurrent()',pro:'double get_measuredCurrent()',cmt:'<p>Returns the measured output current, in mA.</p>',ret:'a floating point number corresponding to the measured output current, in mA',ext:'On failure, throws an exception or returns <tt>Y_MEASUREDCURRENT_INVALID</tt>.'};
doc['PowerSupply']['get_measuredVoltage']={syn:'Returns the measured output voltage, in V.',lib:'powersupply&rarr;get_measuredVoltage()',pro:'double get_measuredVoltage()',cmt:'<p>Returns the measured output voltage, in V.</p>',ret:'a floating point number corresponding to the measured output voltage, in V',ext:'On failure, throws an exception or returns <tt>Y_MEASUREDVOLTAGE_INVALID</tt>.'};
doc['PowerSupply']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'powersupply&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['PowerSupply']['get_powerOutput']={syn:'Returns the power supply output switch state.',lib:'powersupply&rarr;get_powerOutput()',pro:'Y_POWEROUTPUT_enum get_powerOutput()',cmt:'<p>Returns the power supply output switch state.</p>',ret:'either <tt>Y_POWEROUTPUT_OFF</tt> or <tt>Y_POWEROUTPUT_ON</tt>, according to the power supply output switch state',ext:'On failure, throws an exception or returns <tt>Y_POWEROUTPUT_INVALID</tt>.'};
doc['PowerSupply']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'powersupply&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['PowerSupply']['get_vInt']={syn:'Returns the internal voltage, in V.',lib:'powersupply&rarr;get_vInt()',pro:'double get_vInt()',cmt:'<p>Returns the internal voltage, in V.</p>',ret:'a floating point number corresponding to the internal voltage, in V',ext:'On failure, throws an exception or returns <tt>Y_VINT_INVALID</tt>.'};
doc['PowerSupply']['get_voltageAtStartUp']={syn:'Returns the selected voltage set point at device startup, in V.',lib:'powersupply&rarr;get_voltageAtStartUp()',pro:'double get_voltageAtStartUp()',cmt:'<p>Returns the selected voltage set point at device startup, in V.</p>',ret:'a floating point number corresponding to the selected voltage set point at device startup, in V',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGEATSTARTUP_INVALID</tt>.'};
doc['PowerSupply']['get_voltageSense']={syn:'Returns the output voltage control point.',lib:'powersupply&rarr;get_voltageSense()',pro:'Y_VOLTAGESENSE_enum get_voltageSense()',cmt:'<p>Returns the output voltage control point.</p>',ret:'either <tt>Y_VOLTAGESENSE_INT</tt> or <tt>Y_VOLTAGESENSE_EXT</tt>, according to the output voltage control point',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGESENSE_INVALID</tt>.'};
doc['PowerSupply']['get_voltageSetPoint']={syn:'Returns the voltage set point, in V.',lib:'powersupply&rarr;get_voltageSetPoint()',pro:'double get_voltageSetPoint()',cmt:'<p>Returns the voltage set point, in V.</p>',ret:'a floating point number corresponding to the voltage set point, in V',ext:'On failure, throws an exception or returns <tt>Y_VOLTAGESETPOINT_INVALID</tt>.'};
doc['PowerSupply']['isOnline']={syn:'Checks if the regulated power supply is currently reachable, without raising any error.',lib:'powersupply&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the regulated power supply is currently reachable, without raising any error. If there is a cached value for the regulated power supply in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the regulated power supply.</p>',ret:'<tt>true</tt> if the regulated power supply can be reached, and <tt>false</tt> otherwise'};
doc['PowerSupply']['load']={syn:'Preloads the regulated power supply cache with a specified validity duration.',lib:'powersupply&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the regulated power supply cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'powersupply&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['PowerSupply']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'powersupply&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['nextPowerSupply']={syn:'Continues the enumeration of regulated power supplies started using <tt>yFirstPowerSupply()</tt>.',lib:'powersupply&rarr;nextPowerSupply()',pro:'YPowerSupply * nextPowerSupply()',cmt:'<p>Continues the enumeration of regulated power supplies started using <tt>yFirstPowerSupply()</tt>.</p>',ret:'a pointer to a <tt>YPowerSupply</tt> object, corresponding to a regulated power supply currently online, or a <tt>null</tt> pointer if there are no more regulated power supplies to enumerate.'};
doc['PowerSupply']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'powersupply&rarr;registerValueCallback()',pro:'int registerValueCallback(YPowerSupplyValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['PowerSupply']['set_currentAtStartUp']={syn:'Changes the current limit at device start up.',lib:'powersupply&rarr;set_currentAtStartUp()',pro:'int set_currentAtStartUp(double <span id=pn>newval</span>)',cmt:'<p>Changes the current limit at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the current limit at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_currentLimit']={syn:'Changes the current limit, in mA.',lib:'powersupply&rarr;set_currentLimit()',pro:'int set_currentLimit(double <span id=pn>newval</span>)',cmt:'<p>Changes the current limit, in mA.</p>',par:{newval:'a floating point number corresponding to the current limit, in mA'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_logicalName']={syn:'Changes the logical name of the regulated power supply.',lib:'powersupply&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the regulated power supply. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the regulated power supply.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_powerOutput']={syn:'Changes the power supply output switch state.',lib:'powersupply&rarr;set_powerOutput()',pro:'int set_powerOutput(Y_POWEROUTPUT_enum <span id=pn>newval</span>)',cmt:'<p>Changes the power supply output switch state.</p>',par:{newval:'either <tt>Y_POWEROUTPUT_OFF</tt> or <tt>Y_POWEROUTPUT_ON</tt>, according to the power supply output switch state'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'powersupply&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['PowerSupply']['set_voltageAtStartUp']={syn:'Changes the voltage set point at device start up.',lib:'powersupply&rarr;set_voltageAtStartUp()',pro:'int set_voltageAtStartUp(double <span id=pn>newval</span>)',cmt:'<p>Changes the voltage set point at device start up. Remember to call the matching module <tt>saveToFlash()</tt> method, otherwise this call has no effect.</p>',par:{newval:'a floating point number corresponding to the voltage set point at device start up'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_voltageSense']={syn:'Changes the voltage control point.',lib:'powersupply&rarr;set_voltageSense()',pro:'int set_voltageSense(Y_VOLTAGESENSE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the voltage control point.</p>',par:{newval:'either <tt>Y_VOLTAGESENSE_INT</tt> or <tt>Y_VOLTAGESENSE_EXT</tt>, according to the voltage control point'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['set_voltageSetPoint']={syn:'Changes the voltage set point, in V.',lib:'powersupply&rarr;set_voltageSetPoint()',pro:'int set_voltageSetPoint(double <span id=pn>newval</span>)',cmt:'<p>Changes the voltage set point, in V.</p>',par:{newval:'a floating point number corresponding to the voltage set point, in V'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['PowerSupply']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'powersupply&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: PowerSupply)
//--- (generated code: MultiCellWeighScale)
doc['MultiCellWeighScale']={'':{syn:'MultiCellWeighScale function interface',inc:'#include &quot;yocto_multicellweighscale.h&quot;',cmt:'<p>The YMultiCellWeighScale class provides a weight measurement from a set of ratiometric load cells sensor. It can be used to control the bridge excitation parameters, in order to avoid measure shifts caused by temperature variation in the electronics, and can also automatically apply an additional correction factor based on temperature to compensate for offsets in the load cells themselves.</p>'}};
doc['MultiCellWeighScale']['FindMultiCellWeighScale']={syn:'Retrieves a multi-cell weighing scale sensor for a given identifier.',lib:'YMultiCellWeighScale::FindMultiCellWeighScale()',pro:'YMultiCellWeighScale* FindMultiCellWeighScale(string <span id=pn>func</span>)',cmt:'<p>Retrieves a multi-cell weighing scale sensor for a given identifier. The identifier can be specified using several formats:<br> <ul> <li>FunctionLogicalName</li> <li>ModuleSerialNumber.FunctionIdentifier</li> <li>ModuleSerialNumber.FunctionLogicalName</li> <li>ModuleLogicalName.FunctionIdentifier</li> <li>ModuleLogicalName.FunctionLogicalName</li> </ul></p><p> This function does not require that the multi-cell weighing scale sensor is online at the time it is invoked. The returned object is nevertheless valid. Use the method <tt>YMultiCellWeighScale.isOnline()</tt> to test if the multi-cell weighing scale sensor is indeed online at a given time. In case of ambiguity when looking for a multi-cell weighing scale sensor by logical name, no error is notified: the first instance found is returned. The search is performed first by hardware name, then by logical name.</p><p> If a call to this object\x27s is_online() method returns FALSE although you are certain that the matching device is plugged, make sure that you did call registerHub() at application initialization time.</p>',par:{func:'a string that uniquely characterizes the multi-cell weighing scale sensor'},ret:'a <tt>YMultiCellWeighScale</tt> object allowing you to drive the multi-cell weighing scale sensor.'};
doc['MultiCellWeighScale']['FirstMultiCellWeighScale']={syn:'Starts the enumeration of multi-cell weighing scale sensors currently accessible.',lib:'YMultiCellWeighScale::FirstMultiCellWeighScale()',pro:'YMultiCellWeighScale* FirstMultiCellWeighScale()',cmt:'<p>Starts the enumeration of multi-cell weighing scale sensors currently accessible. Use the method <tt>YMultiCellWeighScale.nextMultiCellWeighScale()</tt> to iterate on next multi-cell weighing scale sensors.</p>',ret:'a pointer to a <tt>YMultiCellWeighScale</tt> object, corresponding to the first multi-cell weighing scale sensor currently online, or a <tt>null</tt> pointer if there are none.'};
doc['MultiCellWeighScale']['calibrateFromPoints']={syn:'Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure.',lib:'multicellweighscale&rarr;calibrateFromPoints()',pro:'int calibrateFromPoints(vector&lt;double&gt; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt; <span id=pn>refValues</span>)',cmt:'<p>Configures error correction data points, in particular to compensate for a possible perturbation of the measure caused by an enclosure. It is possible to configure up to five correction points. Correction points must be provided in ascending order, and be in the range of the sensor. The device will automatically perform a linear interpolation of the error correction between specified points. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p><p> For more information on advanced capabilities to refine the calibration of sensors, please contact support@yoctopuce.com.</p>',par:{rawValues:'array of floating point numbers, corresponding to the raw values returned by the sensor for the correction points.',refValues:'array of floating point numbers, corresponding to the corrected values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['clearCache']={syn:'Invalidates the cache.',lib:'multicellweighscale&rarr;clearCache()',pro:'void clearCache()',cmt:'<p>Invalidates the cache. Invalidates the cache of the multi-cell weighing scale sensor attributes. Forces the next call to get_xxx() or loadxxx() to use values that come from the device.</p>'};
doc['MultiCellWeighScale']['describe']={syn:'Returns a short text that describes unambiguously the instance of the multi-cell weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'multicellweighscale&rarr;describe()',pro:'string describe()',cmt:'<p>Returns a short text that describes unambiguously the instance of the multi-cell weighing scale sensor in the form <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. More precisely, <tt>TYPE</tt> is the type of the function, <tt>NAME</tt> it the name used for the first access to the function, <tt>SERIAL</tt> is the serial number of the module if the module is connected or <tt>\x22unresolved\x22</tt>, and <tt>FUNCTIONID</tt> is the hardware identifier of the function if the module is connected. For example, this method returns <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> if the module is already connected or <tt>Relay(BadCustomeName.relay1)=unresolved</tt> if the module has not yet been connected. This method does not trigger any USB or TCP transaction and can therefore be used in a debugger.</p>',ret:'a string that describes the multi-cell weighing scale sensor (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['MultiCellWeighScale']['get_advMode']={syn:'Returns the measuring mode used for the advertised value pushed to the parent hub.',lib:'multicellweighscale&rarr;get_advMode()',pro:'Y_ADVMODE_enum get_advMode()',cmt:'<p>Returns the measuring mode used for the advertised value pushed to the parent hub.</p>',ret:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub',ext:'On failure, throws an exception or returns <tt>Y_ADVMODE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_advertisedValue']={syn:'Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).',lib:'multicellweighscale&rarr;get_advertisedValue()',pro:'string get_advertisedValue()',cmt:'<p>Returns the current value of the multi-cell weighing scale sensor (no more than 6 characters).</p>',ret:'a string corresponding to the current value of the multi-cell weighing scale sensor (no more than 6 characters).',ext:'On failure, throws an exception or returns <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_cellCount']={syn:'Returns the number of load cells in use.',lib:'multicellweighscale&rarr;get_cellCount()',pro:'int get_cellCount()',cmt:'<p>Returns the number of load cells in use.</p>',ret:'an integer corresponding to the number of load cells in use',ext:'On failure, throws an exception or returns <tt>Y_CELLCOUNT_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempAdaptRatio']={syn:'Returns the averaged temperature update rate, in percents.',lib:'multicellweighscale&rarr;get_compTempAdaptRatio()',pro:'double get_compTempAdaptRatio()',cmt:'<p>Returns the averaged temperature update rate, in percents. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambiant temperature and the current compensation temperature. The standard rate is 0.04 percents, and the maximal rate is 65 percents.</p>',ret:'a floating point number corresponding to the averaged temperature update rate, in percents',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPADAPTRATIO_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempAvg']={syn:'Returns the current averaged temperature, used for thermal compensation.',lib:'multicellweighscale&rarr;get_compTempAvg()',pro:'double get_compTempAvg()',cmt:'<p>Returns the current averaged temperature, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current averaged temperature, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPAVG_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compTempChg']={syn:'Returns the current temperature variation, used for thermal compensation.',lib:'multicellweighscale&rarr;get_compTempChg()',pro:'double get_compTempChg()',cmt:'<p>Returns the current temperature variation, used for thermal compensation.</p>',ret:'a floating point number corresponding to the current temperature variation, used for thermal compensation',ext:'On failure, throws an exception or returns <tt>Y_COMPTEMPCHG_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_compensation']={syn:'Returns the current current thermal compensation value.',lib:'multicellweighscale&rarr;get_compensation()',pro:'double get_compensation()',cmt:'<p>Returns the current current thermal compensation value.</p>',ret:'a floating point number corresponding to the current current thermal compensation value',ext:'On failure, throws an exception or returns <tt>Y_COMPENSATION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_currentRawValue']={syn:'Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.',lib:'multicellweighscale&rarr;get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Returns the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the uncalibrated, unrounded raw value returned by the sensor, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_currentValue']={syn:'Returns the current value of the measure, in the specified unit, as a floating point number.',lib:'multicellweighscale&rarr;get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Returns the current value of the measure, in the specified unit, as a floating point number.</p>',ret:'a floating point number corresponding to the current value of the measure, in the specified unit, as a floating point number',ext:'On failure, throws an exception or returns <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_dataLogger']={syn:'Returns the YDatalogger object of the device hosting the sensor.',lib:'multicellweighscale&rarr;get_dataLogger()',pro:'YDataLogger* get_dataLogger()',cmt:'<p>Returns the YDatalogger object of the device hosting the sensor. This method returns an object of class YDatalogger that can control global parameters of the data logger. The returned object should not be freed.</p>',ret:'an YDataLogger object or null on error.'};
doc['MultiCellWeighScale']['get_errorMessage']={syn:'Returns the error message of the latest error with the multi-cell weighing scale sensor.',lib:'multicellweighscale&rarr;get_errorMessage()',pro:'string get_errorMessage()',cmt:'<p>Returns the error message of the latest error with the multi-cell weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a string corresponding to the latest error message that occured while using the multi-cell weighing scale sensor object'};
doc['MultiCellWeighScale']['get_errorType']={syn:'Returns the numerical error code of the latest error with the multi-cell weighing scale sensor.',lib:'multicellweighscale&rarr;get_errorType()',pro:'YRETCODE get_errorType()',cmt:'<p>Returns the numerical error code of the latest error with the multi-cell weighing scale sensor. This method is mostly useful when using the Yoctopuce library with exceptions disabled.</p>',ret:'a number corresponding to the code of the latest error that occurred while using the multi-cell weighing scale sensor object'};
doc['MultiCellWeighScale']['get_excitation']={syn:'Returns the current load cell bridge excitation method.',lib:'multicellweighscale&rarr;get_excitation()',pro:'Y_EXCITATION_enum get_excitation()',cmt:'<p>Returns the current load cell bridge excitation method.</p>',ret:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method',ext:'On failure, throws an exception or returns <tt>Y_EXCITATION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_friendlyName']={syn:'Returns a global identifier of the multi-cell weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>.',lib:'multicellweighscale&rarr;get_friendlyName()',pro:'string get_friendlyName()',cmt:'<p>Returns a global identifier of the multi-cell weighing scale sensor in the format <tt>MODULE_NAME&#46;FUNCTION_NAME</tt>. The returned string uses the logical names of the module and of the multi-cell weighing scale sensor if they are defined, otherwise the serial number of the module and the hardware identifier of the multi-cell weighing scale sensor (for example: <tt>MyCustomName.relay1</tt>)</p>',ret:'a string that uniquely identifies the multi-cell weighing scale sensor using logical names (ex: <tt>MyCustomName.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_functionDescriptor']={syn:'Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function.',lib:'multicellweighscale&rarr;get_functionDescriptor()',pro:'YFUN_DESCR get_functionDescriptor()',cmt:'<p>Returns a unique identifier of type <tt>YFUN_DESCR</tt> corresponding to the function. This identifier can be used to test if two instances of <tt>YFunction</tt> reference the same physical function on the same physical device.</p>',ret:'an identifier of type <tt>YFUN_DESCR</tt>.',ext:'If the function has never been contacted, the returned value is <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_functionId']={syn:'Returns the hardware identifier of the multi-cell weighing scale sensor, without reference to the module.',lib:'multicellweighscale&rarr;get_functionId()',pro:'string get_functionId()',cmt:'<p>Returns the hardware identifier of the multi-cell weighing scale sensor, without reference to the module. For example <tt>relay1</tt></p>',ret:'a string that identifies the multi-cell weighing scale sensor (ex: <tt>relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_hardwareId']={syn:'Returns the unique hardware identifier of the multi-cell weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>.',lib:'multicellweighscale&rarr;get_hardwareId()',pro:'string get_hardwareId()',cmt:'<p>Returns the unique hardware identifier of the multi-cell weighing scale sensor in the form <tt>SERIAL.FUNCTIONID</tt>. The unique hardware identifier is composed of the device serial number and of the hardware identifier of the multi-cell weighing scale sensor (for example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'a string that uniquely identifies the multi-cell weighing scale sensor (ex: <tt>RELAYLO1-123456.relay1</tt>)',ext:'On failure, throws an exception or returns <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_highestValue']={syn:'Returns the maximal value observed for the measure since the device was started.',lib:'multicellweighscale&rarr;get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Returns the maximal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_highestValue().</p>',ret:'a floating point number corresponding to the maximal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_logFrequency']={syn:'Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.',lib:'multicellweighscale&rarr;get_logFrequency()',pro:'string get_logFrequency()',cmt:'<p>Returns the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory.</p>',ret:'a string corresponding to the datalogger recording frequency for this function, or \x22OFF\x22 when measures are not stored in the data logger flash memory',ext:'On failure, throws an exception or returns <tt>Y_LOGFREQUENCY_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_logicalName']={syn:'Returns the logical name of the multi-cell weighing scale sensor.',lib:'multicellweighscale&rarr;get_logicalName()',pro:'string get_logicalName()',cmt:'<p>Returns the logical name of the multi-cell weighing scale sensor.</p>',ret:'a string corresponding to the logical name of the multi-cell weighing scale sensor.',ext:'On failure, throws an exception or returns <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_lowestValue']={syn:'Returns the minimal value observed for the measure since the device was started.',lib:'multicellweighscale&rarr;get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Returns the minimal value observed for the measure since the device was started. Can be reset to an arbitrary value thanks to set_lowestValue().</p>',ret:'a floating point number corresponding to the minimal value observed for the measure since the device was started',ext:'On failure, throws an exception or returns <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_module']={syn:'Gets the <tt>YModule</tt> object for the device on which the function is located.',lib:'multicellweighscale&rarr;get_module()',pro:'YModule * get_module()',cmt:'<p>Gets the <tt>YModule</tt> object for the device on which the function is located. If the function cannot be located on any module, the returned instance of <tt>YModule</tt> is not shown as on-line.</p>',ret:'an instance of <tt>YModule</tt>'};
doc['MultiCellWeighScale']['get_recordedData']={syn:'Retrieves a DataSet object holding historical data for this sensor, for a specified time interval.',lib:'multicellweighscale&rarr;get_recordedData()',pro:'YDataSet get_recordedData(s64 <span id=pn>startTime</span>, s64 <span id=pn>endTime</span>)',cmt:'<p>Retrieves a DataSet object holding historical data for this sensor, for a specified time interval. The measures will be retrieved from the data logger, which must have been turned on at the desired time. See the documentation of the DataSet class for information on how to get an overview of the recorded data, and how to load progressively a large set of measures from the data logger.</p><p> This function only works if the device uses a recent firmware, as DataSet objects are not supported by firmwares older than version 13000.</p>',par:{startTime:'the start of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without initial limit.',endTime:'the end of the desired measure time interval, as a Unix timestamp, i.e. the number of seconds since January 1, 1970 UTC. The special value 0 can be used to include any meaasure, without ending limit.'},ret:'an instance of YDataSet, providing access to historical data. Past measures can be loaded progressively using methods from the YDataSet object.'};
doc['MultiCellWeighScale']['get_reportFrequency']={syn:'Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.',lib:'multicellweighscale&rarr;get_reportFrequency()',pro:'string get_reportFrequency()',cmt:'<p>Returns the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function.</p>',ret:'a string corresponding to the timed value notification frequency, or \x22OFF\x22 if timed value notifications are disabled for this function',ext:'On failure, throws an exception or returns <tt>Y_REPORTFREQUENCY_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_resolution']={syn:'Returns the resolution of the measured values.',lib:'multicellweighscale&rarr;get_resolution()',pro:'double get_resolution()',cmt:'<p>Returns the resolution of the measured values. The resolution corresponds to the numerical precision of the measures, which is not always the same as the actual precision of the sensor.</p>',ret:'a floating point number corresponding to the resolution of the measured values',ext:'On failure, throws an exception or returns <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_sensorState']={syn:'Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.',lib:'multicellweighscale&rarr;get_sensorState()',pro:'int get_sensorState()',cmt:'<p>Returns the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now.</p>',ret:'an integer corresponding to the sensor health state code, which is zero when there is an up-to-date measure available or a positive code if the sensor is not able to provide a measure right now',ext:'On failure, throws an exception or returns <tt>Y_SENSORSTATE_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_unit']={syn:'Returns the measuring unit for the measure.',lib:'multicellweighscale&rarr;get_unit()',pro:'string get_unit()',cmt:'<p>Returns the measuring unit for the measure.</p>',ret:'a string corresponding to the measuring unit for the measure',ext:'On failure, throws an exception or returns <tt>Y_UNIT_INVALID</tt>.'};
doc['MultiCellWeighScale']['get_userData']={syn:'Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>.',lib:'multicellweighscale&rarr;get_userData()',pro:'void * get_userData()',cmt:'<p>Returns the value of the userData attribute, as previously stored using method <tt>set_userData</tt>. This attribute is never touched directly by the API, and is at disposal of the caller to store a context.</p>',ret:'the object stored previously by the caller.'};
doc['MultiCellWeighScale']['get_zeroTracking']={syn:'Returns the zero tracking threshold value.',lib:'multicellweighscale&rarr;get_zeroTracking()',pro:'double get_zeroTracking()',cmt:'<p>Returns the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',ret:'a floating point number corresponding to the zero tracking threshold value',ext:'On failure, throws an exception or returns <tt>Y_ZEROTRACKING_INVALID</tt>.'};
doc['MultiCellWeighScale']['isOnline']={syn:'Checks if the multi-cell weighing scale sensor is currently reachable, without raising any error.',lib:'multicellweighscale&rarr;isOnline()',pro:'bool isOnline()',cmt:'<p>Checks if the multi-cell weighing scale sensor is currently reachable, without raising any error. If there is a cached value for the multi-cell weighing scale sensor in cache, that has not yet expired, the device is considered reachable. No exception is raised if there is an error while trying to contact the device hosting the multi-cell weighing scale sensor.</p>',ret:'<tt>true</tt> if the multi-cell weighing scale sensor can be reached, and <tt>false</tt> otherwise'};
doc['MultiCellWeighScale']['load']={syn:'Preloads the multi-cell weighing scale sensor cache with a specified validity duration.',lib:'multicellweighscale&rarr;load()',pro:'YRETCODE load(int <span id=pn>msValidity</span>)',cmt:'<p>Preloads the multi-cell weighing scale sensor cache with a specified validity duration. By default, whenever accessing a device, all function attributes are kept in cache for the standard duration (5 ms). This method can be used to temporarily mark the cache as valid for a longer period, in order to reduce network traffic for instance.</p>',par:{msValidity:'an integer corresponding to the validity attributed to the loaded function parameters, in milliseconds'},ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['loadAttribute']={syn:'Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.',lib:'multicellweighscale&rarr;loadAttribute()',pro:'string loadAttribute(string <span id=pn>attrName</span>)',cmt:'<p>Returns the current value of a single function attribute, as a text string, as quickly as possible but without using the cached value.</p>',par:{attrName:'the name of the requested attribute'},ret:'a string with the value of the the attribute',ext:'On failure, throws an exception or returns an empty string.'};
doc['MultiCellWeighScale']['loadCalibrationPoints']={syn:'Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.',lib:'multicellweighscale&rarr;loadCalibrationPoints()',pro:'int loadCalibrationPoints(vector&lt;double&gt;&amp; <span id=pn>rawValues</span>,&nbsp;vector&lt;double&gt;&amp; <span id=pn>refValues</span>)',cmt:'<p>Retrieves error correction data points previously entered using the method <tt>calibrateFromPoints</tt>.</p>',par:{rawValues:'array of floating point numbers, that will be filled by the function with the raw sensor values for the correction points.',refValues:'array of floating point numbers, that will be filled by the function with the desired values for the correction points.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['muteValueCallbacks']={syn:'Disables the propagation of every new advertised value to the parent hub.',lib:'multicellweighscale&rarr;muteValueCallbacks()',pro:'int muteValueCallbacks()',cmt:'<p>Disables the propagation of every new advertised value to the parent hub. You can use this function to save bandwidth and CPU on computers with limited resources, or to prevent unwanted invocations of the HTTP callback. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['nextMultiCellWeighScale']={syn:'Continues the enumeration of multi-cell weighing scale sensors started using <tt>yFirstMultiCellWeighScale()</tt>.',lib:'multicellweighscale&rarr;nextMultiCellWeighScale()',pro:'YMultiCellWeighScale * nextMultiCellWeighScale()',cmt:'<p>Continues the enumeration of multi-cell weighing scale sensors started using <tt>yFirstMultiCellWeighScale()</tt>.</p>',ret:'a pointer to a <tt>YMultiCellWeighScale</tt> object, corresponding to a multi-cell weighing scale sensor currently online, or a <tt>null</tt> pointer if there are no more multi-cell weighing scale sensors to enumerate.'};
doc['MultiCellWeighScale']['registerTimedReportCallback']={syn:'Registers the callback function that is invoked on every periodic timed notification.',lib:'multicellweighscale&rarr;registerTimedReportCallback()',pro:'int registerTimedReportCallback(YMultiCellWeighScaleTimedReportCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every periodic timed notification. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and an YMeasure object describing the new advertised value.'}};
doc['MultiCellWeighScale']['registerValueCallback']={syn:'Registers the callback function that is invoked on every change of advertised value.',lib:'multicellweighscale&rarr;registerValueCallback()',pro:'int registerValueCallback(YMultiCellWeighScaleValueCallback <span id=pn>callback</span>)',cmt:'<p>Registers the callback function that is invoked on every change of advertised value. The callback is invoked only during the execution of <tt>ySleep</tt> or <tt>yHandleEvents</tt>. This provides control over the time when the callback is triggered. For good responsiveness, remember to call one of these two functions periodically. To unregister a callback, pass a null pointer as argument.</p>',par:{callback:'the callback function to call, or a null pointer. The callback function should take two arguments: the function object of which the value has changed, and the character string describing the new advertised value.'}};
doc['MultiCellWeighScale']['set_advMode']={syn:'Changes the measuring mode used for the advertised value pushed to the parent hub.',lib:'multicellweighscale&rarr;set_advMode()',pro:'int set_advMode(Y_ADVMODE_enum <span id=pn>newval</span>)',cmt:'<p>Changes the measuring mode used for the advertised value pushed to the parent hub.</p>',par:{newval:'a value among <tt>Y_ADVMODE_IMMEDIATE</tt>, <tt>Y_ADVMODE_PERIOD_AVG</tt>, <tt>Y_ADVMODE_PERIOD_MIN</tt> and <tt>Y_ADVMODE_PERIOD_MAX</tt> corresponding to the measuring mode used for the advertised value pushed to the parent hub'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_cellCount']={syn:'Changes the number of load cells in use.',lib:'multicellweighscale&rarr;set_cellCount()',pro:'int set_cellCount(int <span id=pn>newval</span>)',cmt:'<p>Changes the number of load cells in use.</p>',par:{newval:'an integer corresponding to the number of load cells in use'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_compTempAdaptRatio']={syn:'Changes the averaged temperature update rate, in percents.',lib:'multicellweighscale&rarr;set_compTempAdaptRatio()',pro:'int set_compTempAdaptRatio(double <span id=pn>newval</span>)',cmt:'<p>Changes the averaged temperature update rate, in percents. The averaged temperature is updated every 10 seconds, by applying this adaptation rate to the difference between the measures ambiant temperature and the current compensation temperature. The standard rate is 0.04 percents, and the maximal rate is 65 percents.</p>',par:{newval:'a floating point number corresponding to the averaged temperature update rate, in percents'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_excitation']={syn:'Changes the current load cell bridge excitation method.',lib:'multicellweighscale&rarr;set_excitation()',pro:'int set_excitation(Y_EXCITATION_enum <span id=pn>newval</span>)',cmt:'<p>Changes the current load cell bridge excitation method.</p>',par:{newval:'a value among <tt>Y_EXCITATION_OFF</tt>, <tt>Y_EXCITATION_DC</tt> and <tt>Y_EXCITATION_AC</tt> corresponding to the current load cell bridge excitation method'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_highestValue']={syn:'Changes the recorded maximal value observed.',lib:'multicellweighscale&rarr;set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded maximal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded maximal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_logFrequency']={syn:'Changes the datalogger recording frequency for this function.',lib:'multicellweighscale&rarr;set_logFrequency()',pro:'int set_logFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the datalogger recording frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable recording for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the datalogger recording frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_logicalName']={syn:'Changes the logical name of the multi-cell weighing scale sensor.',lib:'multicellweighscale&rarr;set_logicalName()',pro:'int set_logicalName(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the logical name of the multi-cell weighing scale sensor. You can use <tt>yCheckLogicalName()</tt> prior to this call to make sure that your parameter is valid. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the logical name of the multi-cell weighing scale sensor.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_lowestValue']={syn:'Changes the recorded minimal value observed.',lib:'multicellweighscale&rarr;set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Changes the recorded minimal value observed. Can be used to reset the value returned by get_lowestValue().</p>',par:{newval:'a floating point number corresponding to the recorded minimal value observed'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_reportFrequency']={syn:'Changes the timed value notification frequency for this function.',lib:'multicellweighscale&rarr;set_reportFrequency()',pro:'int set_reportFrequency(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the timed value notification frequency for this function. The frequency can be specified as samples per second, as sample per minute (for instance \x2215/m\x22) or in samples per hour (eg. \x224/h\x22). To disable timed value notifications for this function, use the value \x22OFF\x22.</p>',par:{newval:'a string corresponding to the timed value notification frequency for this function'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_resolution']={syn:'Changes the resolution of the measured physical values.',lib:'multicellweighscale&rarr;set_resolution()',pro:'int set_resolution(double <span id=pn>newval</span>)',cmt:'<p>Changes the resolution of the measured physical values. The resolution corresponds to the numerical precision when displaying value. It does not change the precision of the measure itself.</p>',par:{newval:'a floating point number corresponding to the resolution of the measured physical values'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_unit']={syn:'Changes the measuring unit for the weight.',lib:'multicellweighscale&rarr;set_unit()',pro:'int set_unit(const string&amp; <span id=pn>newval</span>)',cmt:'<p>Changes the measuring unit for the weight. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',par:{newval:'a string corresponding to the measuring unit for the weight'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['set_userData']={syn:'Stores a user context provided as argument in the userData attribute of the function.',lib:'multicellweighscale&rarr;set_userData()',pro:'void set_userData(void* <span id=pn>data</span>)',cmt:'<p>Stores a user context provided as argument in the userData attribute of the function. This attribute is never touched by the API, and is at disposal of the caller to store a context.</p>',par:{data:'any kind of object to be stored'}};
doc['MultiCellWeighScale']['set_zeroTracking']={syn:'Changes the zero tracking threshold value.',lib:'multicellweighscale&rarr;set_zeroTracking()',pro:'int set_zeroTracking(double <span id=pn>newval</span>)',cmt:'<p>Changes the zero tracking threshold value. When this threshold is larger than zero, any measure under the threshold will automatically be ignored and the zero compensation will be updated.</p>',par:{newval:'a floating point number corresponding to the zero tracking threshold value'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['setupSpan']={syn:'Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.',lib:'multicellweighscale&rarr;setupSpan()',pro:'int setupSpan(double <span id=pn>currWeight</span>, double <span id=pn>maxWeight</span>)',cmt:'<p>Configures the load cells span parameters (stored in the corresponding genericSensors) so that the current signal corresponds to the specified reference weight.</p>',par:{currWeight:'reference weight presently on the load cell.',maxWeight:'maximum weight to be expectect on the load cell.'},ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['startDataLogger']={syn:'Starts the data logger on the device.',lib:'multicellweighscale&rarr;startDataLogger()',pro:'int startDataLogger()',cmt:'<p>Starts the data logger on the device. Note that the data logger will only save the measures on this sensor if the logFrequency is not set to \x22OFF\x22.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['MultiCellWeighScale']['stopDataLogger']={syn:'Stops the datalogger on the device.',lib:'multicellweighscale&rarr;stopDataLogger()',pro:'int stopDataLogger()',cmt:'<p>Stops the datalogger on the device.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.'};
doc['MultiCellWeighScale']['tare']={syn:'Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.',lib:'multicellweighscale&rarr;tare()',pro:'int tare()',cmt:'<p>Adapts the load cell signal bias (stored in the corresponding genericSensor) so that the current signal corresponds to a zero weight.</p>',ret:'<tt>YAPI_SUCCESS</tt> if the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
doc['MultiCellWeighScale']['unmuteValueCallbacks']={syn:'Re-enables the propagation of every new advertised value to the parent hub.',lib:'multicellweighscale&rarr;unmuteValueCallbacks()',pro:'int unmuteValueCallbacks()',cmt:'<p>Re-enables the propagation of every new advertised value to the parent hub. This function reverts the effect of a previous call to <tt>muteValueCallbacks()</tt>. Remember to call the <tt>saveToFlash()</tt> method of the module if the modification must be kept.</p>',ret:'<tt>YAPI_SUCCESS</tt> when the call succeeds.',ext:'On failure, throws an exception or returns a negative error code.'};
//--- (end of generated code: MultiCellWeighScale)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 }

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);
 }

function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);
 }

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 }

function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }

function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist."
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 }

function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }

function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."
    it.style.top  = parseInt(t) + "px";
 }

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }

function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }

function computeWinWH()
 { WinW             = GetWindowWidth() ;
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight();
   if (WinH<400) WinH=400;
}


 function getInnerHeight()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );
 }

 function getInnerWidth()
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct)
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct;
  }

function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++)
      resizeCallBacks[i]();
  }

function jsQuote(str_in)
{ str_in = str_in+'';
  var str_out   = '';
  for (i=0;i<str_in.length;i++)
   {
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex;
      }
   }
   return str_out;
  }


function resizeMargin()
 {
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 }

function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110);
 }

function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 }

function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches)
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }
  return new positionObject(x,y);
 }


function EnableDrag(var_element,onDragMove,onDragEnd)
  {
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }
   else
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);

   if (onDragMove)  var_element.onDragMove = onDragMove;
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;
  }

 var LastDraggedObject = null;

 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos)
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;

   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }

   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }

   if (event.preventDefault)   event.preventDefault();
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source,
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    }
   document.onmouseup   =   Drag_stopMouseCapture;
 }


function Drag_mouseCapture(event)
 {
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault();


   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y);

   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;

   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;

   var p = {x:x,y:y};

   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);

   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;

   lastDraggedObject.element.style.left = p.x+"px";
   lastDraggedObject.element.style.top  = p.y+"px";
 }

function Drag_stopMouseCapture()
 {
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent)
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }

  if (lastDraggedObject)
    { lastDraggedObject.element.style.cursor='col-resize';
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }

 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin()
  }

 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  {
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }

    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex;
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par)
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'
          }

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }

         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml;
  }

  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }
  }

 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname)
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'><img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";

       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }
       }
       marginhtml = marginhtml+'</div>'
    }

    document.getElementById("MarginLayer").innerHTML = marginhtml;
  }

 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()

    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }

    for (var i=0;i<tosearch.length;i++)
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }

          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;

          if (!found) return false;
       }


    return true;

  }

 var searchTimer = null;

 function doSearch()
  { searchTimer = null;
    var value= document.forms['yoctoForm'].elements['search'].value;

    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           }
          container["originalDisplay"]=null;
        }
        Show(lastindex_shown,lastname_shown);
       return;
      }

    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');
       for (var method in doc[classname])

         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}
                 }
              else
                 { if (it) it.style.display="none";
                 }
         }

      if  (matchfound)
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }

    Show(firstindex,firstname);


  }

 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }

 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown);
    Show(lastindex_shown,lastname_shown);

  }




 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form>
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" >
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" '+ (UseShortcuts?'checked':'') + ' onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;


 }
doc = sortObject(doc);
ShowFunctions();
Show(doc["YAPI"]?"YAPI":"Module","");


window.onresize = windowResized;
-->
</script>

</BODY>


</HEAD>

